/*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 * 
 * SPDX-License-Identifier: Apache-2.0
 * 
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file     STM32G061.sfd
 * @brief    CMSIS-SVD SFD File
 * @version  0.2
 * @date     04. August 2022
 * @note     Generated by SVDConv V3.3.39 on Thursday, 04.08.2022 20:08:16
 *           from File 'STM32G061.svd',
 *           last modified on Thursday, 16.12.2021 00:30:22
 */




// ---------------------------  Register Item Address: ADC_ADC_ISR  -------------------------------
// SVD Line: 49

unsigned int ADC_ADC_ISR __AT (0x40012400);



// ------------------------------  Field Item: ADC_ADC_ISR_ADRDY  ---------------------------------
// SVD Line: 58

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_ADRDY
//    <name> ADRDY </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012400) \nADC ready  This bit is set by hardware after the ADC has been enabled (ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests.  It is cleared by software writing 1 to it.\n0 : B_0x0 = ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = ADC is ready to start conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.0..0> ADRDY
//        <0=> 0: B_0x0 = ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = ADC is ready to start conversion
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_EOSMP  ---------------------------------
// SVD Line: 79

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_EOSMP
//    <name> EOSMP </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012400) \nEnd of sampling flag  This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1.\n0 : B_0x0 = Not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = End of sampling phase reached </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.1..1> EOSMP
//        <0=> 0: B_0x0 = Not at the end of the sampling phase (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = End of sampling phase reached
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: ADC_ADC_ISR_EOC  ----------------------------------
// SVD Line: 99

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_EOC
//    <name> EOC </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012400) \nEnd of conversion flag  This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.\n0 : B_0x0 = Channel conversion not complete (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Channel conversion complete </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.2..2> EOC
//        <0=> 0: B_0x0 = Channel conversion not complete (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Channel conversion complete
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: ADC_ADC_ISR_EOS  ----------------------------------
// SVD Line: 119

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_EOS
//    <name> EOS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012400) \nEnd of sequence flag  This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.\n0 : B_0x0 = Conversion sequence not complete (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Conversion sequence complete </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.3..3> EOS
//        <0=> 0: B_0x0 = Conversion sequence not complete (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Conversion sequence complete
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: ADC_ADC_ISR_OVR  ----------------------------------
// SVD Line: 139

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_OVR
//    <name> OVR </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012400) \nADC overrun  This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.\n0 : B_0x0 = No overrun occurred (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Overrun has occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.4..4> OVR
//        <0=> 0: B_0x0 = No overrun occurred (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Overrun has occurred
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_AWD1  ----------------------------------
// SVD Line: 159

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD1
//    <name> AWD1 </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012400) \nAnalog watchdog 1 flag  This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.\n0 : B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Analog watchdog event occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.7..7> AWD1
//        <0=> 0: B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Analog watchdog event occurred
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_AWD2  ----------------------------------
// SVD Line: 179

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD2
//    <name> AWD2 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012400) \nAnalog watchdog 2 flag  This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.\n0 : B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Analog watchdog event occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.8..8> AWD2
//        <0=> 0: B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Analog watchdog event occurred
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_AWD3  ----------------------------------
// SVD Line: 199

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD3
//    <name> AWD3 </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012400) \nAnalog watchdog 3 flag  This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.\n0 : B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)\n1 : B_0x1 = Analog watchdog event occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.9..9> AWD3
//        <0=> 0: B_0x0 = No analog watchdog event occurred (or the flag event was already acknowledged and cleared by software)
//        <1=> 1: B_0x1 = Analog watchdog event occurred
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_EOCAL  ---------------------------------
// SVD Line: 219

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_EOCAL
//    <name> EOCAL </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012400) \nEnd Of Calibration flag  This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.\n0 : B_0x0 = Calibration is not complete\n1 : B_0x1 = Calibration is complete </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.11..11> EOCAL
//        <0=> 0: B_0x0 = Calibration is not complete
//        <1=> 1: B_0x1 = Calibration is complete
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_ISR_CCRDY  ---------------------------------
// SVD Line: 239

//  <item> SFDITEM_FIELD__ADC_ADC_ISR_CCRDY
//    <name> CCRDY </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012400) \nChannel Configuration Ready flag  This flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.  Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.\n0 : B_0x0 = Channel configuration update not applied.\n1 : B_0x1 = Channel configuration update is applied. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_ISR ) </loc>
//      <o.13..13> CCRDY
//        <0=> 0: B_0x0 = Channel configuration update not applied.
//        <1=> 1: B_0x1 = Channel configuration update is applied.
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: ADC_ADC_ISR  ----------------------------------
// SVD Line: 49

//  <rtree> SFDITEM_REG__ADC_ADC_ISR
//    <name> ADC_ISR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012400) ADC interrupt and status register </i>
//    <loc> ( (unsigned int)((ADC_ADC_ISR >> 0) & 0xFFFFFFFF), ((ADC_ADC_ISR = (ADC_ADC_ISR & ~(0x2B9FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x2B9F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_ADRDY </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_EOSMP </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_EOC </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_EOS </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_OVR </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_AWD3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_EOCAL </item>
//    <item> SFDITEM_FIELD__ADC_ADC_ISR_CCRDY </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: ADC_ADC_IER  -------------------------------
// SVD Line: 262

unsigned int ADC_ADC_IER __AT (0x40012404);



// -----------------------------  Field Item: ADC_ADC_IER_ADRDYIE  --------------------------------
// SVD Line: 271

//  <item> SFDITEM_FIELD__ADC_ADC_IER_ADRDYIE
//    <name> ADRDYIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012404) \nADC ready interrupt enable  This bit is set and cleared by software to enable/disable the ADC Ready interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = ADRDY interrupt disabled.\n1 : B_0x1 = ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.0..0> ADRDYIE
//        <0=> 0: B_0x0 = ADRDY interrupt disabled.
//        <1=> 1: B_0x1 = ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_EOSMPIE  --------------------------------
// SVD Line: 292

//  <item> SFDITEM_FIELD__ADC_ADC_IER_EOSMPIE
//    <name> EOSMPIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012404) \nEnd of sampling flag interrupt enable  This bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = EOSMP interrupt disabled.\n1 : B_0x1 = EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.1..1> EOSMPIE
//        <0=> 0: B_0x0 = EOSMP interrupt disabled.
//        <1=> 1: B_0x1 = EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_IER_EOCIE  ---------------------------------
// SVD Line: 313

//  <item> SFDITEM_FIELD__ADC_ADC_IER_EOCIE
//    <name> EOCIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012404) \nEnd of conversion interrupt enable  This bit is set and cleared by software to enable/disable the end of conversion interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = EOC interrupt disabled\n1 : B_0x1 = EOC interrupt enabled. An interrupt is generated when the EOC bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.2..2> EOCIE
//        <0=> 0: B_0x0 = EOC interrupt disabled
//        <1=> 1: B_0x1 = EOC interrupt enabled. An interrupt is generated when the EOC bit is set.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_IER_EOSIE  ---------------------------------
// SVD Line: 334

//  <item> SFDITEM_FIELD__ADC_ADC_IER_EOSIE
//    <name> EOSIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012404) \nEnd of conversion sequence interrupt enable  This bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = EOS interrupt disabled\n1 : B_0x1 = EOS interrupt enabled. An interrupt is generated when the EOS bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.3..3> EOSIE
//        <0=> 0: B_0x0 = EOS interrupt disabled
//        <1=> 1: B_0x1 = EOS interrupt enabled. An interrupt is generated when the EOS bit is set.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_IER_OVRIE  ---------------------------------
// SVD Line: 355

//  <item> SFDITEM_FIELD__ADC_ADC_IER_OVRIE
//    <name> OVRIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012404) \nOverrun interrupt enable  This bit is set and cleared by software to enable/disable the overrun interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Overrun interrupt disabled\n1 : B_0x1 = Overrun interrupt enabled. An interrupt is generated when the OVR bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.4..4> OVRIE
//        <0=> 0: B_0x0 = Overrun interrupt disabled
//        <1=> 1: B_0x1 = Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_AWD1IE  ---------------------------------
// SVD Line: 376

//  <item> SFDITEM_FIELD__ADC_ADC_IER_AWD1IE
//    <name> AWD1IE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012404) \nAnalog watchdog 1 interrupt enable  This bit is set and cleared by software to enable/disable the analog watchdog interrupt.  Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Analog watchdog interrupt disabled\n1 : B_0x1 = Analog watchdog interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.7..7> AWD1IE
//        <0=> 0: B_0x0 = Analog watchdog interrupt disabled
//        <1=> 1: B_0x1 = Analog watchdog interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_AWD2IE  ---------------------------------
// SVD Line: 397

//  <item> SFDITEM_FIELD__ADC_ADC_IER_AWD2IE
//    <name> AWD2IE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012404) \nAnalog watchdog 2 interrupt enable  This bit is set and cleared by software to enable/disable the analog watchdog interrupt.  Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Analog watchdog interrupt disabled\n1 : B_0x1 = Analog watchdog interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.8..8> AWD2IE
//        <0=> 0: B_0x0 = Analog watchdog interrupt disabled
//        <1=> 1: B_0x1 = Analog watchdog interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_AWD3IE  ---------------------------------
// SVD Line: 418

//  <item> SFDITEM_FIELD__ADC_ADC_IER_AWD3IE
//    <name> AWD3IE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012404) \nAnalog watchdog 3 interrupt enable  This bit is set and cleared by software to enable/disable the analog watchdog interrupt.  Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Analog watchdog interrupt disabled\n1 : B_0x1 = Analog watchdog interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.9..9> AWD3IE
//        <0=> 0: B_0x0 = Analog watchdog interrupt disabled
//        <1=> 1: B_0x1 = Analog watchdog interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_EOCALIE  --------------------------------
// SVD Line: 439

//  <item> SFDITEM_FIELD__ADC_ADC_IER_EOCALIE
//    <name> EOCALIE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012404) \nEnd of calibration interrupt enable  This bit is set and cleared by software to enable/disable the end of calibration interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = End of calibration interrupt disabled\n1 : B_0x1 = End of calibration interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.11..11> EOCALIE
//        <0=> 0: B_0x0 = End of calibration interrupt disabled
//        <1=> 1: B_0x1 = End of calibration interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_IER_CCRDYIE  --------------------------------
// SVD Line: 460

//  <item> SFDITEM_FIELD__ADC_ADC_IER_CCRDYIE
//    <name> CCRDYIE </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012404) \nChannel Configuration Ready Interrupt enable  This bit is set and cleared by software to enable/disable the channel configuration ready interrupt.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Channel configuration ready interrupt disabled\n1 : B_0x1 = Channel configuration ready interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_IER ) </loc>
//      <o.13..13> CCRDYIE
//        <0=> 0: B_0x0 = Channel configuration ready interrupt disabled
//        <1=> 1: B_0x1 = Channel configuration ready interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: ADC_ADC_IER  ----------------------------------
// SVD Line: 262

//  <rtree> SFDITEM_REG__ADC_ADC_IER
//    <name> ADC_IER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012404) ADC interrupt enable register </i>
//    <loc> ( (unsigned int)((ADC_ADC_IER >> 0) & 0xFFFFFFFF), ((ADC_ADC_IER = (ADC_ADC_IER & ~(0x2B9FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x2B9F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_ADRDYIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_EOSMPIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_EOCIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_EOSIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_OVRIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_AWD1IE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_AWD2IE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_AWD3IE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_EOCALIE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_IER_CCRDYIE </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: ADC_ADC_CR  -------------------------------
// SVD Line: 483

unsigned int ADC_ADC_CR __AT (0x40012408);



// -------------------------------  Field Item: ADC_ADC_CR_ADEN  ----------------------------------
// SVD Line: 492

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADEN
//    <name> ADEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012408) \nADC enable command  This bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.  It is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.  Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0, ADSTP=0, ADSTART=0, ADDIS=0 and ADEN=0)\n0 : B_0x0 = ADC is disabled (OFF state)\n1 : B_0x1 = Write 1 to enable the ADC. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.0..0> ADEN
//        <0=> 0: B_0x0 = ADC is disabled (OFF state)
//        <1=> 1: B_0x1 = Write 1 to enable the ADC.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_CR_ADDIS  ----------------------------------
// SVD Line: 514

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADDIS
//    <name> ADDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012408) \nADC disable command  This bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).  It is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).  Note: Setting ADDIS to '1 is only effective when ADEN=1 and ADSTART=0 (which ensures that no conversion is ongoing)\n0 : B_0x0 = No ADDIS command ongoing\n1 : B_0x1 = Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.1..1> ADDIS
//        <0=> 0: B_0x0 = No ADDIS command ongoing
//        <1=> 1: B_0x1 = Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CR_ADSTART  ---------------------------------
// SVD Line: 536

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADSTART
//    <name> ADSTART </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012408) \nADC start conversion command  This bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).  It is cleared by hardware:  In single conversion mode (CONT=0, DISCEN=0), when software trigger is selected (EXTEN=00): at the assertion of the end of Conversion Sequence (EOS) flag.  In discontinuous conversion mode(CONT=0, DISCEN=1), when the software trigger is selected (EXTEN=00): at the assertion of the end of Conversion (EOC) flag.  In all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.  Note: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC).  After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.\n0 : B_0x0 = No ADC conversion is ongoing.\n1 : B_0x1 = Write 1 to start the ADC. Read 1 means that the ADC is operating and may be converting. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.2..2> ADSTART
//        <0=> 0: B_0x0 = No ADC conversion is ongoing.
//        <1=> 1: B_0x1 = Write 1 to start the ADC. Read 1 means that the ADC is operating and may be converting.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_CR_ADSTP  ----------------------------------
// SVD Line: 562

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADSTP
//    <name> ADSTP </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012408) \nADC stop conversion command  This bit is set by software to stop and discard an ongoing conversion (ADSTP Command).  It is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.  Note: Setting ADSTP to '1 is only effective when ADSTART=1 and ADDIS=0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)\n0 : B_0x0 = No ADC stop conversion command ongoing\n1 : B_0x1 = Write 1 to stop the ADC. Read 1 means that an ADSTP command is in progress. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.4..4> ADSTP
//        <0=> 0: B_0x0 = No ADC stop conversion command ongoing
//        <1=> 1: B_0x1 = Write 1 to stop the ADC. Read 1 means that an ADSTP command is in progress.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CR_ADVREGEN  --------------------------------
// SVD Line: 584

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADVREGEN
//    <name> ADVREGEN </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40012408) \nADC Voltage Regulator Enable  This bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP.  It is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.  Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n0 : B_0x0 = ADC voltage regulator disabled\n1 : B_0x1 = ADC voltage regulator enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.28..28> ADVREGEN
//        <0=> 0: B_0x0 = ADC voltage regulator disabled
//        <1=> 1: B_0x1 = ADC voltage regulator enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_CR_ADCAL  ----------------------------------
// SVD Line: 606

//  <item> SFDITEM_FIELD__ADC_ADC_CR_ADCAL
//    <name> ADCAL </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40012408) \nADC calibration  This bit is set by software to start the calibration of the ADC.  It is cleared by hardware after calibration is complete.  Note: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).  The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN=1 and ADSTART=0 (ADC enabled and no conversion is ongoing).\n0 : B_0x0 = Calibration complete\n1 : B_0x1 = Write 1 to calibrate the ADC. Read at 1 means that a calibration is in progress. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CR ) </loc>
//      <o.31..31> ADCAL
//        <0=> 0: B_0x0 = Calibration complete
//        <1=> 1: B_0x1 = Write 1 to calibrate the ADC. Read at 1 means that a calibration is in progress.
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: ADC_ADC_CR  -----------------------------------
// SVD Line: 483

//  <rtree> SFDITEM_REG__ADC_ADC_CR
//    <name> ADC_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012408) ADC control register </i>
//    <loc> ( (unsigned int)((ADC_ADC_CR >> 0) & 0xFFFFFFFF), ((ADC_ADC_CR = (ADC_ADC_CR & ~(0x90000017UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x90000017) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADDIS </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADSTART </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADSTP </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADVREGEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CR_ADCAL </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_CFGR1  ------------------------------
// SVD Line: 631

unsigned int ADC_ADC_CFGR1 __AT (0x4001240C);



// -----------------------------  Field Item: ADC_ADC_CFGR1_DMAEN  --------------------------------
// SVD Line: 640

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DMAEN
//    <name> DMAEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4001240C) \nDirect memory access enable  This bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to .  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = DMA disabled\n1 : B_0x1 = DMA enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.0..0> DMAEN
//        <0=> 0: B_0x0 = DMA disabled
//        <1=> 1: B_0x1 = DMA enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_DMACFG  --------------------------------
// SVD Line: 661

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DMACFG
//    <name> DMACFG </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4001240C) \nDirect memory access configuration  This bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN=1.  For more details, refer to page391  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = DMA one shot mode selected\n1 : B_0x1 = DMA circular mode selected </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.1..1> DMACFG
//        <0=> 0: B_0x0 = DMA one shot mode selected
//        <1=> 1: B_0x1 = DMA circular mode selected
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_SCANDIR  -------------------------------
// SVD Line: 683

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_SCANDIR
//    <name> SCANDIR </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4001240C) \nScan sequence direction  This bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Upward scan (from CHSEL0 to CHSEL18)\n1 : B_0x1 = Backward scan (from CHSEL18 to CHSEL0) </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.2..2> SCANDIR
//        <0=> 0: B_0x0 = Upward scan (from CHSEL0 to CHSEL18)
//        <1=> 1: B_0x1 = Backward scan (from CHSEL18 to CHSEL0)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_CFGR1_RES  ---------------------------------
// SVD Line: 705

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_RES
//    <name> RES </name>
//    <rw> 
//    <i> [Bits 4..3] RW (@ 0x4001240C) \nData resolution  These bits are written by software to select the resolution of the conversion.  Note: The software is allowed to write these bits only when ADEN=0.\n0 : B_0x0 = 12 bits\n1 : B_0x1 = 10 bits\n2 : B_0x2 = 8 bits\n3 : B_0x3 = 6 bits </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.4..3> RES
//        <0=> 0: B_0x0 = 12 bits
//        <1=> 1: B_0x1 = 10 bits
//        <2=> 2: B_0x2 = 8 bits
//        <3=> 3: B_0x3 = 6 bits
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR1_ALIGN  --------------------------------
// SVD Line: 736

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_ALIGN
//    <name> ALIGN </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x4001240C) \nData alignment  This bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page389  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Right alignment\n1 : B_0x1 = Left alignment </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.5..5> ALIGN
//        <0=> 0: B_0x0 = Right alignment
//        <1=> 1: B_0x1 = Left alignment
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_EXTSEL  --------------------------------
// SVD Line: 757

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_EXTSEL
//    <name> EXTSEL </name>
//    <rw> 
//    <i> [Bits 8..6] RW (@ 0x4001240C) \nExternal trigger selection  These bits select the external event used to trigger the start of conversion (refer to External triggers for details):  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = TRG0\n1 : B_0x1 = TRG1\n2 : B_0x2 = TRG2\n3 : B_0x3 = TRG3\n4 : B_0x4 = TRG4\n5 : B_0x5 = TRG5\n6 : B_0x6 = TRG6\n7 : B_0x7 = TRG7 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.8..6> EXTSEL
//        <0=> 0: B_0x0 = TRG0
//        <1=> 1: B_0x1 = TRG1
//        <2=> 2: B_0x2 = TRG2
//        <3=> 3: B_0x3 = TRG3
//        <4=> 4: B_0x4 = TRG4
//        <5=> 5: B_0x5 = TRG5
//        <6=> 6: B_0x6 = TRG6
//        <7=> 7: B_0x7 = TRG7
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR1_EXTEN  --------------------------------
// SVD Line: 808

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_EXTEN
//    <name> EXTEN </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x4001240C) \nExternal trigger enable and polarity selection  These bits are set and cleared by software to select the external trigger polarity and enable the trigger.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Hardware trigger detection disabled (conversions can be started by software)\n1 : B_0x1 = Hardware trigger detection on the rising edge\n2 : B_0x2 = Hardware trigger detection on the falling edge\n3 : B_0x3 = Hardware trigger detection on both the rising and falling edges </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.11..10> EXTEN
//        <0=> 0: B_0x0 = Hardware trigger detection disabled (conversions can be started by software)
//        <1=> 1: B_0x1 = Hardware trigger detection on the rising edge
//        <2=> 2: B_0x2 = Hardware trigger detection on the falling edge
//        <3=> 3: B_0x3 = Hardware trigger detection on both the rising and falling edges
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_OVRMOD  --------------------------------
// SVD Line: 839

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_OVRMOD
//    <name> OVRMOD </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x4001240C) \nOverrun management mode  This bit is set and cleared by software and configure the way data overruns are managed.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = ADC_DR register is preserved with the old data when an overrun is detected.\n1 : B_0x1 = ADC_DR register is overwritten with the last conversion result when an overrun is detected. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.12..12> OVRMOD
//        <0=> 0: B_0x0 = ADC_DR register is preserved with the old data when an overrun is detected.
//        <1=> 1: B_0x1 = ADC_DR register is overwritten with the last conversion result when an overrun is detected.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR1_CONT  ---------------------------------
// SVD Line: 860

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_CONT
//    <name> CONT </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x4001240C) \nSingle / continuous conversion mode  This bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.  Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.  The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Single conversion mode\n1 : B_0x1 = Continuous conversion mode </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.13..13> CONT
//        <0=> 0: B_0x0 = Single conversion mode
//        <1=> 1: B_0x1 = Continuous conversion mode
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR1_WAIT  ---------------------------------
// SVD Line: 882

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_WAIT
//    <name> WAIT </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x4001240C) \nWait conversion mode  This bit is set and cleared by software to enable/disable wait conversion mode..  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Wait conversion mode off\n1 : B_0x1 = Wait conversion mode on </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.14..14> WAIT
//        <0=> 0: B_0x0 = Wait conversion mode off
//        <1=> 1: B_0x1 = Wait conversion mode on
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_AUTOFF  --------------------------------
// SVD Line: 903

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AUTOFF
//    <name> AUTOFF </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x4001240C) \nAuto-off mode  This bit is set and cleared by software to enable/disable auto-off mode..  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Auto-off mode disabled\n1 : B_0x1 = Auto-off mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.15..15> AUTOFF
//        <0=> 0: B_0x0 = Auto-off mode disabled
//        <1=> 1: B_0x1 = Auto-off mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_DISCEN  --------------------------------
// SVD Line: 924

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DISCEN
//    <name> DISCEN </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x4001240C) \nDiscontinuous mode  This bit is set and cleared by software to enable/disable discontinuous mode.  Note: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.  The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Discontinuous mode disabled\n1 : B_0x1 = Discontinuous mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.16..16> DISCEN
//        <0=> 0: B_0x0 = Discontinuous mode disabled
//        <1=> 1: B_0x1 = Discontinuous mode enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CFGR1_CHSELRMOD  ------------------------------
// SVD Line: 946

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_CHSELRMOD
//    <name> CHSELRMOD </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x4001240C) \nMode selection of the ADC_CHSELR register  This bit is set and cleared by software to control the ADC_CHSELR feature:  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Each bit of the ADC_CHSELR register enables an input\n1 : B_0x1 = ADC_CHSELR register is able to sequence up to 8 channels </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.21..21> CHSELRMOD
//        <0=> 0: B_0x0 = Each bit of the ADC_CHSELR register enables an input
//        <1=> 1: B_0x1 = ADC_CHSELR register is able to sequence up to 8 channels
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_AWD1SGL  -------------------------------
// SVD Line: 968

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1SGL
//    <name> AWD1SGL </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x4001240C) \nEnable the watchdog on a single channel or on all channels  This bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Analog watchdog 1 enabled on all channels\n1 : B_0x1 = Analog watchdog 1 enabled on a single channel </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.22..22> AWD1SGL
//        <0=> 0: B_0x0 = Analog watchdog 1 enabled on all channels
//        <1=> 1: B_0x1 = Analog watchdog 1 enabled on a single channel
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_AWD1EN  --------------------------------
// SVD Line: 989

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1EN
//    <name> AWD1EN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x4001240C) \nAnalog watchdog enable  This bit is set and cleared by software.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Analog watchdog 1 disabled\n1 : B_0x1 = Analog watchdog 1 enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.23..23> AWD1EN
//        <0=> 0: B_0x0 = Analog watchdog 1 disabled
//        <1=> 1: B_0x1 = Analog watchdog 1 enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR1_AWD1CH  --------------------------------
// SVD Line: 1010

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1CH
//    <name> AWD1CH </name>
//    <rw> 
//    <i> [Bits 30..26] RW (@ 0x4001240C) \nAnalog watchdog channel selection  These bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.  .....  Others: Reserved  Note: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.  The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog input Channel 0 monitored by AWD\n1 : B_0x1 = ADC analog input Channel 1 monitored by AWD\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = ADC analog input Channel 17 monitored by AWD\n18 : B_0x12 = ADC analog input Channel 18 monitored by AWD\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR1 ) </loc>
//      <o.30..26> AWD1CH
//        <0=> 0: B_0x0 = ADC analog input Channel 0 monitored by AWD
//        <1=> 1: B_0x1 = ADC analog input Channel 1 monitored by AWD
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = ADC analog input Channel 17 monitored by AWD
//        <18=> 18: B_0x12 = ADC analog input Channel 18 monitored by AWD
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: ADC_ADC_CFGR1  ---------------------------------
// SVD Line: 631

//  <rtree> SFDITEM_REG__ADC_ADC_CFGR1
//    <name> ADC_CFGR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001240C) ADC configuration register 1 </i>
//    <loc> ( (unsigned int)((ADC_ADC_CFGR1 >> 0) & 0xFFFFFFFF), ((ADC_ADC_CFGR1 = (ADC_ADC_CFGR1 & ~(0x7CE1FDFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7CE1FDFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DMAEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DMACFG </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_SCANDIR </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_RES </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_ALIGN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_EXTSEL </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_EXTEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_OVRMOD </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_CONT </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_WAIT </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AUTOFF </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_DISCEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_CHSELRMOD </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1SGL </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1EN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR1_AWD1CH </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_CFGR2  ------------------------------
// SVD Line: 1046

unsigned int ADC_ADC_CFGR2 __AT (0x40012410);



// -----------------------------  Field Item: ADC_ADC_CFGR2_OVSE  ---------------------------------
// SVD Line: 1055

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSE
//    <name> OVSE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012410) \nOversampler Enable  This bit is set and cleared by software.  Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Oversampler disabled\n1 : B_0x1 = Oversampler enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.0..0> OVSE
//        <0=> 0: B_0x0 = Oversampler disabled
//        <1=> 1: B_0x1 = Oversampler enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR2_OVSR  ---------------------------------
// SVD Line: 1076

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSR
//    <name> OVSR </name>
//    <rw> 
//    <i> [Bits 4..2] RW (@ 0x40012410) \nOversampling ratio  This bit filed defines the number of oversampling ratio.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = 2x\n1 : B_0x1 = 4x\n2 : B_0x2 = 8x\n3 : B_0x3 = 16x\n4 : B_0x4 = 32x\n5 : B_0x5 = 64x\n6 : B_0x6 = 128x\n7 : B_0x7 = 256x </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.4..2> OVSR
//        <0=> 0: B_0x0 = 2x
//        <1=> 1: B_0x1 = 4x
//        <2=> 2: B_0x2 = 8x
//        <3=> 3: B_0x3 = 16x
//        <4=> 4: B_0x4 = 32x
//        <5=> 5: B_0x5 = 64x
//        <6=> 6: B_0x6 = 128x
//        <7=> 7: B_0x7 = 256x
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR2_OVSS  ---------------------------------
// SVD Line: 1127

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSS
//    <name> OVSS </name>
//    <rw> 
//    <i> [Bits 8..5] RW (@ 0x40012410) \nOversampling shift  This bit is set and cleared by software.  Others: Reserved  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = No shift\n1 : B_0x1 = Shift 1-bit\n2 : B_0x2 = Shift 2-bits\n3 : B_0x3 = Shift 3-bits\n4 : B_0x4 = Shift 4-bits\n5 : B_0x5 = Shift 5-bits\n6 : B_0x6 = Shift 6-bits\n7 : B_0x7 = Shift 7-bits\n8 : B_0x8 = Shift 8-bits\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.8..5> OVSS
//        <0=> 0: B_0x0 = No shift
//        <1=> 1: B_0x1 = Shift 1-bit
//        <2=> 2: B_0x2 = Shift 2-bits
//        <3=> 3: B_0x3 = Shift 3-bits
//        <4=> 4: B_0x4 = Shift 4-bits
//        <5=> 5: B_0x5 = Shift 5-bits
//        <6=> 6: B_0x6 = Shift 6-bits
//        <7=> 7: B_0x7 = Shift 7-bits
//        <8=> 8: B_0x8 = Shift 8-bits
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CFGR2_TOVS  ---------------------------------
// SVD Line: 1184

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_TOVS
//    <name> TOVS </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012410) \nTriggered Oversampling  This bit is set and cleared by software.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = All oversampled conversions for a channel are done consecutively after a trigger\n1 : B_0x1 = Each oversampled conversion for a channel needs a trigger </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.9..9> TOVS
//        <0=> 0: B_0x0 = All oversampled conversions for a channel are done consecutively after a trigger
//        <1=> 1: B_0x1 = Each oversampled conversion for a channel needs a trigger
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR2_LFTRIG  --------------------------------
// SVD Line: 1205

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_LFTRIG
//    <name> LFTRIG </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40012410) \nLow frequency trigger mode enable  This bit is set and cleared by software.  Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\n0 : B_0x0 = Low Frequency Trigger Mode disabled\n1 : B_0x1 = Low Frequency Trigger Mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.29..29> LFTRIG
//        <0=> 0: B_0x0 = Low Frequency Trigger Mode disabled
//        <1=> 1: B_0x1 = Low Frequency Trigger Mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_CFGR2_CKMODE  --------------------------------
// SVD Line: 1226

//  <item> SFDITEM_FIELD__ADC_ADC_CFGR2_CKMODE
//    <name> CKMODE </name>
//    <rw> 
//    <i> [Bits 31..30] RW (@ 0x40012410) \nADC clock mode  These bits are set and cleared by software to define how the analog ADC is clocked:  In all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.  Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n0 : B_0x0 = ADCCLK (Asynchronous clock mode), generated at product level (refer to RCC section)\n1 : B_0x1 = PCLK/2 (Synchronous clock mode)\n2 : B_0x2 = PCLK/4 (Synchronous clock mode)\n3 : B_0x3 = PCLK (Synchronous clock mode). This configuration must be enabled only if PCLK has a 50% duty clock cycle (APB prescaler configured inside the RCC must be bypassed and the system clock must by 50% duty cycle) </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CFGR2 ) </loc>
//      <o.31..30> CKMODE
//        <0=> 0: B_0x0 = ADCCLK (Asynchronous clock mode), generated at product level (refer to RCC section)
//        <1=> 1: B_0x1 = PCLK/2 (Synchronous clock mode)
//        <2=> 2: B_0x2 = PCLK/4 (Synchronous clock mode)
//        <3=> 3: B_0x3 = PCLK (Synchronous clock mode). This configuration must be enabled only if PCLK has a 50% duty clock cycle (APB prescaler configured inside the RCC must be bypassed and the system clock must by 50% duty cycle)
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: ADC_ADC_CFGR2  ---------------------------------
// SVD Line: 1046

//  <rtree> SFDITEM_REG__ADC_ADC_CFGR2
//    <name> ADC_CFGR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012410) ADC configuration register 2 </i>
//    <loc> ( (unsigned int)((ADC_ADC_CFGR2 >> 0) & 0xFFFFFFFF), ((ADC_ADC_CFGR2 = (ADC_ADC_CFGR2 & ~(0xE00003FDUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE00003FD) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSE </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSR </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_OVSS </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_TOVS </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_LFTRIG </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CFGR2_CKMODE </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: ADC_ADC_SMPR  ------------------------------
// SVD Line: 1260

unsigned int ADC_ADC_SMPR __AT (0x40012414);



// ------------------------------  Field Item: ADC_ADC_SMPR_SMP1  ---------------------------------
// SVD Line: 1269

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMP1
//    <name> SMP1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40012414) \nSampling time selection 1  These bits are written by software to select the sampling time that applies to all channels.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = 1.5 ADC clock cycles\n1 : B_0x1 = 3.5 ADC clock cycles\n2 : B_0x2 = 7.5 ADC clock cycles\n3 : B_0x3 = 12.5 ADC clock cycles\n4 : B_0x4 = 19.5 ADC clock cycles\n5 : B_0x5 = 39.5 ADC clock cycles\n6 : B_0x6 = 79.5 ADC clock cycles\n7 : B_0x7 = 160.5 ADC clock cycles </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.2..0> SMP1
//        <0=> 0: B_0x0 = 1.5 ADC clock cycles
//        <1=> 1: B_0x1 = 3.5 ADC clock cycles
//        <2=> 2: B_0x2 = 7.5 ADC clock cycles
//        <3=> 3: B_0x3 = 12.5 ADC clock cycles
//        <4=> 4: B_0x4 = 19.5 ADC clock cycles
//        <5=> 5: B_0x5 = 39.5 ADC clock cycles
//        <6=> 6: B_0x6 = 79.5 ADC clock cycles
//        <7=> 7: B_0x7 = 160.5 ADC clock cycles
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_SMPR_SMP2  ---------------------------------
// SVD Line: 1320

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMP2
//    <name> SMP2 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012414) \nSampling time selection 2  These bits are written by software to select the sampling time that applies to all channels.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = 1.5 ADC clock cycles\n1 : B_0x1 = 3.5 ADC clock cycles\n2 : B_0x2 = 7.5 ADC clock cycles\n3 : B_0x3 = 12.5 ADC clock cycles\n4 : B_0x4 = 19.5 ADC clock cycles\n5 : B_0x5 = 39.5 ADC clock cycles\n6 : B_0x6 = 79.5 ADC clock cycles\n7 : B_0x7 = 160.5 ADC clock cycles </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.6..4> SMP2
//        <0=> 0: B_0x0 = 1.5 ADC clock cycles
//        <1=> 1: B_0x1 = 3.5 ADC clock cycles
//        <2=> 2: B_0x2 = 7.5 ADC clock cycles
//        <3=> 3: B_0x3 = 12.5 ADC clock cycles
//        <4=> 4: B_0x4 = 19.5 ADC clock cycles
//        <5=> 5: B_0x5 = 39.5 ADC clock cycles
//        <6=> 6: B_0x6 = 79.5 ADC clock cycles
//        <7=> 7: B_0x7 = 160.5 ADC clock cycles
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL0  --------------------------------
// SVD Line: 1371

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL0
//    <name> SMPSEL0 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.8..8> SMPSEL0
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL1  --------------------------------
// SVD Line: 1393

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL1
//    <name> SMPSEL1 </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.9..9> SMPSEL1
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL2  --------------------------------
// SVD Line: 1415

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL2
//    <name> SMPSEL2 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.10..10> SMPSEL2
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL3  --------------------------------
// SVD Line: 1437

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL3
//    <name> SMPSEL3 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.11..11> SMPSEL3
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL4  --------------------------------
// SVD Line: 1459

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL4
//    <name> SMPSEL4 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.12..12> SMPSEL4
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL5  --------------------------------
// SVD Line: 1481

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL5
//    <name> SMPSEL5 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.13..13> SMPSEL5
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL6  --------------------------------
// SVD Line: 1503

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL6
//    <name> SMPSEL6 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.14..14> SMPSEL6
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL7  --------------------------------
// SVD Line: 1525

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL7
//    <name> SMPSEL7 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.15..15> SMPSEL7
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL8  --------------------------------
// SVD Line: 1547

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL8
//    <name> SMPSEL8 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.16..16> SMPSEL8
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL9  --------------------------------
// SVD Line: 1569

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL9
//    <name> SMPSEL9 </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.17..17> SMPSEL9
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL10  -------------------------------
// SVD Line: 1591

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL10
//    <name> SMPSEL10 </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.18..18> SMPSEL10
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL11  -------------------------------
// SVD Line: 1613

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL11
//    <name> SMPSEL11 </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.19..19> SMPSEL11
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL12  -------------------------------
// SVD Line: 1635

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL12
//    <name> SMPSEL12 </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.20..20> SMPSEL12
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL13  -------------------------------
// SVD Line: 1657

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL13
//    <name> SMPSEL13 </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.21..21> SMPSEL13
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL14  -------------------------------
// SVD Line: 1679

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL14
//    <name> SMPSEL14 </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.22..22> SMPSEL14
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL15  -------------------------------
// SVD Line: 1701

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL15
//    <name> SMPSEL15 </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.23..23> SMPSEL15
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL16  -------------------------------
// SVD Line: 1723

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL16
//    <name> SMPSEL16 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.24..24> SMPSEL16
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL17  -------------------------------
// SVD Line: 1745

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL17
//    <name> SMPSEL17 </name>
//    <rw> 
//    <i> [Bit 25] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.25..25> SMPSEL17
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: ADC_ADC_SMPR_SMPSEL18  -------------------------------
// SVD Line: 1767

//  <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL18
//    <name> SMPSEL18 </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40012414) \nChannel-x sampling time selection  These bits are written by software to define which sampling time is used.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.\n1 : B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register. </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_SMPR ) </loc>
//      <o.26..26> SMPSEL18
//        <0=> 0: B_0x0 = Sampling time of CHANNELx use the setting of SMP1[2:0] register.
//        <1=> 1: B_0x1 = Sampling time of CHANNELx use the setting of SMP2[2:0] register.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: ADC_ADC_SMPR  ----------------------------------
// SVD Line: 1260

//  <rtree> SFDITEM_REG__ADC_ADC_SMPR
//    <name> ADC_SMPR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012414) ADC sampling time register </i>
//    <loc> ( (unsigned int)((ADC_ADC_SMPR >> 0) & 0xFFFFFFFF), ((ADC_ADC_SMPR = (ADC_ADC_SMPR & ~(0x7FFFF77UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFF77) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMP1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMP2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL0 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL4 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL5 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL6 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL7 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL8 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL9 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL10 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL11 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL12 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL13 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL14 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL15 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL16 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL17 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_SMPR_SMPSEL18 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_AWD1TR  -----------------------------
// SVD Line: 1791

unsigned int ADC_ADC_AWD1TR __AT (0x40012420);



// -----------------------------  Field Item: ADC_ADC_AWD1TR_LT1  ---------------------------------
// SVD Line: 1800

//  <item> SFDITEM_FIELD__ADC_ADC_AWD1TR_LT1
//    <name> LT1 </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40012420) Analog watchdog 1 lower threshold  These bits are written by software to define the lower threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD1TR >> 0) & 0xFFF), ((ADC_ADC_AWD1TR = (ADC_ADC_AWD1TR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_AWD1TR_HT1  ---------------------------------
// SVD Line: 1809

//  <item> SFDITEM_FIELD__ADC_ADC_AWD1TR_HT1
//    <name> HT1 </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x40012420) Analog watchdog 1 higher threshold  These bits are written by software to define the higher threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD1TR >> 16) & 0xFFF), ((ADC_ADC_AWD1TR = (ADC_ADC_AWD1TR & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_AWD1TR  ---------------------------------
// SVD Line: 1791

//  <rtree> SFDITEM_REG__ADC_ADC_AWD1TR
//    <name> ADC_AWD1TR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012420) ADC watchdog threshold register </i>
//    <loc> ( (unsigned int)((ADC_ADC_AWD1TR >> 0) & 0xFFFFFFFF), ((ADC_ADC_AWD1TR = (ADC_ADC_AWD1TR & ~(0xFFF0FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD1TR_LT1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD1TR_HT1 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_AWD2TR  -----------------------------
// SVD Line: 1820

unsigned int ADC_ADC_AWD2TR __AT (0x40012424);



// -----------------------------  Field Item: ADC_ADC_AWD2TR_LT2  ---------------------------------
// SVD Line: 1829

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2TR_LT2
//    <name> LT2 </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40012424) Analog watchdog 2 lower threshold  These bits are written by software to define the lower threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD2TR >> 0) & 0xFFF), ((ADC_ADC_AWD2TR = (ADC_ADC_AWD2TR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_AWD2TR_HT2  ---------------------------------
// SVD Line: 1838

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2TR_HT2
//    <name> HT2 </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x40012424) Analog watchdog 2 higher threshold  These bits are written by software to define the higher threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD2TR >> 16) & 0xFFF), ((ADC_ADC_AWD2TR = (ADC_ADC_AWD2TR & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_AWD2TR  ---------------------------------
// SVD Line: 1820

//  <rtree> SFDITEM_REG__ADC_ADC_AWD2TR
//    <name> ADC_AWD2TR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012424) ADC watchdog threshold register </i>
//    <loc> ( (unsigned int)((ADC_ADC_AWD2TR >> 0) & 0xFFFFFFFF), ((ADC_ADC_AWD2TR = (ADC_ADC_AWD2TR & ~(0xFFF0FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2TR_LT2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2TR_HT2 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: ADC_ADC_CHSELRMOD0  ---------------------------
// SVD Line: 1849

unsigned int ADC_ADC_CHSELRMOD0 __AT (0x40012428);



// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL0  -----------------------------
// SVD Line: 1858

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL0
//    <name> CHSEL0 </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.0..0> CHSEL0
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL1  -----------------------------
// SVD Line: 1881

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL1
//    <name> CHSEL1 </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.1..1> CHSEL1
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL2  -----------------------------
// SVD Line: 1904

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL2
//    <name> CHSEL2 </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.2..2> CHSEL2
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL3  -----------------------------
// SVD Line: 1927

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL3
//    <name> CHSEL3 </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.3..3> CHSEL3
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL4  -----------------------------
// SVD Line: 1950

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL4
//    <name> CHSEL4 </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.4..4> CHSEL4
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL5  -----------------------------
// SVD Line: 1973

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL5
//    <name> CHSEL5 </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.5..5> CHSEL5
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL6  -----------------------------
// SVD Line: 1996

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL6
//    <name> CHSEL6 </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.6..6> CHSEL6
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL7  -----------------------------
// SVD Line: 2019

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL7
//    <name> CHSEL7 </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.7..7> CHSEL7
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL8  -----------------------------
// SVD Line: 2042

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL8
//    <name> CHSEL8 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.8..8> CHSEL8
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// --------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL9  -----------------------------
// SVD Line: 2065

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL9
//    <name> CHSEL9 </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.9..9> CHSEL9
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL10  -----------------------------
// SVD Line: 2088

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL10
//    <name> CHSEL10 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.10..10> CHSEL10
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL11  -----------------------------
// SVD Line: 2111

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL11
//    <name> CHSEL11 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.11..11> CHSEL11
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL12  -----------------------------
// SVD Line: 2134

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL12
//    <name> CHSEL12 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.12..12> CHSEL12
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL13  -----------------------------
// SVD Line: 2157

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL13
//    <name> CHSEL13 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.13..13> CHSEL13
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL14  -----------------------------
// SVD Line: 2180

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL14
//    <name> CHSEL14 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.14..14> CHSEL14
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL15  -----------------------------
// SVD Line: 2203

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL15
//    <name> CHSEL15 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.15..15> CHSEL15
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL16  -----------------------------
// SVD Line: 2226

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL16
//    <name> CHSEL16 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.16..16> CHSEL16
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL17  -----------------------------
// SVD Line: 2249

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL17
//    <name> CHSEL17 </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.17..17> CHSEL17
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// -------------------------  Field Item: ADC_ADC_CHSELRMOD0_CHSEL18  -----------------------------
// SVD Line: 2272

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL18
//    <name> CHSEL18 </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40012428) \nChannel-x selection  These bits are written by software and define which channels are part of the sequence of channels to be converted.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).  If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.\n0 : B_0x0 = Input Channel-x is not selected for conversion\n1 : B_0x1 = Input Channel-x is selected for conversion </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD0 ) </loc>
//      <o.18..18> CHSEL18
//        <0=> 0: B_0x0 = Input Channel-x is not selected for conversion
//        <1=> 1: B_0x1 = Input Channel-x is selected for conversion
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: ADC_ADC_CHSELRMOD0  -------------------------------
// SVD Line: 1849

//  <rtree> SFDITEM_REG__ADC_ADC_CHSELRMOD0
//    <name> ADC_CHSELRMOD0 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012428) ADC channel selection register </i>
//    <loc> ( (unsigned int)((ADC_ADC_CHSELRMOD0 >> 0) & 0xFFFFFFFF), ((ADC_ADC_CHSELRMOD0 = (ADC_ADC_CHSELRMOD0 & ~(0x7FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL0 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL4 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL5 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL6 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL7 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL8 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL9 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL10 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL11 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL12 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL13 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL14 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL15 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL16 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL17 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD0_CHSEL18 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: ADC_ADC_CHSELRMOD1  ---------------------------
// SVD Line: 2297

unsigned int ADC_ADC_CHSELRMOD1 __AT (0x40012428);



// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ1  -------------------------------
// SVD Line: 2307

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ1
//    <name> SQ1 </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40012428) 1st conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 0) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ2  -------------------------------
// SVD Line: 2318

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ2
//    <name> SQ2 </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40012428) 2nd conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 4) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ3  -------------------------------
// SVD Line: 2329

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ3
//    <name> SQ3 </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40012428) 3rd conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 8) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ4  -------------------------------
// SVD Line: 2340

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ4
//    <name> SQ4 </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40012428) 4th conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 12) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ5  -------------------------------
// SVD Line: 2351

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ5
//    <name> SQ5 </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40012428) 5th conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 16) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ6  -------------------------------
// SVD Line: 2362

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ6
//    <name> SQ6 </name>
//    <rw> 
//    <i> [Bits 23..20] RW (@ 0x40012428) 6th conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 20) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 20 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 20 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ7  -------------------------------
// SVD Line: 2373

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ7
//    <name> SQ7 </name>
//    <rw> 
//    <i> [Bits 27..24] RW (@ 0x40012428) 7th conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  Refer to SQ8[3:0] for a definition of channel selection.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing). </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CHSELRMOD1 >> 24) & 0xF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_CHSELRMOD1_SQ8  -------------------------------
// SVD Line: 2384

//  <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ8
//    <name> SQ8 </name>
//    <rw> 
//    <i> [Bits 31..28] RW (@ 0x40012428) \n8th conversion of the sequence  These bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.  When 0b1111 (end of sequence) is programmed to the lower sequence channels, these bits are ignored.  ...  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = CH0\n1 : B_0x1 = CH1\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : B_0xC = CH12\n13 : B_0xD = CH13\n14 : B_0xE = CH14\n15 : B_0xF = No channel selected (End of sequence) </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CHSELRMOD1 ) </loc>
//      <o.31..28> SQ8
//        <0=> 0: B_0x0 = CH0
//        <1=> 1: B_0x1 = CH1
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: B_0xC = CH12
//        <13=> 13: B_0xD = CH13
//        <14=> 14: B_0xE = CH14
//        <15=> 15: B_0xF = No channel selected (End of sequence)
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: ADC_ADC_CHSELRMOD1  -------------------------------
// SVD Line: 2297

//  <rtree> SFDITEM_REG__ADC_ADC_CHSELRMOD1
//    <name> ADC_CHSELRMOD1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012428) ADC channel selection register </i>
//    <loc> ( (unsigned int)((ADC_ADC_CHSELRMOD1 >> 0) & 0xFFFFFFFF), ((ADC_ADC_CHSELRMOD1 = (ADC_ADC_CHSELRMOD1 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ4 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ5 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ6 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ7 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CHSELRMOD1_SQ8 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_AWD3TR  -----------------------------
// SVD Line: 2429

unsigned int ADC_ADC_AWD3TR __AT (0x4001242C);



// -----------------------------  Field Item: ADC_ADC_AWD3TR_LT3  ---------------------------------
// SVD Line: 2438

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3TR_LT3
//    <name> LT3 </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x4001242C) Analog watchdog 3lower threshold  These bits are written by software to define the lower threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD3TR >> 0) & 0xFFF), ((ADC_ADC_AWD3TR = (ADC_ADC_AWD3TR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_AWD3TR_HT3  ---------------------------------
// SVD Line: 2447

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3TR_HT3
//    <name> HT3 </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x4001242C) Analog watchdog 3 higher threshold  These bits are written by software to define the higher threshold for the analog watchdog.  Refer to ADC_AWDxTR) on page395. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_AWD3TR >> 16) & 0xFFF), ((ADC_ADC_AWD3TR = (ADC_ADC_AWD3TR & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_AWD3TR  ---------------------------------
// SVD Line: 2429

//  <rtree> SFDITEM_REG__ADC_ADC_AWD3TR
//    <name> ADC_AWD3TR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001242C) ADC watchdog threshold register </i>
//    <loc> ( (unsigned int)((ADC_ADC_AWD3TR >> 0) & 0xFFFFFFFF), ((ADC_ADC_AWD3TR = (ADC_ADC_AWD3TR & ~(0xFFF0FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3TR_LT3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3TR_HT3 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: ADC_ADC_DR  -------------------------------
// SVD Line: 2458

unsigned int ADC_ADC_DR __AT (0x40012440);



// -------------------------------  Field Item: ADC_ADC_DR_DATA  ----------------------------------
// SVD Line: 2467

//  <item> SFDITEM_FIELD__ADC_ADC_DR_DATA
//    <name> DATA </name>
//    <r> 
//    <i> [Bits 15..0] RO (@ 0x40012440) Converted data  These bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page389.  Just after a calibration is complete, DATA[6:0] contains the calibration factor. </i>
//    <edit> 
//      <loc> ( (unsigned short)((ADC_ADC_DR >> 0) & 0xFFFF) ) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: ADC_ADC_DR  -----------------------------------
// SVD Line: 2458

//  <rtree> SFDITEM_REG__ADC_ADC_DR
//    <name> ADC_DR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40012440) ADC data register </i>
//    <loc> ( (unsigned int)((ADC_ADC_DR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_DR_DATA </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_AWD2CR  -----------------------------
// SVD Line: 2478

unsigned int ADC_ADC_AWD2CR __AT (0x400124A0);



// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH0  -------------------------------
// SVD Line: 2487

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH0
//    <name> AWD2CH0 </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.0..0> AWD2CH0
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH1  -------------------------------
// SVD Line: 2509

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH1
//    <name> AWD2CH1 </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.1..1> AWD2CH1
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH2  -------------------------------
// SVD Line: 2531

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH2
//    <name> AWD2CH2 </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.2..2> AWD2CH2
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH3  -------------------------------
// SVD Line: 2553

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH3
//    <name> AWD2CH3 </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.3..3> AWD2CH3
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH4  -------------------------------
// SVD Line: 2575

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH4
//    <name> AWD2CH4 </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.4..4> AWD2CH4
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH5  -------------------------------
// SVD Line: 2597

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH5
//    <name> AWD2CH5 </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.5..5> AWD2CH5
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH6  -------------------------------
// SVD Line: 2619

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH6
//    <name> AWD2CH6 </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.6..6> AWD2CH6
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH7  -------------------------------
// SVD Line: 2641

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH7
//    <name> AWD2CH7 </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.7..7> AWD2CH7
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH8  -------------------------------
// SVD Line: 2663

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH8
//    <name> AWD2CH8 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.8..8> AWD2CH8
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH9  -------------------------------
// SVD Line: 2685

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH9
//    <name> AWD2CH9 </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.9..9> AWD2CH9
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH10  ------------------------------
// SVD Line: 2707

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH10
//    <name> AWD2CH10 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.10..10> AWD2CH10
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH11  ------------------------------
// SVD Line: 2729

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH11
//    <name> AWD2CH11 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.11..11> AWD2CH11
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH12  ------------------------------
// SVD Line: 2751

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH12
//    <name> AWD2CH12 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.12..12> AWD2CH12
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH13  ------------------------------
// SVD Line: 2773

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH13
//    <name> AWD2CH13 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.13..13> AWD2CH13
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH14  ------------------------------
// SVD Line: 2795

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH14
//    <name> AWD2CH14 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.14..14> AWD2CH14
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH15  ------------------------------
// SVD Line: 2817

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH15
//    <name> AWD2CH15 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.15..15> AWD2CH15
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH16  ------------------------------
// SVD Line: 2839

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH16
//    <name> AWD2CH16 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.16..16> AWD2CH16
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH17  ------------------------------
// SVD Line: 2861

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH17
//    <name> AWD2CH17 </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.17..17> AWD2CH17
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD2CR_AWD2CH18  ------------------------------
// SVD Line: 2883

//  <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH18
//    <name> AWD2CH18 </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x400124A0) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).  Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD2\n1 : B_0x1 = ADC analog channel-x is monitored by AWD2 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD2CR ) </loc>
//      <o.18..18> AWD2CH18
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD2
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD2
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_AWD2CR  ---------------------------------
// SVD Line: 2478

//  <rtree> SFDITEM_REG__ADC_ADC_AWD2CR
//    <name> ADC_AWD2CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x400124A0) ADC Analog Watchdog 2 Configuration register </i>
//    <loc> ( (unsigned int)((ADC_ADC_AWD2CR >> 0) & 0xFFFFFFFF), ((ADC_ADC_AWD2CR = (ADC_ADC_AWD2CR & ~(0x7FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH0 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH4 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH5 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH6 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH7 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH8 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH9 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH10 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH11 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH12 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH13 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH14 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH15 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH16 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH17 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD2CR_AWD2CH18 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: ADC_ADC_AWD3CR  -----------------------------
// SVD Line: 2907

unsigned int ADC_ADC_AWD3CR __AT (0x400124A4);



// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH0  -------------------------------
// SVD Line: 2916

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH0
//    <name> AWD3CH0 </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.0..0> AWD3CH0
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH1  -------------------------------
// SVD Line: 2938

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH1
//    <name> AWD3CH1 </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.1..1> AWD3CH1
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH2  -------------------------------
// SVD Line: 2960

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH2
//    <name> AWD3CH2 </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.2..2> AWD3CH2
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH3  -------------------------------
// SVD Line: 2982

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH3
//    <name> AWD3CH3 </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.3..3> AWD3CH3
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH4  -------------------------------
// SVD Line: 3004

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH4
//    <name> AWD3CH4 </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.4..4> AWD3CH4
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH5  -------------------------------
// SVD Line: 3026

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH5
//    <name> AWD3CH5 </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.5..5> AWD3CH5
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH6  -------------------------------
// SVD Line: 3048

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH6
//    <name> AWD3CH6 </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.6..6> AWD3CH6
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH7  -------------------------------
// SVD Line: 3070

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH7
//    <name> AWD3CH7 </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.7..7> AWD3CH7
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH8  -------------------------------
// SVD Line: 3092

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH8
//    <name> AWD3CH8 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.8..8> AWD3CH8
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH9  -------------------------------
// SVD Line: 3114

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH9
//    <name> AWD3CH9 </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.9..9> AWD3CH9
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH10  ------------------------------
// SVD Line: 3136

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH10
//    <name> AWD3CH10 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.10..10> AWD3CH10
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH11  ------------------------------
// SVD Line: 3158

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH11
//    <name> AWD3CH11 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.11..11> AWD3CH11
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH12  ------------------------------
// SVD Line: 3180

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH12
//    <name> AWD3CH12 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.12..12> AWD3CH12
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH13  ------------------------------
// SVD Line: 3202

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH13
//    <name> AWD3CH13 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.13..13> AWD3CH13
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH14  ------------------------------
// SVD Line: 3224

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH14
//    <name> AWD3CH14 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.14..14> AWD3CH14
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH15  ------------------------------
// SVD Line: 3246

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH15
//    <name> AWD3CH15 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.15..15> AWD3CH15
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH16  ------------------------------
// SVD Line: 3268

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH16
//    <name> AWD3CH16 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.16..16> AWD3CH16
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH17  ------------------------------
// SVD Line: 3290

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH17
//    <name> AWD3CH17 </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.17..17> AWD3CH17
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: ADC_ADC_AWD3CR_AWD3CH18  ------------------------------
// SVD Line: 3312

//  <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH18
//    <name> AWD3CH18 </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x400124A4) \nAnalog watchdog channel selection  These bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).  Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = ADC analog channel-x is not monitored by AWD3\n1 : B_0x1 = ADC analog channel-x is monitored by AWD3 </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_AWD3CR ) </loc>
//      <o.18..18> AWD3CH18
//        <0=> 0: B_0x0 = ADC analog channel-x is not monitored by AWD3
//        <1=> 1: B_0x1 = ADC analog channel-x is monitored by AWD3
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_AWD3CR  ---------------------------------
// SVD Line: 2907

//  <rtree> SFDITEM_REG__ADC_ADC_AWD3CR
//    <name> ADC_AWD3CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x400124A4) ADC Analog Watchdog 3 Configuration register </i>
//    <loc> ( (unsigned int)((ADC_ADC_AWD3CR >> 0) & 0xFFFFFFFF), ((ADC_ADC_AWD3CR = (ADC_ADC_AWD3CR & ~(0x7FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH0 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH1 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH2 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH3 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH4 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH5 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH6 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH7 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH8 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH9 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH10 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH11 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH12 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH13 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH14 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH15 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH16 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH17 </item>
//    <item> SFDITEM_FIELD__ADC_ADC_AWD3CR_AWD3CH18 </item>
//  </rtree>
//  


// -------------------------  Register Item Address: ADC_ADC_CALFACT  -----------------------------
// SVD Line: 3336

unsigned int ADC_ADC_CALFACT __AT (0x400124B4);



// ---------------------------  Field Item: ADC_ADC_CALFACT_CALFACT  ------------------------------
// SVD Line: 3345

//  <item> SFDITEM_FIELD__ADC_ADC_CALFACT_CALFACT
//    <name> CALFACT </name>
//    <rw> 
//    <i> [Bits 6..0] RW (@ 0x400124B4) Calibration factor  These bits are written by hardware or by software.  Once a calibration is complete,they are updated by hardware with the calibration factors.  Software can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.  Just after a calibration is complete, DATA[6:0] contains the calibration factor.  Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection. </i>
//    <edit> 
//      <loc> ( (unsigned char)((ADC_ADC_CALFACT >> 0) & 0x7F), ((ADC_ADC_CALFACT = (ADC_ADC_CALFACT & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: ADC_ADC_CALFACT  --------------------------------
// SVD Line: 3336

//  <rtree> SFDITEM_REG__ADC_ADC_CALFACT
//    <name> ADC_CALFACT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x400124B4) ADC Calibration factor </i>
//    <loc> ( (unsigned int)((ADC_ADC_CALFACT >> 0) & 0xFFFFFFFF), ((ADC_ADC_CALFACT = (ADC_ADC_CALFACT & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CALFACT_CALFACT </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: ADC_ADC_CCR  -------------------------------
// SVD Line: 3359

unsigned int ADC_ADC_CCR __AT (0x40012708);



// ------------------------------  Field Item: ADC_ADC_CCR_PRESC  ---------------------------------
// SVD Line: 3368

//  <item> SFDITEM_FIELD__ADC_ADC_CCR_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 21..18] RW (@ 0x40012708) \nADC prescaler Set and cleared by software to select the frequency of the clock to the ADC. Other: Reserved Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n0 : B_0x0 = input ADC clock not divided\n1 : B_0x1 = input ADC clock divided by 2\n2 : B_0x2 = input ADC clock divided by 4\n3 : B_0x3 = input ADC clock divided by 6\n4 : B_0x4 = input ADC clock divided by 8\n5 : B_0x5 = input ADC clock divided by 10\n6 : B_0x6 = input ADC clock divided by 12\n7 : B_0x7 = input ADC clock divided by 16\n8 : B_0x8 = input ADC clock divided by 32\n9 : B_0x9 = input ADC clock divided by 64\n10 : B_0xA = input ADC clock divided by 128\n11 : B_0xB = input ADC clock divided by 256\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CCR ) </loc>
//      <o.21..18> PRESC
//        <0=> 0: B_0x0 = input ADC clock not divided
//        <1=> 1: B_0x1 = input ADC clock divided by 2
//        <2=> 2: B_0x2 = input ADC clock divided by 4
//        <3=> 3: B_0x3 = input ADC clock divided by 6
//        <4=> 4: B_0x4 = input ADC clock divided by 8
//        <5=> 5: B_0x5 = input ADC clock divided by 10
//        <6=> 6: B_0x6 = input ADC clock divided by 12
//        <7=> 7: B_0x7 = input ADC clock divided by 16
//        <8=> 8: B_0x8 = input ADC clock divided by 32
//        <9=> 9: B_0x9 = input ADC clock divided by 64
//        <10=> 10: B_0xA = input ADC clock divided by 128
//        <11=> 11: B_0xB = input ADC clock divided by 256
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CCR_VREFEN  ---------------------------------
// SVD Line: 3440

//  <item> SFDITEM_FIELD__ADC_ADC_CCR_VREFEN
//    <name> VREFEN </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40012708) \nVREFINT enable  This bit is set and cleared by software to enable/disable the VREFINT.  Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = VREFINT disabled\n1 : B_0x1 = VREFINT enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CCR ) </loc>
//      <o.22..22> VREFEN
//        <0=> 0: B_0x0 = VREFINT disabled
//        <1=> 1: B_0x1 = VREFINT enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: ADC_ADC_CCR_TSEN  ----------------------------------
// SVD Line: 3461

//  <item> SFDITEM_FIELD__ADC_ADC_CCR_TSEN
//    <name> TSEN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40012708) \nTemperature sensor enable  This bit is set and cleared by software to enable/disable the temperature sensor.  Note: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\n0 : B_0x0 = Temperature sensor disabled, DAC_OUT1 connected to ADC channel 12\n1 : B_0x1 = Temperature sensor enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CCR ) </loc>
//      <o.23..23> TSEN
//        <0=> 0: B_0x0 = Temperature sensor disabled, DAC_OUT1 connected to ADC channel 12
//        <1=> 1: B_0x1 = Temperature sensor enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: ADC_ADC_CCR_VBATEN  ---------------------------------
// SVD Line: 3482

//  <item> SFDITEM_FIELD__ADC_ADC_CCR_VBATEN
//    <name> VBATEN </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012708) \nVBAT enable  This bit is set and cleared by software to enable/disable the VBAT channel.  Note: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)\n0 : B_0x0 = VBAT channel disabled, DAC_OUT2 connected to ADC channel 14\n1 : B_0x1 = VBAT channel enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) ADC_ADC_CCR ) </loc>
//      <o.24..24> VBATEN
//        <0=> 0: B_0x0 = VBAT channel disabled, DAC_OUT2 connected to ADC channel 14
//        <1=> 1: B_0x1 = VBAT channel enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: ADC_ADC_CCR  ----------------------------------
// SVD Line: 3359

//  <rtree> SFDITEM_REG__ADC_ADC_CCR
//    <name> ADC_CCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012708) ADC common configuration register </i>
//    <loc> ( (unsigned int)((ADC_ADC_CCR >> 0) & 0xFFFFFFFF), ((ADC_ADC_CCR = (ADC_ADC_CCR & ~(0x1FC0000UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FC0000) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__ADC_ADC_CCR_PRESC </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CCR_VREFEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CCR_TSEN </item>
//    <item> SFDITEM_FIELD__ADC_ADC_CCR_VBATEN </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: ADC  --------------------------------------
// SVD Line: 38

//  <view> ADC
//    <name> ADC </name>
//    <item> SFDITEM_REG__ADC_ADC_ISR </item>
//    <item> SFDITEM_REG__ADC_ADC_IER </item>
//    <item> SFDITEM_REG__ADC_ADC_CR </item>
//    <item> SFDITEM_REG__ADC_ADC_CFGR1 </item>
//    <item> SFDITEM_REG__ADC_ADC_CFGR2 </item>
//    <item> SFDITEM_REG__ADC_ADC_SMPR </item>
//    <item> SFDITEM_REG__ADC_ADC_AWD1TR </item>
//    <item> SFDITEM_REG__ADC_ADC_AWD2TR </item>
//    <item> SFDITEM_REG__ADC_ADC_CHSELRMOD0 </item>
//    <item> SFDITEM_REG__ADC_ADC_CHSELRMOD1 </item>
//    <item> SFDITEM_REG__ADC_ADC_AWD3TR </item>
//    <item> SFDITEM_REG__ADC_ADC_DR </item>
//    <item> SFDITEM_REG__ADC_ADC_AWD2CR </item>
//    <item> SFDITEM_REG__ADC_ADC_AWD3CR </item>
//    <item> SFDITEM_REG__ADC_ADC_CALFACT </item>
//    <item> SFDITEM_REG__ADC_ADC_CCR </item>
//  </view>
//  


// ----------------------------  Register Item Address: CRC_CRC_DR  -------------------------------
// SVD Line: 3519

unsigned int CRC_CRC_DR __AT (0x40023000);



// --------------------------------  Field Item: CRC_CRC_DR_DR  -----------------------------------
// SVD Line: 3528

//  <item> SFDITEM_FIELD__CRC_CRC_DR_DR
//    <name> DR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023000) Data register bits </i>
//    <edit> 
//      <loc> ( (unsigned int)((CRC_CRC_DR >> 0) & 0xFFFFFFFF), ((CRC_CRC_DR = (CRC_CRC_DR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: CRC_CRC_DR  -----------------------------------
// SVD Line: 3519

//  <rtree> SFDITEM_REG__CRC_CRC_DR
//    <name> CRC_DR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023000) Data register </i>
//    <loc> ( (unsigned int)((CRC_CRC_DR >> 0) & 0xFFFFFFFF), ((CRC_CRC_DR = (CRC_CRC_DR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__CRC_CRC_DR_DR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: CRC_CRC_IDR  -------------------------------
// SVD Line: 3536

unsigned int CRC_CRC_IDR __AT (0x40023004);



// -------------------------------  Field Item: CRC_CRC_IDR_IDR  ----------------------------------
// SVD Line: 3545

//  <item> SFDITEM_FIELD__CRC_CRC_IDR_IDR
//    <name> IDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023004) General-purpose 32-bit data register  bits </i>
//    <edit> 
//      <loc> ( (unsigned int)((CRC_CRC_IDR >> 0) & 0xFFFFFFFF), ((CRC_CRC_IDR = (CRC_CRC_IDR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: CRC_CRC_IDR  ----------------------------------
// SVD Line: 3536

//  <rtree> SFDITEM_REG__CRC_CRC_IDR
//    <name> CRC_IDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023004) Independent data register </i>
//    <loc> ( (unsigned int)((CRC_CRC_IDR >> 0) & 0xFFFFFFFF), ((CRC_CRC_IDR = (CRC_CRC_IDR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__CRC_CRC_IDR_IDR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: CRC_CRC_CR  -------------------------------
// SVD Line: 3554

unsigned int CRC_CRC_CR __AT (0x40023008);



// -----------------------------  Field Item: CRC_CRC_CR_REV_OUT  ---------------------------------
// SVD Line: 3562

//  <item> SFDITEM_FIELD__CRC_CRC_CR_REV_OUT
//    <name> REV_OUT </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40023008) \nReverse output data This bit controls the reversal of the bit order of the output data.\n0 : B_0x0 = Bit order not affected\n1 : B_0x1 = Bit-reversed output format </i>
//    <combo> 
//      <loc> ( (unsigned int) CRC_CRC_CR ) </loc>
//      <o.7..7> REV_OUT
//        <0=> 0: B_0x0 = Bit order not affected
//        <1=> 1: B_0x1 = Bit-reversed output format
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: CRC_CRC_CR_REV_IN  ---------------------------------
// SVD Line: 3582

//  <item> SFDITEM_FIELD__CRC_CRC_CR_REV_IN
//    <name> REV_IN </name>
//    <rw> 
//    <i> [Bits 6..5] RW (@ 0x40023008) \nReverse input data These bits control the reversal of the bit order of the input data\n0 : B_0x0 = Bit order not affected\n1 : B_0x1 = Bit reversal done by byte\n2 : B_0x2 = Bit reversal done by half-word\n3 : B_0x3 = Bit reversal done by word </i>
//    <combo> 
//      <loc> ( (unsigned int) CRC_CRC_CR ) </loc>
//      <o.6..5> REV_IN
//        <0=> 0: B_0x0 = Bit order not affected
//        <1=> 1: B_0x1 = Bit reversal done by byte
//        <2=> 2: B_0x2 = Bit reversal done by half-word
//        <3=> 3: B_0x3 = Bit reversal done by word
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: CRC_CRC_CR_POLYSIZE  --------------------------------
// SVD Line: 3612

//  <item> SFDITEM_FIELD__CRC_CRC_CR_POLYSIZE
//    <name> POLYSIZE </name>
//    <rw> 
//    <i> [Bits 4..3] RW (@ 0x40023008) \nPolynomial size These bits control the size of the polynomial.\n0 : B_0x0 = 32 bit polynomial\n1 : B_0x1 = 16 bit polynomial\n2 : B_0x2 = 8 bit polynomial\n3 : B_0x3 = 7 bit polynomial </i>
//    <combo> 
//      <loc> ( (unsigned int) CRC_CRC_CR ) </loc>
//      <o.4..3> POLYSIZE
//        <0=> 0: B_0x0 = 32 bit polynomial
//        <1=> 1: B_0x1 = 16 bit polynomial
//        <2=> 2: B_0x2 = 8 bit polynomial
//        <3=> 3: B_0x3 = 7 bit polynomial
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: CRC_CRC_CR_RESET  ----------------------------------
// SVD Line: 3642

//  <item> SFDITEM_FIELD__CRC_CRC_CR_RESET
//    <name> RESET </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40023008) RESET bit </i>
//    <check> 
//      <loc> ( (unsigned int) CRC_CRC_CR ) </loc>
//      <o.0..0> RESET
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: CRC_CRC_CR  -----------------------------------
// SVD Line: 3554

//  <rtree> SFDITEM_REG__CRC_CRC_CR
//    <name> CRC_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023008) Control register </i>
//    <loc> ( (unsigned int)((CRC_CRC_CR >> 0) & 0xFFFFFFFF), ((CRC_CRC_CR = (CRC_CRC_CR & ~(0xF9UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF9) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__CRC_CRC_CR_REV_OUT </item>
//    <item> SFDITEM_FIELD__CRC_CRC_CR_REV_IN </item>
//    <item> SFDITEM_FIELD__CRC_CRC_CR_POLYSIZE </item>
//    <item> SFDITEM_FIELD__CRC_CRC_CR_RESET </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: CRC_CRC_INIT  ------------------------------
// SVD Line: 3651

unsigned int CRC_CRC_INIT __AT (0x40023010);



// ----------------------------  Field Item: CRC_CRC_INIT_CRC_INIT  -------------------------------
// SVD Line: 3660

//  <item> SFDITEM_FIELD__CRC_CRC_INIT_CRC_INIT
//    <name> CRC_INIT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023010) Programmable initial CRC  value </i>
//    <edit> 
//      <loc> ( (unsigned int)((CRC_CRC_INIT >> 0) & 0xFFFFFFFF), ((CRC_CRC_INIT = (CRC_CRC_INIT & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: CRC_CRC_INIT  ----------------------------------
// SVD Line: 3651

//  <rtree> SFDITEM_REG__CRC_CRC_INIT
//    <name> CRC_INIT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023010) Initial CRC value </i>
//    <loc> ( (unsigned int)((CRC_CRC_INIT >> 0) & 0xFFFFFFFF), ((CRC_CRC_INIT = (CRC_CRC_INIT & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__CRC_CRC_INIT_CRC_INIT </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: CRC_CRC_POL  -------------------------------
// SVD Line: 3669

unsigned int CRC_CRC_POL __AT (0x40023014);



// -------------------------------  Field Item: CRC_CRC_POL_POL  ----------------------------------
// SVD Line: 3678

//  <item> SFDITEM_FIELD__CRC_CRC_POL_POL
//    <name> POL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023014) Programmable polynomial </i>
//    <edit> 
//      <loc> ( (unsigned int)((CRC_CRC_POL >> 0) & 0xFFFFFFFF), ((CRC_CRC_POL = (CRC_CRC_POL & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: CRC_CRC_POL  ----------------------------------
// SVD Line: 3669

//  <rtree> SFDITEM_REG__CRC_CRC_POL
//    <name> CRC_POL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40023014) polynomial </i>
//    <loc> ( (unsigned int)((CRC_CRC_POL >> 0) & 0xFFFFFFFF), ((CRC_CRC_POL = (CRC_CRC_POL & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__CRC_CRC_POL_POL </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: CRC  --------------------------------------
// SVD Line: 3507

//  <view> CRC
//    <name> CRC </name>
//    <item> SFDITEM_REG__CRC_CRC_DR </item>
//    <item> SFDITEM_REG__CRC_CRC_IDR </item>
//    <item> SFDITEM_REG__CRC_CRC_CR </item>
//    <item> SFDITEM_REG__CRC_CRC_INIT </item>
//    <item> SFDITEM_REG__CRC_CRC_POL </item>
//  </view>
//  


// ----------------------------  Register Item Address: DAC_DAC_CR  -------------------------------
// SVD Line: 3699

unsigned int DAC_DAC_CR __AT (0x40007400);



// -------------------------------  Field Item: DAC_DAC_CR_EN1  -----------------------------------
// SVD Line: 3708

//  <item> SFDITEM_FIELD__DAC_DAC_CR_EN1
//    <name> EN1 </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007400) \nDAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.\n0 : B_0x0 = DAC channel1 disabled\n1 : B_0x1 = DAC channel1 enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.0..0> EN1
//        <0=> 0: B_0x0 = DAC channel1 disabled
//        <1=> 1: B_0x1 = DAC channel1 enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: DAC_DAC_CR_TEN1  ----------------------------------
// SVD Line: 3728

//  <item> SFDITEM_FIELD__DAC_DAC_CR_TEN1
//    <name> TEN1 </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007400) \nDAC channel1 trigger enable This bit is set and cleared by software to enable/disable DAC channel1 trigger. Note: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle.\n0 : B_0x0 = DAC channel1 trigger disabled and data written into the DAC_DHR1 register are transferred one dac_pclk clock cycle later to the DAC_DOR1 register\n1 : B_0x1 = DAC channel1 trigger enabled and data from the DAC_DHR1 register are transferred three dac_pclk clock cycles later to the DAC_DOR1 register </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.1..1> TEN1
//        <0=> 0: B_0x0 = DAC channel1 trigger disabled and data written into the DAC_DHR1 register are transferred one dac_pclk clock cycle later to the DAC_DOR1 register
//        <1=> 1: B_0x1 = DAC channel1 trigger enabled and data from the DAC_DHR1 register are transferred three dac_pclk clock cycles later to the DAC_DOR1 register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_TSEL1  ----------------------------------
// SVD Line: 3749

//  <item> SFDITEM_FIELD__DAC_DAC_CR_TSEL1
//    <name> TSEL1 </name>
//    <rw> 
//    <i> [Bits 5..2] RW (@ 0x40007400) \nDAC channel1 trigger selection These bits select the external event used to trigger DAC channel1 ... Refer to the trigger selection tables in for details on trigger configuration and mapping. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).\n0 : B_0x0 = SWTRIG1\n1 : B_0x1 = dac_ch1_trg1\n2 : B_0x2 = dac_ch1_trg2\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : B_0xF = dac_ch1_trg15 </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.5..2> TSEL1
//        <0=> 0: B_0x0 = SWTRIG1
//        <1=> 1: B_0x1 = dac_ch1_trg1
//        <2=> 2: B_0x2 = dac_ch1_trg2
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: B_0xF = dac_ch1_trg15
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_WAVE1  ----------------------------------
// SVD Line: 3782

//  <item> SFDITEM_FIELD__DAC_DAC_CR_WAVE1
//    <name> WAVE1 </name>
//    <rw> 
//    <i> [Bits 7..6] RW (@ 0x40007400) \nDAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. 1x: Triangle wave generation enabled Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).\n0 : B_0x0 = wave generation disabled\n1 : B_0x1 = Noise wave generation enabled\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.7..6> WAVE1
//        <0=> 0: B_0x0 = wave generation disabled
//        <1=> 1: B_0x1 = Noise wave generation enabled
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_MAMP1  ----------------------------------
// SVD Line: 3804

//  <item> SFDITEM_FIELD__DAC_DAC_CR_MAMP1
//    <name> MAMP1 </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40007400) \nDAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.  1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095\n0 : B_0x0 = Unmask bit0 of LFSR/ triangle amplitude equal to 1\n1 : B_0x1 = Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3\n2 : B_0x2 = Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7\n3 : B_0x3 = Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15\n4 : B_0x4 = Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31\n5 : B_0x5 = Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63\n6 : B_0x6 = Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127\n7 : B_0x7 = Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255\n8 : B_0x8 = Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511\n9 : B_0x9 = Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023\n10 : B_0xA = Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.11..8> MAMP1
//        <0=> 0: B_0x0 = Unmask bit0 of LFSR/ triangle amplitude equal to 1
//        <1=> 1: B_0x1 = Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3
//        <2=> 2: B_0x2 = Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7
//        <3=> 3: B_0x3 = Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15
//        <4=> 4: B_0x4 = Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31
//        <5=> 5: B_0x5 = Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63
//        <6=> 6: B_0x6 = Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127
//        <7=> 7: B_0x7 = Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255
//        <8=> 8: B_0x8 = Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511
//        <9=> 9: B_0x9 = Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023
//        <10=> 10: B_0xA = Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_DMAEN1  ---------------------------------
// SVD Line: 3870

//  <item> SFDITEM_FIELD__DAC_DAC_CR_DMAEN1
//    <name> DMAEN1 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40007400) \nDAC channel1 DMA enable This bit is set and cleared by software.\n0 : B_0x0 = DAC channel1 DMA mode disabled\n1 : B_0x1 = DAC channel1 DMA mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.12..12> DMAEN1
//        <0=> 0: B_0x0 = DAC channel1 DMA mode disabled
//        <1=> 1: B_0x1 = DAC channel1 DMA mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DAC_DAC_CR_DMAUDRIE1  --------------------------------
// SVD Line: 3890

//  <item> SFDITEM_FIELD__DAC_DAC_CR_DMAUDRIE1
//    <name> DMAUDRIE1 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40007400) \nDAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = DAC channel1 DMA Underrun Interrupt disabled\n1 : B_0x1 = DAC channel1 DMA Underrun Interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.13..13> DMAUDRIE1
//        <0=> 0: B_0x0 = DAC channel1 DMA Underrun Interrupt disabled
//        <1=> 1: B_0x1 = DAC channel1 DMA Underrun Interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: DAC_DAC_CR_CEN1  ----------------------------------
// SVD Line: 3910

//  <item> SFDITEM_FIELD__DAC_DAC_CR_CEN1
//    <name> CEN1 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40007400) \nDAC channel1 calibration enable This bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.\n0 : B_0x0 = DAC channel1 in Normal operating mode\n1 : B_0x1 = DAC channel1 in calibration mode </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.14..14> CEN1
//        <0=> 0: B_0x0 = DAC channel1 in Normal operating mode
//        <1=> 1: B_0x1 = DAC channel1 in calibration mode
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: DAC_DAC_CR_EN2  -----------------------------------
// SVD Line: 3930

//  <item> SFDITEM_FIELD__DAC_DAC_CR_EN2
//    <name> EN2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40007400) \nDAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2. Note: These bits are available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = DAC channel2 disabled\n1 : B_0x1 = DAC channel2 enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.16..16> EN2
//        <0=> 0: B_0x0 = DAC channel2 disabled
//        <1=> 1: B_0x1 = DAC channel2 enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: DAC_DAC_CR_TEN2  ----------------------------------
// SVD Line: 3951

//  <item> SFDITEM_FIELD__DAC_DAC_CR_TEN2
//    <name> TEN2 </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40007400) \nDAC channel2 trigger enable This bit is set and cleared by software to enable/disable DAC channel2 trigger Note: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_pclk clock cycle. These bits are available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = DAC channel2 trigger disabled and data written into the DAC_DHR2 register are transferred one dac_pclk clock cycle later to the DAC_DOR2 register\n1 : B_0x1 = DAC channel2 trigger enabled and data from the DAC_DHR2 register are transferred three dac_pclk clock cycles later to the DAC_DOR2 register </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.17..17> TEN2
//        <0=> 0: B_0x0 = DAC channel2 trigger disabled and data written into the DAC_DHR2 register are transferred one dac_pclk clock cycle later to the DAC_DOR2 register
//        <1=> 1: B_0x1 = DAC channel2 trigger enabled and data from the DAC_DHR2 register are transferred three dac_pclk clock cycles later to the DAC_DOR2 register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_TSEL2  ----------------------------------
// SVD Line: 3973

//  <item> SFDITEM_FIELD__DAC_DAC_CR_TSEL2
//    <name> TSEL2 </name>
//    <rw> 
//    <i> [Bits 21..18] RW (@ 0x40007400) \nDAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 ... Refer to the trigger selection tables in for details on trigger configuration and mapping. Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled). These bits are available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = SWTRIG2\n1 : B_0x1 = dac_ch2_trg1\n2 : B_0x2 = dac_ch2_trg2\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : B_0xF = dac_ch2_trg15 </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.21..18> TSEL2
//        <0=> 0: B_0x0 = SWTRIG2
//        <1=> 1: B_0x1 = dac_ch2_trg1
//        <2=> 2: B_0x2 = dac_ch2_trg2
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: B_0xF = dac_ch2_trg15
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_WAVE2  ----------------------------------
// SVD Line: 4007

//  <item> SFDITEM_FIELD__DAC_DAC_CR_WAVE2
//    <name> WAVE2 </name>
//    <rw> 
//    <i> [Bits 23..22] RW (@ 0x40007400) \nDAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled) These bits are available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = wave generation disabled\n1 : B_0x1 = Noise wave generation enabled\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.23..22> WAVE2
//        <0=> 0: B_0x0 = wave generation disabled
//        <1=> 1: B_0x1 = Noise wave generation enabled
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_MAMP2  ----------------------------------
// SVD Line: 4030

//  <item> SFDITEM_FIELD__DAC_DAC_CR_MAMP2
//    <name> MAMP2 </name>
//    <rw> 
//    <i> [Bits 27..24] RW (@ 0x40007400) \nDAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.  1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 Note: These bits are available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = Unmask bit0 of LFSR/ triangle amplitude equal to 1\n1 : B_0x1 = Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3\n2 : B_0x2 = Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7\n3 : B_0x3 = Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15\n4 : B_0x4 = Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31\n5 : B_0x5 = Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63\n6 : B_0x6 = Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127\n7 : B_0x7 = Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255\n8 : B_0x8 = Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511\n9 : B_0x9 = Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023\n10 : B_0xA = Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.27..24> MAMP2
//        <0=> 0: B_0x0 = Unmask bit0 of LFSR/ triangle amplitude equal to 1
//        <1=> 1: B_0x1 = Unmask bits[1:0] of LFSR/ triangle amplitude equal to 3
//        <2=> 2: B_0x2 = Unmask bits[2:0] of LFSR/ triangle amplitude equal to 7
//        <3=> 3: B_0x3 = Unmask bits[3:0] of LFSR/ triangle amplitude equal to 15
//        <4=> 4: B_0x4 = Unmask bits[4:0] of LFSR/ triangle amplitude equal to 31
//        <5=> 5: B_0x5 = Unmask bits[5:0] of LFSR/ triangle amplitude equal to 63
//        <6=> 6: B_0x6 = Unmask bits[6:0] of LFSR/ triangle amplitude equal to 127
//        <7=> 7: B_0x7 = Unmask bits[7:0] of LFSR/ triangle amplitude equal to 255
//        <8=> 8: B_0x8 = Unmask bits[8:0] of LFSR/ triangle amplitude equal to 511
//        <9=> 9: B_0x9 = Unmask bits[9:0] of LFSR/ triangle amplitude equal to 1023
//        <10=> 10: B_0xA = Unmask bits[10:0] of LFSR/ triangle amplitude equal to 2047
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_CR_DMAEN2  ---------------------------------
// SVD Line: 4097

//  <item> SFDITEM_FIELD__DAC_DAC_CR_DMAEN2
//    <name> DMAEN2 </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40007400) \nDAC channel2 DMA enable This bit is set and cleared by software. Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = DAC channel2 DMA mode disabled\n1 : B_0x1 = DAC channel2 DMA mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.28..28> DMAEN2
//        <0=> 0: B_0x0 = DAC channel2 DMA mode disabled
//        <1=> 1: B_0x1 = DAC channel2 DMA mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DAC_DAC_CR_DMAUDRIE2  --------------------------------
// SVD Line: 4118

//  <item> SFDITEM_FIELD__DAC_DAC_CR_DMAUDRIE2
//    <name> DMAUDRIE2 </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40007400) \nDAC channel2 DMA underrun interrupt enable This bit is set and cleared by software. Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = DAC channel2 DMA underrun interrupt disabled\n1 : B_0x1 = DAC channel2 DMA underrun interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.29..29> DMAUDRIE2
//        <0=> 0: B_0x0 = DAC channel2 DMA underrun interrupt disabled
//        <1=> 1: B_0x1 = DAC channel2 DMA underrun interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: DAC_DAC_CR_CEN2  ----------------------------------
// SVD Line: 4139

//  <item> SFDITEM_FIELD__DAC_DAC_CR_CEN2
//    <name> CEN2 </name>
//    <rw> 
//    <i> [Bit 30] RW (@ 0x40007400) \nDAC channel2 calibration enable This bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored. Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = DAC channel2 in Normal operating mode\n1 : B_0x1 = DAC channel2 in calibration mode </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_CR ) </loc>
//      <o.30..30> CEN2
//        <0=> 0: B_0x0 = DAC channel2 in Normal operating mode
//        <1=> 1: B_0x1 = DAC channel2 in calibration mode
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: DAC_DAC_CR  -----------------------------------
// SVD Line: 3699

//  <rtree> SFDITEM_REG__DAC_DAC_CR
//    <name> DAC_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007400) DAC control register </i>
//    <loc> ( (unsigned int)((DAC_DAC_CR >> 0) & 0xFFFFFFFF), ((DAC_DAC_CR = (DAC_DAC_CR & ~(0x7FFF7FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFF7FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_EN1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_TEN1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_TSEL1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_WAVE1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_MAMP1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_DMAEN1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_DMAUDRIE1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_CEN1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_EN2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_TEN2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_TSEL2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_WAVE2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_MAMP2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_DMAEN2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_DMAUDRIE2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CR_CEN2 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_SWTRGR  -----------------------------
// SVD Line: 4162

unsigned int DAC_DAC_SWTRGR __AT (0x40007404);



// ---------------------------  Field Item: DAC_DAC_SWTRGR_SWTRIG1  -------------------------------
// SVD Line: 4171

//  <item> SFDITEM_FIELD__DAC_DAC_SWTRGR_SWTRIG1
//    <name> SWTRIG1 </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40007404) \nDAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.\n0 : B_0x0 = No trigger\n1 : B_0x1 = Trigger </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SWTRGR ) </loc>
//      <o.0..0> SWTRIG1
//        <0=> 0: B_0x0 = No trigger
//        <1=> 1: B_0x1 = Trigger
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DAC_DAC_SWTRGR_SWTRIG2  -------------------------------
// SVD Line: 4192

//  <item> SFDITEM_FIELD__DAC_DAC_SWTRGR_SWTRIG2
//    <name> SWTRIG2 </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40007404) \nDAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = No trigger\n1 : B_0x1 = Trigger </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SWTRGR ) </loc>
//      <o.1..1> SWTRIG2
//        <0=> 0: B_0x0 = No trigger
//        <1=> 1: B_0x1 = Trigger
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_SWTRGR  ---------------------------------
// SVD Line: 4162

//  <rtree> SFDITEM_REG__DAC_DAC_SWTRGR
//    <name> DAC_SWTRGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40007404) DAC software trigger register </i>
//    <loc> ( (unsigned int)((DAC_DAC_SWTRGR >> 0) & 0xFFFFFFFF), ((DAC_DAC_SWTRGR = (DAC_DAC_SWTRGR & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SWTRGR_SWTRIG1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SWTRGR_SWTRIG2 </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12R1  -----------------------------
// SVD Line: 4216

unsigned int DAC_DAC_DHR12R1 __AT (0x40007408);



// --------------------------  Field Item: DAC_DAC_DHR12R1_DACC1DHR  ------------------------------
// SVD Line: 4226

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12R1_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40007408) DAC channel1 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12R1 >> 0) & 0xFFF), ((DAC_DAC_DHR12R1 = (DAC_DAC_DHR12R1 & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12R1  --------------------------------
// SVD Line: 4216

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12R1
//    <name> DAC_DHR12R1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007408) DAC channel1 12-bit right-aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12R1 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12R1 = (DAC_DAC_DHR12R1 & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12R1_DACC1DHR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12L1  -----------------------------
// SVD Line: 4236

unsigned int DAC_DAC_DHR12L1 __AT (0x4000740C);



// --------------------------  Field Item: DAC_DAC_DHR12L1_DACC1DHR  ------------------------------
// SVD Line: 4246

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12L1_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 15..4] RW (@ 0x4000740C) DAC channel1 12-bit left-aligned data These bits are written by software. They specify 12-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12L1 >> 4) & 0xFFF), ((DAC_DAC_DHR12L1 = (DAC_DAC_DHR12L1 & ~(0xFFFUL << 4 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12L1  --------------------------------
// SVD Line: 4236

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12L1
//    <name> DAC_DHR12L1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000740C) DAC channel1 12-bit left aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12L1 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12L1 = (DAC_DAC_DHR12L1 & ~(0xFFF0UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12L1_DACC1DHR </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_DHR8R1  -----------------------------
// SVD Line: 4257

unsigned int DAC_DAC_DHR8R1 __AT (0x40007410);



// ---------------------------  Field Item: DAC_DAC_DHR8R1_DACC1DHR  ------------------------------
// SVD Line: 4267

//  <item> SFDITEM_FIELD__DAC_DAC_DHR8R1_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40007410) DAC channel1 8-bit right-aligned data These bits are written by software. They specify 8-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_DHR8R1 >> 0) & 0xFF), ((DAC_DAC_DHR8R1 = (DAC_DAC_DHR8R1 & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR8R1  ---------------------------------
// SVD Line: 4257

//  <rtree> SFDITEM_REG__DAC_DAC_DHR8R1
//    <name> DAC_DHR8R1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007410) DAC channel1 8-bit right aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR8R1 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR8R1 = (DAC_DAC_DHR8R1 & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR8R1_DACC1DHR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12R2  -----------------------------
// SVD Line: 4277

unsigned int DAC_DAC_DHR12R2 __AT (0x40007414);



// --------------------------  Field Item: DAC_DAC_DHR12R2_DACC2DHR  ------------------------------
// SVD Line: 4287

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12R2_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40007414) DAC channel2 12-bit right-aligned data These bits are written by software. They specify 12-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12R2 >> 0) & 0xFFF), ((DAC_DAC_DHR12R2 = (DAC_DAC_DHR12R2 & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12R2  --------------------------------
// SVD Line: 4277

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12R2
//    <name> DAC_DHR12R2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007414) DAC channel2 12-bit right aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12R2 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12R2 = (DAC_DAC_DHR12R2 & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12R2_DACC2DHR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12L2  -----------------------------
// SVD Line: 4297

unsigned int DAC_DAC_DHR12L2 __AT (0x40007418);



// --------------------------  Field Item: DAC_DAC_DHR12L2_DACC2DHR  ------------------------------
// SVD Line: 4307

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12L2_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 15..4] RW (@ 0x40007418) DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12L2 >> 4) & 0xFFF), ((DAC_DAC_DHR12L2 = (DAC_DAC_DHR12L2 & ~(0xFFFUL << 4 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12L2  --------------------------------
// SVD Line: 4297

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12L2
//    <name> DAC_DHR12L2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007418) DAC channel2 12-bit left aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12L2 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12L2 = (DAC_DAC_DHR12L2 & ~(0xFFF0UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12L2_DACC2DHR </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_DHR8R2  -----------------------------
// SVD Line: 4317

unsigned int DAC_DAC_DHR8R2 __AT (0x4000741C);



// ---------------------------  Field Item: DAC_DAC_DHR8R2_DACC2DHR  ------------------------------
// SVD Line: 4327

//  <item> SFDITEM_FIELD__DAC_DAC_DHR8R2_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x4000741C) DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_DHR8R2 >> 0) & 0xFF), ((DAC_DAC_DHR8R2 = (DAC_DAC_DHR8R2 & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR8R2  ---------------------------------
// SVD Line: 4317

//  <rtree> SFDITEM_REG__DAC_DAC_DHR8R2
//    <name> DAC_DHR8R2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000741C) DAC channel2 8-bit right-aligned data  holding register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR8R2 >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR8R2 = (DAC_DAC_DHR8R2 & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR8R2_DACC2DHR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12RD  -----------------------------
// SVD Line: 4337

unsigned int DAC_DAC_DHR12RD __AT (0x40007420);



// --------------------------  Field Item: DAC_DAC_DHR12RD_DACC1DHR  ------------------------------
// SVD Line: 4347

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12RD_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40007420) DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12RD >> 0) & 0xFFF), ((DAC_DAC_DHR12RD = (DAC_DAC_DHR12RD & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------  Field Item: DAC_DAC_DHR12RD_DACC2DHR  ------------------------------
// SVD Line: 4355

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12RD_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x40007420) DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12RD >> 16) & 0xFFF), ((DAC_DAC_DHR12RD = (DAC_DAC_DHR12RD & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12RD  --------------------------------
// SVD Line: 4337

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12RD
//    <name> DAC_DHR12RD </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007420) Dual DAC 12-bit right-aligned data holding  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12RD >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12RD = (DAC_DAC_DHR12RD & ~(0xFFF0FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12RD_DACC1DHR </item>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12RD_DACC2DHR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: DAC_DAC_DHR12LD  -----------------------------
// SVD Line: 4365

unsigned int DAC_DAC_DHR12LD __AT (0x40007424);



// --------------------------  Field Item: DAC_DAC_DHR12LD_DACC1DHR  ------------------------------
// SVD Line: 4375

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12LD_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 15..4] RW (@ 0x40007424) DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12LD >> 4) & 0xFFF), ((DAC_DAC_DHR12LD = (DAC_DAC_DHR12LD & ~(0xFFFUL << 4 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------  Field Item: DAC_DAC_DHR12LD_DACC2DHR  ------------------------------
// SVD Line: 4383

//  <item> SFDITEM_FIELD__DAC_DAC_DHR12LD_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 31..20] RW (@ 0x40007424) DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DHR12LD >> 20) & 0xFFF), ((DAC_DAC_DHR12LD = (DAC_DAC_DHR12LD & ~(0xFFFUL << 20 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 20 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR12LD  --------------------------------
// SVD Line: 4365

//  <rtree> SFDITEM_REG__DAC_DAC_DHR12LD
//    <name> DAC_DHR12LD </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007424) DUAL DAC 12-bit left aligned data holding  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR12LD >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR12LD = (DAC_DAC_DHR12LD & ~(0xFFF0FFF0UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF0FFF0) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12LD_DACC1DHR </item>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR12LD_DACC2DHR </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_DHR8RD  -----------------------------
// SVD Line: 4393

unsigned int DAC_DAC_DHR8RD __AT (0x40007428);



// ---------------------------  Field Item: DAC_DAC_DHR8RD_DACC1DHR  ------------------------------
// SVD Line: 4403

//  <item> SFDITEM_FIELD__DAC_DAC_DHR8RD_DACC1DHR
//    <name> DACC1DHR </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40007428) DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_DHR8RD >> 0) & 0xFF), ((DAC_DAC_DHR8RD = (DAC_DAC_DHR8RD & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DAC_DAC_DHR8RD_DACC2DHR  ------------------------------
// SVD Line: 4411

//  <item> SFDITEM_FIELD__DAC_DAC_DHR8RD_DACC2DHR
//    <name> DACC2DHR </name>
//    <rw> 
//    <i> [Bits 15..8] RW (@ 0x40007428) DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_DHR8RD >> 8) & 0xFF), ((DAC_DAC_DHR8RD = (DAC_DAC_DHR8RD & ~(0xFFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: DAC_DAC_DHR8RD  ---------------------------------
// SVD Line: 4393

//  <rtree> SFDITEM_REG__DAC_DAC_DHR8RD
//    <name> DAC_DHR8RD </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007428) DUAL DAC 8-bit right aligned data holding  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DHR8RD >> 0) & 0xFFFFFFFF), ((DAC_DAC_DHR8RD = (DAC_DAC_DHR8RD & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR8RD_DACC1DHR </item>
//    <item> SFDITEM_FIELD__DAC_DAC_DHR8RD_DACC2DHR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_DOR1  ------------------------------
// SVD Line: 4421

unsigned int DAC_DAC_DOR1 __AT (0x4000742C);



// ----------------------------  Field Item: DAC_DAC_DOR1_DACC1DOR  -------------------------------
// SVD Line: 4431

//  <item> SFDITEM_FIELD__DAC_DAC_DOR1_DACC1DOR
//    <name> DACC1DOR </name>
//    <r> 
//    <i> [Bits 11..0] RO (@ 0x4000742C) DAC channel1 data output These bits are read-only, they contain data output for DAC channel1. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DOR1 >> 0) & 0xFFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_DOR1  ----------------------------------
// SVD Line: 4421

//  <rtree> SFDITEM_REG__DAC_DAC_DOR1
//    <name> DAC_DOR1 </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000742C) DAC channel1 data output  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DOR1 >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DOR1_DACC1DOR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_DOR2  ------------------------------
// SVD Line: 4441

unsigned int DAC_DAC_DOR2 __AT (0x40007430);



// ----------------------------  Field Item: DAC_DAC_DOR2_DACC2DOR  -------------------------------
// SVD Line: 4451

//  <item> SFDITEM_FIELD__DAC_DAC_DOR2_DACC2DOR
//    <name> DACC2DOR </name>
//    <r> 
//    <i> [Bits 11..0] RO (@ 0x40007430) DAC channel2 data output These bits are read-only, they contain data output for DAC channel2. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_DOR2 >> 0) & 0xFFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_DOR2  ----------------------------------
// SVD Line: 4441

//  <rtree> SFDITEM_REG__DAC_DAC_DOR2
//    <name> DAC_DOR2 </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40007430) DAC channel2 data output  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_DOR2 >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_DOR2_DACC2DOR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: DAC_DAC_SR  -------------------------------
// SVD Line: 4461

unsigned int DAC_DAC_SR __AT (0x40007434);



// -----------------------------  Field Item: DAC_DAC_SR_DMAUDR1  ---------------------------------
// SVD Line: 4469

//  <item> SFDITEM_FIELD__DAC_DAC_SR_DMAUDR1
//    <name> DMAUDR1 </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40007434) \nDAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).\n0 : B_0x0 = No DMA underrun error condition occurred for DAC channel1\n1 : B_0x1 = DMA underrun error condition occurred for DAC channel1 (the currently selected trigger is driving DAC channel1 conversion at a frequency higher than the DMA service capability rate) </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.13..13> DMAUDR1
//        <0=> 0: B_0x0 = No DMA underrun error condition occurred for DAC channel1
//        <1=> 1: B_0x1 = DMA underrun error condition occurred for DAC channel1 (the currently selected trigger is driving DAC channel1 conversion at a frequency higher than the DMA service capability rate)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DAC_DAC_SR_CAL_FLAG1  --------------------------------
// SVD Line: 4489

//  <item> SFDITEM_FIELD__DAC_DAC_SR_CAL_FLAG1
//    <name> CAL_FLAG1 </name>
//    <r> 
//    <i> [Bit 14] RO (@ 0x40007434) \nDAC channel1 calibration offset status This bit is set and cleared by hardware\n0 : B_0x0 = calibration trimming value is lower than the offset correction value\n1 : B_0x1 = calibration trimming value is equal or greater than the offset correction value </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.14..14> CAL_FLAG1
//        <0=> 0: B_0x0 = calibration trimming value is lower than the offset correction value
//        <1=> 1: B_0x1 = calibration trimming value is equal or greater than the offset correction value
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_SR_BWST1  ----------------------------------
// SVD Line: 4509

//  <item> SFDITEM_FIELD__DAC_DAC_SR_BWST1
//    <name> BWST1 </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x40007434) \nDAC channel1 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization).\n0 : B_0x0 = There is no write operation of DAC_SHSR1 ongoing: DAC_SHSR1 can be written\n1 : B_0x1 = There is a write operation of DAC_SHSR1 ongoing: DAC_SHSR1 cannot be written </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.15..15> BWST1
//        <0=> 0: B_0x0 = There is no write operation of DAC_SHSR1 ongoing: DAC_SHSR1 can be written
//        <1=> 1: B_0x1 = There is a write operation of DAC_SHSR1 ongoing: DAC_SHSR1 cannot be written
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: DAC_DAC_SR_DMAUDR2  ---------------------------------
// SVD Line: 4529

//  <item> SFDITEM_FIELD__DAC_DAC_SR_DMAUDR2
//    <name> DMAUDR2 </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40007434) \nDAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1). Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = No DMA underrun error condition occurred for DAC channel2\n1 : B_0x1 = DMA underrun error condition occurred for DAC channel2 (the currently selected trigger is driving DAC channel2 conversion at a frequency higher than the DMA service capability rate). </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.29..29> DMAUDR2
//        <0=> 0: B_0x0 = No DMA underrun error condition occurred for DAC channel2
//        <1=> 1: B_0x1 = DMA underrun error condition occurred for DAC channel2 (the currently selected trigger is driving DAC channel2 conversion at a frequency higher than the DMA service capability rate).
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DAC_DAC_SR_CAL_FLAG2  --------------------------------
// SVD Line: 4550

//  <item> SFDITEM_FIELD__DAC_DAC_SR_CAL_FLAG2
//    <name> CAL_FLAG2 </name>
//    <r> 
//    <i> [Bit 30] RO (@ 0x40007434) \nDAC channel2 calibration offset status This bit is set and cleared by hardware Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = calibration trimming value is lower than the offset correction value\n1 : B_0x1 = calibration trimming value is equal or greater than the offset correction value </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.30..30> CAL_FLAG2
//        <0=> 0: B_0x0 = calibration trimming value is lower than the offset correction value
//        <1=> 1: B_0x1 = calibration trimming value is equal or greater than the offset correction value
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_SR_BWST2  ----------------------------------
// SVD Line: 4571

//  <item> SFDITEM_FIELD__DAC_DAC_SR_BWST2
//    <name> BWST2 </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40007434) \nDAC channel2 busy writing sample time flag This bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). Note: This bit is available only on dual-channel DACs. Refer to implementation.\n0 : B_0x0 = There is no write operation of DAC_SHSR2 ongoing: DAC_SHSR2 can be written\n1 : B_0x1 = There is a write operation of DAC_SHSR2 ongoing: DAC_SHSR2 cannot be written </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_SR ) </loc>
//      <o.31..31> BWST2
//        <0=> 0: B_0x0 = There is no write operation of DAC_SHSR2 ongoing: DAC_SHSR2 can be written
//        <1=> 1: B_0x1 = There is a write operation of DAC_SHSR2 ongoing: DAC_SHSR2 cannot be written
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: DAC_DAC_SR  -----------------------------------
// SVD Line: 4461

//  <rtree> SFDITEM_REG__DAC_DAC_SR
//    <name> DAC_SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007434) DAC status register </i>
//    <loc> ( (unsigned int)((DAC_DAC_SR >> 0) & 0xFFFFFFFF), ((DAC_DAC_SR = (DAC_DAC_SR & ~(0x20002000UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x20002000) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_DMAUDR1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_CAL_FLAG1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_BWST1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_DMAUDR2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_CAL_FLAG2 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SR_BWST2 </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_CCR  -------------------------------
// SVD Line: 4594

unsigned int DAC_DAC_CCR __AT (0x40007438);



// -----------------------------  Field Item: DAC_DAC_CCR_OTRIM1  ---------------------------------
// SVD Line: 4604

//  <item> SFDITEM_FIELD__DAC_DAC_CCR_OTRIM1
//    <name> OTRIM1 </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40007438) DAC channel1 offset trimming value </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_CCR >> 0) & 0x1F), ((DAC_DAC_CCR = (DAC_DAC_CCR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: DAC_DAC_CCR_OTRIM2  ---------------------------------
// SVD Line: 4611

//  <item> SFDITEM_FIELD__DAC_DAC_CCR_OTRIM2
//    <name> OTRIM2 </name>
//    <rw> 
//    <i> [Bits 20..16] RW (@ 0x40007438) DAC channel2 offset trimming value These bits are available only on dual-channel DACs. Refer to implementation. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_CCR >> 16) & 0x1F), ((DAC_DAC_CCR = (DAC_DAC_CCR & ~(0x1FUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: DAC_DAC_CCR  ----------------------------------
// SVD Line: 4594

//  <rtree> SFDITEM_REG__DAC_DAC_CCR
//    <name> DAC_CCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007438) DAC calibration control  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_CCR >> 0) & 0xFFFFFFFF), ((DAC_DAC_CCR = (DAC_DAC_CCR & ~(0x1F001FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F001F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_CCR_OTRIM1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_CCR_OTRIM2 </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_MCR  -------------------------------
// SVD Line: 4621

unsigned int DAC_DAC_MCR __AT (0x4000743C);



// ------------------------------  Field Item: DAC_DAC_MCR_MODE1  ---------------------------------
// SVD Line: 4630

//  <item> SFDITEM_FIELD__DAC_DAC_MCR_MODE1
//    <name> MODE1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x4000743C) \nDAC channel1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel1 mode: DAC channel1 in Normal mode DAC channel1 in sample & hold mode Note: This register can be modified only when EN1=0.\n0 : B_0x0 = DAC channel1 is connected to external pin with Buffer enabled\n1 : B_0x1 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled\n2 : B_0x2 = DAC channel1 is connected to external pin with Buffer disabled\n3 : B_0x3 = DAC channel1 is connected to on chip peripherals with Buffer disabled\n4 : B_0x4 = DAC channel1 is connected to external pin with Buffer enabled\n5 : B_0x5 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled\n6 : B_0x6 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer disabled\n7 : B_0x7 = DAC channel1 is connected to on chip peripherals with Buffer disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_MCR ) </loc>
//      <o.2..0> MODE1
//        <0=> 0: B_0x0 = DAC channel1 is connected to external pin with Buffer enabled
//        <1=> 1: B_0x1 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled
//        <2=> 2: B_0x2 = DAC channel1 is connected to external pin with Buffer disabled
//        <3=> 3: B_0x3 = DAC channel1 is connected to on chip peripherals with Buffer disabled
//        <4=> 4: B_0x4 = DAC channel1 is connected to external pin with Buffer enabled
//        <5=> 5: B_0x5 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer enabled
//        <6=> 6: B_0x6 = DAC channel1 is connected to external pin and to on chip peripherals with Buffer disabled
//        <7=> 7: B_0x7 = DAC channel1 is connected to on chip peripherals with Buffer disabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: DAC_DAC_MCR_MODE2  ---------------------------------
// SVD Line: 4684

//  <item> SFDITEM_FIELD__DAC_DAC_MCR_MODE2
//    <name> MODE2 </name>
//    <rw> 
//    <i> [Bits 18..16] RW (@ 0x4000743C) \nDAC channel2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel2 mode: DAC channel2 in Normal mode DAC channel2 in Sample and hold mode Note: This register can be modified only when EN2=0. Refer to for the availability of DAC channel2.\n0 : B_0x0 = DAC channel2 is connected to external pin with Buffer enabled\n1 : B_0x1 = DAC channel2 is connected to external pin and to on chip peripherals with buffer enabled\n2 : B_0x2 = DAC channel2 is connected to external pin with buffer disabled\n3 : B_0x3 = DAC channel2 is connected to on chip peripherals with Buffer disabled\n4 : B_0x4 = DAC channel2 is connected to external pin with Buffer enabled\n5 : B_0x5 = DAC channel2 is connected to external pin and to on chip peripherals with Buffer enabled\n6 : B_0x6 = DAC channel2 is connected to external pin and to on chip peripherals with Buffer disabled\n7 : B_0x7 = DAC channel2 is connected to on chip peripherals with Buffer disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DAC_DAC_MCR ) </loc>
//      <o.18..16> MODE2
//        <0=> 0: B_0x0 = DAC channel2 is connected to external pin with Buffer enabled
//        <1=> 1: B_0x1 = DAC channel2 is connected to external pin and to on chip peripherals with buffer enabled
//        <2=> 2: B_0x2 = DAC channel2 is connected to external pin with buffer disabled
//        <3=> 3: B_0x3 = DAC channel2 is connected to on chip peripherals with Buffer disabled
//        <4=> 4: B_0x4 = DAC channel2 is connected to external pin with Buffer enabled
//        <5=> 5: B_0x5 = DAC channel2 is connected to external pin and to on chip peripherals with Buffer enabled
//        <6=> 6: B_0x6 = DAC channel2 is connected to external pin and to on chip peripherals with Buffer disabled
//        <7=> 7: B_0x7 = DAC channel2 is connected to on chip peripherals with Buffer disabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: DAC_DAC_MCR  ----------------------------------
// SVD Line: 4621

//  <rtree> SFDITEM_REG__DAC_DAC_MCR
//    <name> DAC_MCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000743C) DAC mode control register </i>
//    <loc> ( (unsigned int)((DAC_DAC_MCR >> 0) & 0xFFFFFFFF), ((DAC_DAC_MCR = (DAC_DAC_MCR & ~(0x70007UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x70007) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_MCR_MODE1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_MCR_MODE2 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_SHSR1  ------------------------------
// SVD Line: 4741

unsigned int DAC_DAC_SHSR1 __AT (0x40007440);



// ---------------------------  Field Item: DAC_DAC_SHSR1_TSAMPLE1  -------------------------------
// SVD Line: 4751

//  <item> SFDITEM_FIELD__DAC_DAC_SHSR1_TSAMPLE1
//    <name> TSAMPLE1 </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40007440) DAC channel1 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1=1, the write operation is ignored. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_SHSR1 >> 0) & 0x3FF), ((DAC_DAC_SHSR1 = (DAC_DAC_SHSR1 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_SHSR1  ---------------------------------
// SVD Line: 4741

//  <rtree> SFDITEM_REG__DAC_DAC_SHSR1
//    <name> DAC_SHSR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007440) DAC Sample and Hold sample time register  1 </i>
//    <loc> ( (unsigned int)((DAC_DAC_SHSR1 >> 0) & 0xFFFFFFFF), ((DAC_DAC_SHSR1 = (DAC_DAC_SHSR1 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SHSR1_TSAMPLE1 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: DAC_DAC_SHSR2  ------------------------------
// SVD Line: 4761

unsigned int DAC_DAC_SHSR2 __AT (0x40007444);



// ---------------------------  Field Item: DAC_DAC_SHSR2_TSAMPLE2  -------------------------------
// SVD Line: 4771

//  <item> SFDITEM_FIELD__DAC_DAC_SHSR2_TSAMPLE2
//    <name> TSAMPLE2 </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40007444) DAC channel2 sample time (only valid in Sample and hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2=1, the write operation is ignored. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_SHSR2 >> 0) & 0x3FF), ((DAC_DAC_SHSR2 = (DAC_DAC_SHSR2 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_SHSR2  ---------------------------------
// SVD Line: 4761

//  <rtree> SFDITEM_REG__DAC_DAC_SHSR2
//    <name> DAC_SHSR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007444) DAC Sample and Hold sample time register  2 </i>
//    <loc> ( (unsigned int)((DAC_DAC_SHSR2 >> 0) & 0xFFFFFFFF), ((DAC_DAC_SHSR2 = (DAC_DAC_SHSR2 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SHSR2_TSAMPLE2 </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_SHHR  ------------------------------
// SVD Line: 4781

unsigned int DAC_DAC_SHHR __AT (0x40007448);



// -----------------------------  Field Item: DAC_DAC_SHHR_THOLD1  --------------------------------
// SVD Line: 4791

//  <item> SFDITEM_FIELD__DAC_DAC_SHHR_THOLD1
//    <name> THOLD1 </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40007448) DAC channel1 hold time (only valid in Sample and hold mode) Hold time= (THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN1=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_SHHR >> 0) & 0x3FF), ((DAC_DAC_SHHR = (DAC_DAC_SHHR & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: DAC_DAC_SHHR_THOLD2  --------------------------------
// SVD Line: 4800

//  <item> SFDITEM_FIELD__DAC_DAC_SHHR_THOLD2
//    <name> THOLD2 </name>
//    <rw> 
//    <i> [Bits 25..16] RW (@ 0x40007448) DAC channel2 hold time (only valid in Sample and hold mode). Hold time= (THOLD[9:0]) x LSI clock period Note: This register can be modified only when EN2=0. These bits are available only on dual-channel DACs. Refer to implementation. </i>
//    <edit> 
//      <loc> ( (unsigned short)((DAC_DAC_SHHR >> 16) & 0x3FF), ((DAC_DAC_SHHR = (DAC_DAC_SHHR & ~(0x3FFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_SHHR  ----------------------------------
// SVD Line: 4781

//  <rtree> SFDITEM_REG__DAC_DAC_SHHR
//    <name> DAC_SHHR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007448) DAC Sample and Hold hold time  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_SHHR >> 0) & 0xFFFFFFFF), ((DAC_DAC_SHHR = (DAC_DAC_SHHR & ~(0x3FF03FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FF03FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SHHR_THOLD1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SHHR_THOLD2 </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: DAC_DAC_SHRR  ------------------------------
// SVD Line: 4812

unsigned int DAC_DAC_SHRR __AT (0x4000744C);



// ---------------------------  Field Item: DAC_DAC_SHRR_TREFRESH1  -------------------------------
// SVD Line: 4822

//  <item> SFDITEM_FIELD__DAC_DAC_SHRR_TREFRESH1
//    <name> TREFRESH1 </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x4000744C) DAC channel1 refresh time (only valid in Sample and hold mode) Refresh time= (TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN1=0. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_SHRR >> 0) & 0xFF), ((DAC_DAC_SHRR = (DAC_DAC_SHRR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DAC_DAC_SHRR_TREFRESH2  -------------------------------
// SVD Line: 4831

//  <item> SFDITEM_FIELD__DAC_DAC_SHRR_TREFRESH2
//    <name> TREFRESH2 </name>
//    <rw> 
//    <i> [Bits 23..16] RW (@ 0x4000744C) DAC channel2 refresh time (only valid in Sample and hold mode) Refresh time= (TREFRESH[7:0]) x LSI clock period Note: This register can be modified only when EN2=0. These bits are available only on dual-channel DACs. Refer to implementation. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DAC_DAC_SHRR >> 16) & 0xFF), ((DAC_DAC_SHRR = (DAC_DAC_SHRR & ~(0xFFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: DAC_DAC_SHRR  ----------------------------------
// SVD Line: 4812

//  <rtree> SFDITEM_REG__DAC_DAC_SHRR
//    <name> DAC_SHRR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000744C) DAC Sample and Hold refresh time  register </i>
//    <loc> ( (unsigned int)((DAC_DAC_SHRR >> 0) & 0xFFFFFFFF), ((DAC_DAC_SHRR = (DAC_DAC_SHRR & ~(0xFF00FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF00FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DAC_DAC_SHRR_TREFRESH1 </item>
//    <item> SFDITEM_FIELD__DAC_DAC_SHRR_TREFRESH2 </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: DAC  --------------------------------------
// SVD Line: 3688

//  <view> DAC
//    <name> DAC </name>
//    <item> SFDITEM_REG__DAC_DAC_CR </item>
//    <item> SFDITEM_REG__DAC_DAC_SWTRGR </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12R1 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12L1 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR8R1 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12R2 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12L2 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR8R2 </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12RD </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR12LD </item>
//    <item> SFDITEM_REG__DAC_DAC_DHR8RD </item>
//    <item> SFDITEM_REG__DAC_DAC_DOR1 </item>
//    <item> SFDITEM_REG__DAC_DAC_DOR2 </item>
//    <item> SFDITEM_REG__DAC_DAC_SR </item>
//    <item> SFDITEM_REG__DAC_DAC_CCR </item>
//    <item> SFDITEM_REG__DAC_DAC_MCR </item>
//    <item> SFDITEM_REG__DAC_DAC_SHSR1 </item>
//    <item> SFDITEM_REG__DAC_DAC_SHSR2 </item>
//    <item> SFDITEM_REG__DAC_DAC_SHHR </item>
//    <item> SFDITEM_REG__DAC_DAC_SHRR </item>
//  </view>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C0CR  ---------------------------
// SVD Line: 4862

unsigned int DMAMUX_DMAMUX_C0CR __AT (0x40020800);



// ------------------------  Field Item: DMAMUX_DMAMUX_C0CR_DMAREQ_ID  ----------------------------
// SVD Line: 4871

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020800) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C0CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C0CR = (DMAMUX_DMAMUX_C0CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C0CR_SOIE  ------------------------------
// SVD Line: 4879

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020800) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C0CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C0CR_EGE  -------------------------------
// SVD Line: 4898

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020800) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C0CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C0CR_SE  -------------------------------
// SVD Line: 4917

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020800) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C0CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C0CR_SPOL  ------------------------------
// SVD Line: 4936

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020800) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C0CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C0CR_NBREQ  ------------------------------
// SVD Line: 4966

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020800) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C0CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C0CR = (DMAMUX_DMAMUX_C0CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C0CR_SYNC_ID  -----------------------------
// SVD Line: 4975

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020800) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C0CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C0CR = (DMAMUX_DMAMUX_C0CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C0CR  -------------------------------
// SVD Line: 4862

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C0CR
//    <name> DMAMUX_C0CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020800) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C0CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C0CR = (DMAMUX_DMAMUX_C0CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C0CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C1CR  ---------------------------
// SVD Line: 4985

unsigned int DMAMUX_DMAMUX_C1CR __AT (0x40020804);



// ------------------------  Field Item: DMAMUX_DMAMUX_C1CR_DMAREQ_ID  ----------------------------
// SVD Line: 4994

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020804) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C1CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C1CR = (DMAMUX_DMAMUX_C1CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C1CR_SOIE  ------------------------------
// SVD Line: 5002

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020804) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C1CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C1CR_EGE  -------------------------------
// SVD Line: 5021

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020804) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C1CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C1CR_SE  -------------------------------
// SVD Line: 5040

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020804) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C1CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C1CR_SPOL  ------------------------------
// SVD Line: 5059

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020804) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C1CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C1CR_NBREQ  ------------------------------
// SVD Line: 5089

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020804) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C1CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C1CR = (DMAMUX_DMAMUX_C1CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C1CR_SYNC_ID  -----------------------------
// SVD Line: 5098

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020804) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C1CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C1CR = (DMAMUX_DMAMUX_C1CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C1CR  -------------------------------
// SVD Line: 4985

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C1CR
//    <name> DMAMUX_C1CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020804) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C1CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C1CR = (DMAMUX_DMAMUX_C1CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C1CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C2CR  ---------------------------
// SVD Line: 5108

unsigned int DMAMUX_DMAMUX_C2CR __AT (0x40020808);



// ------------------------  Field Item: DMAMUX_DMAMUX_C2CR_DMAREQ_ID  ----------------------------
// SVD Line: 5117

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020808) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C2CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C2CR = (DMAMUX_DMAMUX_C2CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C2CR_SOIE  ------------------------------
// SVD Line: 5125

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020808) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C2CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C2CR_EGE  -------------------------------
// SVD Line: 5144

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020808) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C2CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C2CR_SE  -------------------------------
// SVD Line: 5163

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020808) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C2CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C2CR_SPOL  ------------------------------
// SVD Line: 5182

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020808) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C2CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C2CR_NBREQ  ------------------------------
// SVD Line: 5212

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020808) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C2CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C2CR = (DMAMUX_DMAMUX_C2CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C2CR_SYNC_ID  -----------------------------
// SVD Line: 5221

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020808) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C2CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C2CR = (DMAMUX_DMAMUX_C2CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C2CR  -------------------------------
// SVD Line: 5108

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C2CR
//    <name> DMAMUX_C2CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020808) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C2CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C2CR = (DMAMUX_DMAMUX_C2CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C2CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C3CR  ---------------------------
// SVD Line: 5231

unsigned int DMAMUX_DMAMUX_C3CR __AT (0x4002080C);



// ------------------------  Field Item: DMAMUX_DMAMUX_C3CR_DMAREQ_ID  ----------------------------
// SVD Line: 5240

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x4002080C) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C3CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C3CR = (DMAMUX_DMAMUX_C3CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C3CR_SOIE  ------------------------------
// SVD Line: 5248

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4002080C) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C3CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C3CR_EGE  -------------------------------
// SVD Line: 5267

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4002080C) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C3CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C3CR_SE  -------------------------------
// SVD Line: 5286

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x4002080C) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C3CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C3CR_SPOL  ------------------------------
// SVD Line: 5305

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x4002080C) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C3CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C3CR_NBREQ  ------------------------------
// SVD Line: 5335

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x4002080C) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C3CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C3CR = (DMAMUX_DMAMUX_C3CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C3CR_SYNC_ID  -----------------------------
// SVD Line: 5344

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x4002080C) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C3CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C3CR = (DMAMUX_DMAMUX_C3CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C3CR  -------------------------------
// SVD Line: 5231

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C3CR
//    <name> DMAMUX_C3CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4002080C) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C3CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C3CR = (DMAMUX_DMAMUX_C3CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C3CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C4CR  ---------------------------
// SVD Line: 5354

unsigned int DMAMUX_DMAMUX_C4CR __AT (0x40020810);



// ------------------------  Field Item: DMAMUX_DMAMUX_C4CR_DMAREQ_ID  ----------------------------
// SVD Line: 5363

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020810) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C4CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C4CR = (DMAMUX_DMAMUX_C4CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C4CR_SOIE  ------------------------------
// SVD Line: 5371

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020810) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C4CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C4CR_EGE  -------------------------------
// SVD Line: 5390

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020810) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C4CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C4CR_SE  -------------------------------
// SVD Line: 5409

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020810) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C4CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C4CR_SPOL  ------------------------------
// SVD Line: 5428

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020810) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C4CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C4CR_NBREQ  ------------------------------
// SVD Line: 5458

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020810) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C4CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C4CR = (DMAMUX_DMAMUX_C4CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C4CR_SYNC_ID  -----------------------------
// SVD Line: 5467

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020810) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C4CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C4CR = (DMAMUX_DMAMUX_C4CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C4CR  -------------------------------
// SVD Line: 5354

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C4CR
//    <name> DMAMUX_C4CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020810) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C4CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C4CR = (DMAMUX_DMAMUX_C4CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C4CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C5CR  ---------------------------
// SVD Line: 5477

unsigned int DMAMUX_DMAMUX_C5CR __AT (0x40020814);



// ------------------------  Field Item: DMAMUX_DMAMUX_C5CR_DMAREQ_ID  ----------------------------
// SVD Line: 5486

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020814) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C5CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C5CR = (DMAMUX_DMAMUX_C5CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C5CR_SOIE  ------------------------------
// SVD Line: 5494

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020814) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C5CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C5CR_EGE  -------------------------------
// SVD Line: 5513

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020814) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C5CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C5CR_SE  -------------------------------
// SVD Line: 5532

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020814) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C5CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C5CR_SPOL  ------------------------------
// SVD Line: 5551

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020814) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C5CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C5CR_NBREQ  ------------------------------
// SVD Line: 5581

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020814) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C5CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C5CR = (DMAMUX_DMAMUX_C5CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C5CR_SYNC_ID  -----------------------------
// SVD Line: 5590

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020814) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C5CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C5CR = (DMAMUX_DMAMUX_C5CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C5CR  -------------------------------
// SVD Line: 5477

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C5CR
//    <name> DMAMUX_C5CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020814) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C5CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C5CR = (DMAMUX_DMAMUX_C5CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C5CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_C6CR  ---------------------------
// SVD Line: 5600

unsigned int DMAMUX_DMAMUX_C6CR __AT (0x40020818);



// ------------------------  Field Item: DMAMUX_DMAMUX_C6CR_DMAREQ_ID  ----------------------------
// SVD Line: 5609

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_DMAREQ_ID
//    <name> DMAREQ_ID </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40020818) DMA request identification  Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C6CR >> 0) & 0x3F), ((DMAMUX_DMAMUX_C6CR = (DMAMUX_DMAMUX_C6CR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C6CR_SOIE  ------------------------------
// SVD Line: 5617

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SOIE
//    <name> SOIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020818) \nSynchronization overrun interrupt enable\n0 : B_0x0 = interrupt disabled\n1 : B_0x1 = interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C6CR ) </loc>
//      <o.8..8> SOIE
//        <0=> 0: B_0x0 = interrupt disabled
//        <1=> 1: B_0x1 = interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C6CR_EGE  -------------------------------
// SVD Line: 5636

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_EGE
//    <name> EGE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40020818) \nEvent generation enable\n0 : B_0x0 = event generation disabled\n1 : B_0x1 = event generation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C6CR ) </loc>
//      <o.9..9> EGE
//        <0=> 0: B_0x0 = event generation disabled
//        <1=> 1: B_0x1 = event generation enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: DMAMUX_DMAMUX_C6CR_SE  -------------------------------
// SVD Line: 5655

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SE
//    <name> SE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020818) \nSynchronization enable\n0 : B_0x0 = synchronization disabled\n1 : B_0x1 = synchronization enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C6CR ) </loc>
//      <o.16..16> SE
//        <0=> 0: B_0x0 = synchronization disabled
//        <1=> 1: B_0x1 = synchronization enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_C6CR_SPOL  ------------------------------
// SVD Line: 5674

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SPOL
//    <name> SPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020818) \nSynchronization polarity  Defines the edge polarity of the selected synchronization input:\n0 : B_0x0 = no event, i.e. no synchronization nor detection.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_C6CR ) </loc>
//      <o.18..17> SPOL
//        <0=> 0: B_0x0 = no event, i.e. no synchronization nor detection.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_C6CR_NBREQ  ------------------------------
// SVD Line: 5704

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_NBREQ
//    <name> NBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020818) Number of DMA requests minus 1 to forward  Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.  This field shall only be written when both SE and EGE bits are low. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C6CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_C6CR = (DMAMUX_DMAMUX_C6CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_C6CR_SYNC_ID  -----------------------------
// SVD Line: 5713

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SYNC_ID
//    <name> SYNC_ID </name>
//    <rw> 
//    <i> [Bits 28..24] RW (@ 0x40020818) Synchronization identification  Selects the synchronization input (see inputs to resources STM32G0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_C6CR >> 24) & 0x1F), ((DMAMUX_DMAMUX_C6CR = (DMAMUX_DMAMUX_C6CR & ~(0x1FUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_C6CR  -------------------------------
// SVD Line: 5600

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_C6CR
//    <name> DMAMUX_C6CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020818) DMAMUX request line multiplexer channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_C6CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_C6CR = (DMAMUX_DMAMUX_C6CR & ~(0x1FFF033FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF033F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_DMAREQ_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SOIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_EGE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_NBREQ </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_C6CR_SYNC_ID </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_CSR  ----------------------------
// SVD Line: 5723

unsigned int DMAMUX_DMAMUX_CSR __AT (0x40020880);



// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF0  -------------------------------
// SVD Line: 5732

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF0
//    <name> SOF0 </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.0..0> SOF0
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF1  -------------------------------
// SVD Line: 5741

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF1
//    <name> SOF1 </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.1..1> SOF1
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF2  -------------------------------
// SVD Line: 5750

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF2
//    <name> SOF2 </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.2..2> SOF2
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF3  -------------------------------
// SVD Line: 5759

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF3
//    <name> SOF3 </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.3..3> SOF3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF4  -------------------------------
// SVD Line: 5768

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF4
//    <name> SOF4 </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.4..4> SOF4
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF5  -------------------------------
// SVD Line: 5777

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF5
//    <name> SOF5 </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.5..5> SOF5
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CSR_SOF6  -------------------------------
// SVD Line: 5786

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF6
//    <name> SOF6 </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x40020880) Synchronization overrun event flag  The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.  The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CSR ) </loc>
//      <o.6..6> SOF6
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: DMAMUX_DMAMUX_CSR  -------------------------------
// SVD Line: 5723

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_CSR
//    <name> DMAMUX_CSR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40020880) DMAMUX request line multiplexer interrupt channel status register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_CSR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF0 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF1 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF2 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF3 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF4 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF5 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CSR_SOF6 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_CFR  ----------------------------
// SVD Line: 5797

unsigned int DMAMUX_DMAMUX_CFR __AT (0x40020884);



// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF0  ------------------------------
// SVD Line: 5806

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF0
//    <name> CSOF0 </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.0..0> CSOF0
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF1  ------------------------------
// SVD Line: 5814

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF1
//    <name> CSOF1 </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.1..1> CSOF1
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF2  ------------------------------
// SVD Line: 5822

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF2
//    <name> CSOF2 </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.2..2> CSOF2
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF3  ------------------------------
// SVD Line: 5830

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF3
//    <name> CSOF3 </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.3..3> CSOF3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF4  ------------------------------
// SVD Line: 5838

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF4
//    <name> CSOF4 </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.4..4> CSOF4
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF5  ------------------------------
// SVD Line: 5846

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF5
//    <name> CSOF5 </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.5..5> CSOF5
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_CFR_CSOF6  ------------------------------
// SVD Line: 5854

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF6
//    <name> CSOF6 </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40020884) Clear synchronization overrun event flag Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_CFR ) </loc>
//      <o.6..6> CSOF6
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: DMAMUX_DMAMUX_CFR  -------------------------------
// SVD Line: 5797

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_CFR
//    <name> DMAMUX_CFR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40020884) DMAMUX request line multiplexer interrupt clear flag register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_CFR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_CFR = (DMAMUX_DMAMUX_CFR & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF0 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF1 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF2 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF3 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF4 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF5 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_CFR_CSOF6 </item>
//  </rtree>
//  


// -----------------------  Register Item Address: DMAMUX_DMAMUX_RG0CR  ---------------------------
// SVD Line: 5864

unsigned int DMAMUX_DMAMUX_RG0CR __AT (0x40020900);



// -------------------------  Field Item: DMAMUX_DMAMUX_RG0CR_SIG_ID  -----------------------------
// SVD Line: 5873

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_SIG_ID
//    <name> SIG_ID </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40020900) Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG0CR >> 0) & 0x1F), ((DMAMUX_DMAMUX_RG0CR = (DMAMUX_DMAMUX_RG0CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG0CR_OIE  ------------------------------
// SVD Line: 5881

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_OIE
//    <name> OIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020900) \nTrigger overrun interrupt enable\n0 : B_0x0 = interrupt on a trigger overrun event occurrence is disabled\n1 : B_0x1 = interrupt on a trigger overrun event occurrence is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG0CR ) </loc>
//      <o.8..8> OIE
//        <0=> 0: B_0x0 = interrupt on a trigger overrun event occurrence is disabled
//        <1=> 1: B_0x1 = interrupt on a trigger overrun event occurrence is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG0CR_GE  -------------------------------
// SVD Line: 5900

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GE
//    <name> GE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020900) \nDMA request generator channel x enable\n0 : B_0x0 = DMA request generator channel x disabled\n1 : B_0x1 = DMA request generator channel x enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG0CR ) </loc>
//      <o.16..16> GE
//        <0=> 0: B_0x0 = DMA request generator channel x disabled
//        <1=> 1: B_0x1 = DMA request generator channel x enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RG0CR_GPOL  ------------------------------
// SVD Line: 5919

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GPOL
//    <name> GPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020900) \nDMA request generator trigger polarity Defines the edge polarity of the selected trigger input\n0 : B_0x0 = no event. I.e. none trigger detection nor generation.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG0CR ) </loc>
//      <o.18..17> GPOL
//        <0=> 0: B_0x0 = no event. I.e. none trigger detection nor generation.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_RG0CR_GNBREQ  -----------------------------
// SVD Line: 5949

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GNBREQ
//    <name> GNBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020900) Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field shall only be written when GE bit is disabled. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG0CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_RG0CR = (DMAMUX_DMAMUX_RG0CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RG0CR  ------------------------------
// SVD Line: 5864

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RG0CR
//    <name> DMAMUX_RG0CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020900) DMAMUX request generator channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RG0CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_RG0CR = (DMAMUX_DMAMUX_RG0CR & ~(0xFF011FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF011F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_SIG_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_OIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG0CR_GNBREQ </item>
//  </rtree>
//  


// -----------------------  Register Item Address: DMAMUX_DMAMUX_RG1CR  ---------------------------
// SVD Line: 5960

unsigned int DMAMUX_DMAMUX_RG1CR __AT (0x40020904);



// -------------------------  Field Item: DMAMUX_DMAMUX_RG1CR_SIG_ID  -----------------------------
// SVD Line: 5969

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_SIG_ID
//    <name> SIG_ID </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40020904) Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG1CR >> 0) & 0x1F), ((DMAMUX_DMAMUX_RG1CR = (DMAMUX_DMAMUX_RG1CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG1CR_OIE  ------------------------------
// SVD Line: 5977

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_OIE
//    <name> OIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020904) \nTrigger overrun interrupt enable\n0 : B_0x0 = interrupt on a trigger overrun event occurrence is disabled\n1 : B_0x1 = interrupt on a trigger overrun event occurrence is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG1CR ) </loc>
//      <o.8..8> OIE
//        <0=> 0: B_0x0 = interrupt on a trigger overrun event occurrence is disabled
//        <1=> 1: B_0x1 = interrupt on a trigger overrun event occurrence is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG1CR_GE  -------------------------------
// SVD Line: 5996

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GE
//    <name> GE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020904) \nDMA request generator channel x enable\n0 : B_0x0 = DMA request generator channel x disabled\n1 : B_0x1 = DMA request generator channel x enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG1CR ) </loc>
//      <o.16..16> GE
//        <0=> 0: B_0x0 = DMA request generator channel x disabled
//        <1=> 1: B_0x1 = DMA request generator channel x enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RG1CR_GPOL  ------------------------------
// SVD Line: 6015

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GPOL
//    <name> GPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020904) \nDMA request generator trigger polarity Defines the edge polarity of the selected trigger input\n0 : B_0x0 = no event. I.e. none trigger detection nor generation.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG1CR ) </loc>
//      <o.18..17> GPOL
//        <0=> 0: B_0x0 = no event. I.e. none trigger detection nor generation.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_RG1CR_GNBREQ  -----------------------------
// SVD Line: 6045

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GNBREQ
//    <name> GNBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020904) Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field shall only be written when GE bit is disabled. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG1CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_RG1CR = (DMAMUX_DMAMUX_RG1CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RG1CR  ------------------------------
// SVD Line: 5960

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RG1CR
//    <name> DMAMUX_RG1CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020904) DMAMUX request generator channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RG1CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_RG1CR = (DMAMUX_DMAMUX_RG1CR & ~(0xFF011FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF011F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_SIG_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_OIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG1CR_GNBREQ </item>
//  </rtree>
//  


// -----------------------  Register Item Address: DMAMUX_DMAMUX_RG2CR  ---------------------------
// SVD Line: 6056

unsigned int DMAMUX_DMAMUX_RG2CR __AT (0x40020908);



// -------------------------  Field Item: DMAMUX_DMAMUX_RG2CR_SIG_ID  -----------------------------
// SVD Line: 6065

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_SIG_ID
//    <name> SIG_ID </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40020908) Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG2CR >> 0) & 0x1F), ((DMAMUX_DMAMUX_RG2CR = (DMAMUX_DMAMUX_RG2CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG2CR_OIE  ------------------------------
// SVD Line: 6073

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_OIE
//    <name> OIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40020908) \nTrigger overrun interrupt enable\n0 : B_0x0 = interrupt on a trigger overrun event occurrence is disabled\n1 : B_0x1 = interrupt on a trigger overrun event occurrence is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG2CR ) </loc>
//      <o.8..8> OIE
//        <0=> 0: B_0x0 = interrupt on a trigger overrun event occurrence is disabled
//        <1=> 1: B_0x1 = interrupt on a trigger overrun event occurrence is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG2CR_GE  -------------------------------
// SVD Line: 6092

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GE
//    <name> GE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40020908) \nDMA request generator channel x enable\n0 : B_0x0 = DMA request generator channel x disabled\n1 : B_0x1 = DMA request generator channel x enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG2CR ) </loc>
//      <o.16..16> GE
//        <0=> 0: B_0x0 = DMA request generator channel x disabled
//        <1=> 1: B_0x1 = DMA request generator channel x enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RG2CR_GPOL  ------------------------------
// SVD Line: 6111

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GPOL
//    <name> GPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40020908) \nDMA request generator trigger polarity Defines the edge polarity of the selected trigger input\n0 : B_0x0 = no event. I.e. none trigger detection nor generation.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG2CR ) </loc>
//      <o.18..17> GPOL
//        <0=> 0: B_0x0 = no event. I.e. none trigger detection nor generation.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_RG2CR_GNBREQ  -----------------------------
// SVD Line: 6141

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GNBREQ
//    <name> GNBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x40020908) Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field shall only be written when GE bit is disabled. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG2CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_RG2CR = (DMAMUX_DMAMUX_RG2CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RG2CR  ------------------------------
// SVD Line: 6056

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RG2CR
//    <name> DMAMUX_RG2CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40020908) DMAMUX request generator channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RG2CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_RG2CR = (DMAMUX_DMAMUX_RG2CR & ~(0xFF011FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF011F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_SIG_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_OIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG2CR_GNBREQ </item>
//  </rtree>
//  


// -----------------------  Register Item Address: DMAMUX_DMAMUX_RG3CR  ---------------------------
// SVD Line: 6152

unsigned int DMAMUX_DMAMUX_RG3CR __AT (0x4002090C);



// -------------------------  Field Item: DMAMUX_DMAMUX_RG3CR_SIG_ID  -----------------------------
// SVD Line: 6161

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_SIG_ID
//    <name> SIG_ID </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x4002090C) Signal identification Selects the DMA request trigger input used for the channel x of the DMA request generator </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG3CR >> 0) & 0x1F), ((DMAMUX_DMAMUX_RG3CR = (DMAMUX_DMAMUX_RG3CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG3CR_OIE  ------------------------------
// SVD Line: 6169

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_OIE
//    <name> OIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4002090C) \nTrigger overrun interrupt enable\n0 : B_0x0 = interrupt on a trigger overrun event occurrence is disabled\n1 : B_0x1 = interrupt on a trigger overrun event occurrence is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG3CR ) </loc>
//      <o.8..8> OIE
//        <0=> 0: B_0x0 = interrupt on a trigger overrun event occurrence is disabled
//        <1=> 1: B_0x1 = interrupt on a trigger overrun event occurrence is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RG3CR_GE  -------------------------------
// SVD Line: 6188

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GE
//    <name> GE </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x4002090C) \nDMA request generator channel x enable\n0 : B_0x0 = DMA request generator channel x disabled\n1 : B_0x1 = DMA request generator channel x enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG3CR ) </loc>
//      <o.16..16> GE
//        <0=> 0: B_0x0 = DMA request generator channel x disabled
//        <1=> 1: B_0x1 = DMA request generator channel x enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RG3CR_GPOL  ------------------------------
// SVD Line: 6207

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GPOL
//    <name> GPOL </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x4002090C) \nDMA request generator trigger polarity Defines the edge polarity of the selected trigger input\n0 : B_0x0 = no event. I.e. none trigger detection nor generation.\n1 : B_0x1 = rising edge\n2 : B_0x2 = falling edge\n3 : B_0x3 = rising and falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RG3CR ) </loc>
//      <o.18..17> GPOL
//        <0=> 0: B_0x0 = no event. I.e. none trigger detection nor generation.
//        <1=> 1: B_0x1 = rising edge
//        <2=> 2: B_0x2 = falling edge
//        <3=> 3: B_0x3 = rising and falling edge
//    </combo>
//  </item>
//  


// -------------------------  Field Item: DMAMUX_DMAMUX_RG3CR_GNBREQ  -----------------------------
// SVD Line: 6237

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GNBREQ
//    <name> GNBREQ </name>
//    <rw> 
//    <i> [Bits 23..19] RW (@ 0x4002090C) Number of DMA requests to be generated (minus 1) Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1. Note: This field shall only be written when GE bit is disabled. </i>
//    <edit> 
//      <loc> ( (unsigned char)((DMAMUX_DMAMUX_RG3CR >> 19) & 0x1F), ((DMAMUX_DMAMUX_RG3CR = (DMAMUX_DMAMUX_RG3CR & ~(0x1FUL << 19 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 19 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RG3CR  ------------------------------
// SVD Line: 6152

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RG3CR
//    <name> DMAMUX_RG3CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4002090C) DMAMUX request generator channel x configuration register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RG3CR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_RG3CR = (DMAMUX_DMAMUX_RG3CR & ~(0xFF011FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF011F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_SIG_ID </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_OIE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GE </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GPOL </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RG3CR_GNBREQ </item>
//  </rtree>
//  


// ------------------------  Register Item Address: DMAMUX_DMAMUX_RGSR  ---------------------------
// SVD Line: 6248

unsigned int DMAMUX_DMAMUX_RGSR __AT (0x40020940);



// ---------------------------  Field Item: DMAMUX_DMAMUX_RGSR_OF0  -------------------------------
// SVD Line: 6257

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF0
//    <name> OF0 </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x40020940) Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGSR ) </loc>
//      <o.0..0> OF0
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RGSR_OF1  -------------------------------
// SVD Line: 6266

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF1
//    <name> OF1 </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x40020940) Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGSR ) </loc>
//      <o.1..1> OF1
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RGSR_OF2  -------------------------------
// SVD Line: 6275

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF2
//    <name> OF2 </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40020940) Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGSR ) </loc>
//      <o.2..2> OF2
//    </check>
//  </item>
//  


// ---------------------------  Field Item: DMAMUX_DMAMUX_RGSR_OF3  -------------------------------
// SVD Line: 6284

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF3
//    <name> OF3 </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40020940) Trigger overrun event flag The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register). The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGSR ) </loc>
//      <o.3..3> OF3
//    </check>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RGSR  -------------------------------
// SVD Line: 6248

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RGSR
//    <name> DMAMUX_RGSR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40020940) DMAMUX request generator interrupt status register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RGSR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF0 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF1 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF2 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGSR_OF3 </item>
//  </rtree>
//  


// -----------------------  Register Item Address: DMAMUX_DMAMUX_RGCFR  ---------------------------
// SVD Line: 6295

unsigned int DMAMUX_DMAMUX_RGCFR __AT (0x40020944);



// --------------------------  Field Item: DMAMUX_DMAMUX_RGCFR_COF0  ------------------------------
// SVD Line: 6304

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF0
//    <name> COF0 </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40020944) Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGCFR ) </loc>
//      <o.0..0> COF0
//    </check>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RGCFR_COF1  ------------------------------
// SVD Line: 6312

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF1
//    <name> COF1 </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40020944) Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGCFR ) </loc>
//      <o.1..1> COF1
//    </check>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RGCFR_COF2  ------------------------------
// SVD Line: 6320

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF2
//    <name> COF2 </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40020944) Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGCFR ) </loc>
//      <o.2..2> COF2
//    </check>
//  </item>
//  


// --------------------------  Field Item: DMAMUX_DMAMUX_RGCFR_COF3  ------------------------------
// SVD Line: 6328

//  <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF3
//    <name> COF3 </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40020944) Clear trigger overrun event flag Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register. </i>
//    <check> 
//      <loc> ( (unsigned int) DMAMUX_DMAMUX_RGCFR ) </loc>
//      <o.3..3> COF3
//    </check>
//  </item>
//  


// ---------------------------  Register RTree: DMAMUX_DMAMUX_RGCFR  ------------------------------
// SVD Line: 6295

//  <rtree> SFDITEM_REG__DMAMUX_DMAMUX_RGCFR
//    <name> DMAMUX_RGCFR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40020944) DMAMUX request generator interrupt clear flag register </i>
//    <loc> ( (unsigned int)((DMAMUX_DMAMUX_RGCFR >> 0) & 0xFFFFFFFF), ((DMAMUX_DMAMUX_RGCFR = (DMAMUX_DMAMUX_RGCFR & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF0 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF1 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF2 </item>
//    <item> SFDITEM_FIELD__DMAMUX_DMAMUX_RGCFR_COF3 </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: DMAMUX  ------------------------------------
// SVD Line: 4845

//  <view> DMAMUX
//    <name> DMAMUX </name>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C0CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C1CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C2CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C3CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C4CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C5CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_C6CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_CSR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_CFR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RG0CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RG1CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RG2CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RG3CR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RGSR </item>
//    <item> SFDITEM_REG__DMAMUX_DMAMUX_RGCFR </item>
//  </view>
//  


// -------------------------  Register Item Address: HDMI_CEC_CEC_CR  -----------------------------
// SVD Line: 6356

unsigned int HDMI_CEC_CEC_CR __AT (0x40007800);



// ----------------------------  Field Item: HDMI_CEC_CEC_CR_CECEN  -------------------------------
// SVD Line: 6365

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_CECEN
//    <name> CECEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007800) \nCEC enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.\n0 : B_0x0 = CEC peripheral is off.\n1 : B_0x1 = CEC peripheral is on. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CR ) </loc>
//      <o.0..0> CECEN
//        <0=> 0: B_0x0 = CEC peripheral is off.
//        <1=> 1: B_0x1 = CEC peripheral is on.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_CR_TXSOM  -------------------------------
// SVD Line: 6385

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_TXSOM
//    <name> TXSOM </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007800) \nTx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission starts after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1. TXSOM must be set when transmission data is available into TXDR. HEADER first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR that is used only for reception.\n0 : B_0x0 = No CEC transmission is on-going\n1 : B_0x1 = CEC transmission command </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CR ) </loc>
//      <o.1..1> TXSOM
//        <0=> 0: B_0x0 = No CEC transmission is on-going
//        <1=> 1: B_0x1 = CEC transmission command
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_CR_TXEOM  -------------------------------
// SVD Line: 6411

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_TXEOM
//    <name> TXEOM </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40007800) \nTx end of message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1. TXEOM must be set before writing transmission data to TXDR. If TXEOM is set when TXSOM=0, transmitted message consists of 1 byte (HEADER) only (PING message).\n0 : B_0x0 = TXDR data byte is transmitted with EOM = 0\n1 : B_0x1 = TXDR data byte is transmitted with EOM = 1 </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CR ) </loc>
//      <o.2..2> TXEOM
//        <0=> 0: B_0x0 = TXDR data byte is transmitted with EOM = 0
//        <1=> 1: B_0x1 = TXDR data byte is transmitted with EOM = 1
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: HDMI_CEC_CEC_CR  --------------------------------
// SVD Line: 6356

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_CR
//    <name> CEC_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007800) CEC control register </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_CR >> 0) & 0xFFFFFFFF), ((HDMI_CEC_CEC_CR = (HDMI_CEC_CEC_CR & ~(0x7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_CECEN </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_TXSOM </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CR_TXEOM </item>
//  </rtree>
//  


// ------------------------  Register Item Address: HDMI_CEC_CEC_CFGR  ----------------------------
// SVD Line: 6437

unsigned int HDMI_CEC_CEC_CFGR __AT (0x40007804);



// ----------------------------  Field Item: HDMI_CEC_CEC_CFGR_SFT  -------------------------------
// SVD Line: 6448

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_SFT
//    <name> SFT </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40007804) \nSignal free time SFT bits are set by software. In the SFT=0x0 configuration, the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. 0x0 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE=1) 4 data-bit periods if CEC is the new bus initiator 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1)\n0 : Reserved - do not use\n1 : B_0x1 = 0.5 nominal data bit periods\n2 : B_0x2 = 1.5 nominal data bit periods\n3 : B_0x3 = 2.5 nominal data bit periods\n4 : B_0x4 = 3.5 nominal data bit periods\n5 : B_0x5 = 4.5 nominal data bit periods\n6 : B_0x6 = 5.5 nominal data bit periods\n7 : B_0x7 = 6.5 nominal data bit periods </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.2..0> SFT
//        <0=> 0: 
//        <1=> 1: B_0x1 = 0.5 nominal data bit periods
//        <2=> 2: B_0x2 = 1.5 nominal data bit periods
//        <3=> 3: B_0x3 = 2.5 nominal data bit periods
//        <4=> 4: B_0x4 = 3.5 nominal data bit periods
//        <5=> 5: B_0x5 = 4.5 nominal data bit periods
//        <6=> 6: B_0x6 = 5.5 nominal data bit periods
//        <7=> 7: B_0x7 = 6.5 nominal data bit periods
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_CFGR_RXTOL  ------------------------------
// SVD Line: 6497

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_RXTOL
//    <name> RXTOL </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40007804) \nRx-tolerance The RXTOL bit is set and cleared by software. Start-bit, +/- 200 s rise, +/- 200 s fall Data-bit: +/- 200 s rise. +/- 350 s fall Start-bit: +/- 400 s rise, +/- 400 s fall Data-bit: +/-300 s rise, +/- 500 s fall\n0 : B_0x0 = Standard tolerance margin:\n1 : B_0x1 = Extended tolerance </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.3..3> RXTOL
//        <0=> 0: B_0x0 = Standard tolerance margin:
//        <1=> 1: B_0x1 = Extended tolerance
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_CFGR_BRESTP  ------------------------------
// SVD Line: 6521

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BRESTP
//    <name> BRESTP </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40007804) \nRx-stop on bit rising error The BRESTP bit is set and cleared by software.\n0 : B_0x0 = BRE detection does not stop reception of the CEC message. Data bit is sampled at 1.05 ms.\n1 : B_0x1 = BRE detection stops message reception. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.4..4> BRESTP
//        <0=> 0: B_0x0 = BRE detection does not stop reception of the CEC message. Data bit is sampled at 1.05 ms.
//        <1=> 1: B_0x1 = BRE detection stops message reception.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_CFGR_BREGEN  ------------------------------
// SVD Line: 6541

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BREGEN
//    <name> BREGEN </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40007804) \nGenerate error-bit on bit rising error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0.\n0 : B_0x0 = BRE detection does not generate an error-bit on the CEC line.\n1 : B_0x1 = BRE detection generates an error-bit on the CEC line (if BRESTP is set). </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.5..5> BREGEN
//        <0=> 0: B_0x0 = BRE detection does not generate an error-bit on the CEC line.
//        <1=> 1: B_0x1 = BRE detection generates an error-bit on the CEC line (if BRESTP is set).
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_CFGR_LBPEGEN  -----------------------------
// SVD Line: 6562

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_LBPEGEN
//    <name> LBPEGEN </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40007804) \nGenerate error-bit on long bit period error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0.\n0 : B_0x0 = LBPE detection does not generate an error-bit on the CEC line.\n1 : B_0x1 = LBPE detection generates an error-bit on the CEC line. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.6..6> LBPEGEN
//        <0=> 0: B_0x0 = LBPE detection does not generate an error-bit on the CEC line.
//        <1=> 1: B_0x1 = LBPE detection generates an error-bit on the CEC line.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: HDMI_CEC_CEC_CFGR_BRDNOGEN  -----------------------------
// SVD Line: 6583

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BRDNOGEN
//    <name> BRDNOGEN </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40007804) \nAvoid error-bit generation in broadcast The BRDNOGEN bit is set and cleared by software. error-bit on the CEC line. LBPE detection with LBPEGEN=0 on a broadcast message generates an error-bit on the CEC line.\n0 : B_0x0 = BRE detection with BRESTP = 1 and BREGEN = 0 on a broadcast message generates an\n1 : B_0x1 = Error-bit is not generated in the same condition as above. An error-bit is not generated even in case of an SBPE detection in a broadcast message if listen mode is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.7..7> BRDNOGEN
//        <0=> 0: B_0x0 = BRE detection with BRESTP = 1 and BREGEN = 0 on a broadcast message generates an
//        <1=> 1: B_0x1 = Error-bit is not generated in the same condition as above. An error-bit is not generated even in case of an SBPE detection in a broadcast message if listen mode is set.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_CFGR_SFTOP  ------------------------------
// SVD Line: 6604

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_SFTOP
//    <name> SFTOP </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40007804) \nSFT option bit The SFTOPT bit is set and cleared by software.\n0 : B_0x0 = SFT timer starts when TXSOM is set by software.\n1 : B_0x1 = SFT timer starts automatically at the end of message transmission/reception. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.8..8> SFTOP
//        <0=> 0: B_0x0 = SFT timer starts when TXSOM is set by software.
//        <1=> 1: B_0x1 = SFT timer starts automatically at the end of message transmission/reception.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_CFGR_OAR  -------------------------------
// SVD Line: 6624

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_OAR
//    <name> OAR </name>
//    <rw> 
//    <i> [Bits 30..16] RW (@ 0x40007804) Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. </i>
//    <edit> 
//      <loc> ( (unsigned short)((HDMI_CEC_CEC_CFGR >> 16) & 0x7FFF), ((HDMI_CEC_CEC_CFGR = (HDMI_CEC_CEC_CFGR & ~(0x7FFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0x7FFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_CFGR_LSTN  -------------------------------
// SVD Line: 6635

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_LSTN
//    <name> LSTN </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40007804) \nListen mode LSTN bit is set and cleared by software.\n0 : B_0x0 = CEC peripheral receives only message addressed to its own address (OAR). Messages addressed to different destination are ignored. Broadcast messages are always received.\n1 : B_0x1 = CEC peripheral receives messages addressed to its own address (OAR) with positive acknowledge. Messages addressed to different destination are received, but without interfering with the CEC bus: no acknowledge sent. </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_CFGR ) </loc>
//      <o.31..31> LSTN
//        <0=> 0: B_0x0 = CEC peripheral receives only message addressed to its own address (OAR). Messages addressed to different destination are ignored. Broadcast messages are always received.
//        <1=> 1: B_0x1 = CEC peripheral receives messages addressed to its own address (OAR) with positive acknowledge. Messages addressed to different destination are received, but without interfering with the CEC bus: no acknowledge sent.
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: HDMI_CEC_CEC_CFGR  -------------------------------
// SVD Line: 6437

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_CFGR
//    <name> CEC_CFGR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007804) This register is used to configure the  HDMI-CEC controller. It is mandatory to write CEC_CFGR  only when CECEN=0. </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_CFGR >> 0) & 0xFFFFFFFF), ((HDMI_CEC_CEC_CFGR = (HDMI_CEC_CEC_CFGR & ~(0xFFFF01FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF01FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_SFT </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_RXTOL </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BRESTP </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BREGEN </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_LBPEGEN </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_BRDNOGEN </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_SFTOP </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_OAR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_CFGR_LSTN </item>
//  </rtree>
//  


// ------------------------  Register Item Address: HDMI_CEC_CEC_TXDR  ----------------------------
// SVD Line: 6657

unsigned int HDMI_CEC_CEC_TXDR __AT (0x40007808);



// ----------------------------  Field Item: HDMI_CEC_CEC_TXDR_TXD  -------------------------------
// SVD Line: 6666

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_TXDR_TXD
//    <name> TXD </name>
//    <w> 
//    <i> [Bits 7..0] WO (@ 0x40007808) Tx Data register. TXD is a write-only  register containing the data byte to be transmitted.  Note: TXD must be written when  TXSTART=1 </i>
//    <edit> 
//      <loc> ( (unsigned char)((HDMI_CEC_CEC_TXDR >> 0) & 0x0), ((HDMI_CEC_CEC_TXDR = (HDMI_CEC_CEC_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: HDMI_CEC_CEC_TXDR  -------------------------------
// SVD Line: 6657

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_TXDR
//    <name> CEC_TXDR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40007808) CEC Tx data register </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_TXDR >> 0) & 0xFFFFFFFF), ((HDMI_CEC_CEC_TXDR = (HDMI_CEC_CEC_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_TXDR_TXD </item>
//  </rtree>
//  


// ------------------------  Register Item Address: HDMI_CEC_CEC_RXDR  ----------------------------
// SVD Line: 6677

unsigned int HDMI_CEC_CEC_RXDR __AT (0x4000780C);



// ----------------------------  Field Item: HDMI_CEC_CEC_RXDR_RXD  -------------------------------
// SVD Line: 6686

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_RXDR_RXD
//    <name> RXD </name>
//    <r> 
//    <i> [Bits 7..0] RO (@ 0x4000780C) Rx Data register. RXD is read-only and  contains the last data byte which has been received  from the CEC line. </i>
//    <edit> 
//      <loc> ( (unsigned char)((HDMI_CEC_CEC_RXDR >> 0) & 0xFF) ) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: HDMI_CEC_CEC_RXDR  -------------------------------
// SVD Line: 6677

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_RXDR
//    <name> CEC_RXDR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000780C) CEC Rx Data Register </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_RXDR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_RXDR_RXD </item>
//  </rtree>
//  


// -------------------------  Register Item Address: HDMI_CEC_CEC_ISR  ----------------------------
// SVD Line: 6696

unsigned int HDMI_CEC_CEC_ISR __AT (0x40007810);



// ----------------------------  Field Item: HDMI_CEC_CEC_ISR_RXBR  -------------------------------
// SVD Line: 6706

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXBR
//    <name> RXBR </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007810) Rx-Byte Received The RXBR bit is set by  hardware to inform application that a new byte has  been received from the CEC line and stored into the  RXD buffer. RXBR is cleared by software write at  1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.0..0> RXBR
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_RXEND  -------------------------------
// SVD Line: 6716

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXEND
//    <name> RXEND </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007810) End Of Reception RXEND is set by  hardware to inform application that the last byte of  a CEC message is received from the CEC line and  stored into the RXD buffer. RXEND is set at the same  time of RXBR. RXEND is cleared by software write at  1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.1..1> RXEND
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_RXOVR  -------------------------------
// SVD Line: 6727

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXOVR
//    <name> RXOVR </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40007810) Rx-Overrun RXOVR is set by hardware if  RXBR is not yet cleared at the time a new byte is  received on the CEC line and stored into RXD. RXOVR  assertion stops message reception so that no  acknowledge is sent. In case of broadcast, a negative  acknowledge is sent. RXOVR is cleared by software  write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.2..2> RXOVR
//    </check>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_ISR_BRE  --------------------------------
// SVD Line: 6739

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_BRE
//    <name> BRE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40007810) Rx-Bit Rising Error BRE is set by  hardware in case a Data-Bit waveform is detected with  Bit Rising Error. BRE is set either at the time the  misplaced rising edge occurs, or at the end of the  maximum BRE tolerance allowed by RXTOL, in case  rising edge is still longing. BRE stops message  reception if BRESTP=1. BRE generates an Error-Bit on  the CEC line if BREGEN=1. BRE is cleared by software  write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.3..3> BRE
//    </check>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_ISR_SBPE  -------------------------------
// SVD Line: 6753

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_SBPE
//    <name> SBPE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40007810) Rx-Short Bit Period Error SBPE is set by  hardware in case a Data-Bit waveform is detected with  Short Bit Period Error. SBPE is set at the time the  anticipated falling edge occurs. SBPE generates an  Error-Bit on the CEC line. SBPE is cleared by  software write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.4..4> SBPE
//    </check>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_ISR_LBPE  -------------------------------
// SVD Line: 6764

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_LBPE
//    <name> LBPE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40007810) Rx-Long Bit Period Error LBPE is set by  hardware in case a Data-Bit waveform is detected with  Long Bit Period Error. LBPE is set at the end of the  maximum bit-extension tolerance allowed by RXTOL, in  case falling edge is still longing. LBPE always stops  reception of the CEC message. LBPE generates an  Error-Bit on the CEC line if LBPEGEN=1. In case of  broadcast, Error-Bit is generated even in case of  LBPEGEN=0. LBPE is cleared by software write at  1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.5..5> LBPE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_RXACKE  ------------------------------
// SVD Line: 6779

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXACKE
//    <name> RXACKE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40007810) Rx-Missing Acknowledge In receive mode,  RXACKE is set by hardware to inform application that  no acknowledge was seen on the CEC line. RXACKE  applies only for broadcast messages and in listen  mode also for not directly addressed messages  (destination address not enabled in OAR). RXACKE  aborts message reception. RXACKE is cleared by  software write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.6..6> RXACKE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_ARBLST  ------------------------------
// SVD Line: 6792

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_ARBLST
//    <name> ARBLST </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40007810) Arbitration Lost ARBLST is set by  hardware to inform application that CEC device is  switching to reception due to arbitration lost event  following the TXSOM command. ARBLST can be due either  to a contending CEC device starting earlier or  starting at the same time but with higher HEADER  priority. After ARBLST assertion TXSOM bit keeps  pending for next transmission attempt. ARBLST is  cleared by software write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.7..7> ARBLST
//    </check>
//  </item>
//  


// ----------------------------  Field Item: HDMI_CEC_CEC_ISR_TXBR  -------------------------------
// SVD Line: 6806

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXBR
//    <name> TXBR </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40007810) Tx-Byte Request TXBR is set by hardware  to inform application that the next transmission data  has to be written to TXDR. TXBR is set when the 4th  bit of currently transmitted byte is sent.  Application must write the next byte to TXDR within 6  nominal data-bit periods before transmission underrun  error occurs (TXUDR). TXBR is cleared by software  write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.8..8> TXBR
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_TXEND  -------------------------------
// SVD Line: 6819

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXEND
//    <name> TXEND </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40007810) End of Transmission TXEND is set by  hardware to inform application that the last byte of  the CEC message has been successfully transmitted.  TXEND clears the TXSOM and TXEOM control bits. TXEND  is cleared by software write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.9..9> TXEND
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_TXUDR  -------------------------------
// SVD Line: 6829

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXUDR
//    <name> TXUDR </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40007810) Tx-Buffer Underrun In transmission mode,  TXUDR is set by hardware if application was not in  time to load TXDR before of next byte transmission.  TXUDR aborts message transmission and clears TXSOM  and TXEOM control bits. TXUDR is cleared by software  write at 1 </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.10..10> TXUDR
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_TXERR  -------------------------------
// SVD Line: 6840

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXERR
//    <name> TXERR </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40007810) Tx-Error In transmission mode, TXERR is  set by hardware if the CEC initiator detects low  impedance on the CEC line while it is released. TXERR  aborts message transmission and clears TXSOM and  TXEOM controls. TXERR is cleared by software write at  1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.11..11> TXERR
//    </check>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_ISR_TXACKE  ------------------------------
// SVD Line: 6851

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXACKE
//    <name> TXACKE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40007810) Tx-Missing Acknowledge Error In  transmission mode, TXACKE is set by hardware to  inform application that no acknowledge was received.  In case of broadcast transmission, TXACKE informs  application that a negative acknowledge was received.  TXACKE aborts message transmission and clears TXSOM  and TXEOM controls. TXACKE is cleared by software  write at 1. </i>
//    <check> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_ISR ) </loc>
//      <o.12..12> TXACKE
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: HDMI_CEC_CEC_ISR  --------------------------------
// SVD Line: 6696

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_ISR
//    <name> CEC_ISR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007810) CEC Interrupt and Status  Register </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_ISR >> 0) & 0xFFFFFFFF), ((HDMI_CEC_CEC_ISR = (HDMI_CEC_CEC_ISR & ~(0x1FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXBR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXEND </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXOVR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_BRE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_SBPE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_LBPE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_RXACKE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_ARBLST </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXBR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXEND </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXUDR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXERR </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_ISR_TXACKE </item>
//  </rtree>
//  


// -------------------------  Register Item Address: HDMI_CEC_CEC_IER  ----------------------------
// SVD Line: 6866

unsigned int HDMI_CEC_CEC_IER __AT (0x40007814);



// ---------------------------  Field Item: HDMI_CEC_CEC_IER_RXBRIE  ------------------------------
// SVD Line: 6875

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXBRIE
//    <name> RXBRIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007814) \nRx-byte received interrupt enable The RXBRIE bit is set and cleared by software.\n0 : B_0x0 = RXBR interrupt disabled\n1 : B_0x1 = RXBR interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.0..0> RXBRIE
//        <0=> 0: B_0x0 = RXBR interrupt disabled
//        <1=> 1: B_0x1 = RXBR interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_RXENDIE  ------------------------------
// SVD Line: 6895

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXENDIE
//    <name> RXENDIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007814) \nEnd of reception interrupt enable The RXENDIE bit is set and cleared by software.\n0 : B_0x0 = RXEND interrupt disabled\n1 : B_0x1 = RXEND interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.1..1> RXENDIE
//        <0=> 0: B_0x0 = RXEND interrupt disabled
//        <1=> 1: B_0x1 = RXEND interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_RXOVRIE  ------------------------------
// SVD Line: 6915

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXOVRIE
//    <name> RXOVRIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40007814) \nRx-buffer overrun interrupt enable The RXOVRIE bit is set and cleared by software.\n0 : B_0x0 = RXOVR interrupt disabled\n1 : B_0x1 = RXOVR interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.2..2> RXOVRIE
//        <0=> 0: B_0x0 = RXOVR interrupt disabled
//        <1=> 1: B_0x1 = RXOVR interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_IER_BREIE  -------------------------------
// SVD Line: 6935

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_BREIE
//    <name> BREIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40007814) \nBit rising error interrupt enable The BREIE bit is set and cleared by software.\n0 : B_0x0 = BRE interrupt disabled\n1 : B_0x1 = BRE interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.3..3> BREIE
//        <0=> 0: B_0x0 = BRE interrupt disabled
//        <1=> 1: B_0x1 = BRE interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_IER_SBPEIE  ------------------------------
// SVD Line: 6955

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_SBPEIE
//    <name> SBPEIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40007814) \nShort bit period error interrupt enable The SBPEIE bit is set and cleared by software.\n0 : B_0x0 = SBPE interrupt disabled\n1 : B_0x1 = SBPE interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.4..4> SBPEIE
//        <0=> 0: B_0x0 = SBPE interrupt disabled
//        <1=> 1: B_0x1 = SBPE interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_IER_LBPEIE  ------------------------------
// SVD Line: 6975

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_LBPEIE
//    <name> LBPEIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40007814) \nLong bit period error interrupt enable The LBPEIE bit is set and cleared by software.\n0 : B_0x0 = LBPE interrupt disabled\n1 : B_0x1 = LBPE interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.5..5> LBPEIE
//        <0=> 0: B_0x0 = LBPE interrupt disabled
//        <1=> 1: B_0x1 = LBPE interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_RXACKIE  ------------------------------
// SVD Line: 6995

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXACKIE
//    <name> RXACKIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40007814) \nRx-missing acknowledge error interrupt enable The RXACKIE bit is set and cleared by software.\n0 : B_0x0 = RXACKE interrupt disabled\n1 : B_0x1 = RXACKE interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.6..6> RXACKIE
//        <0=> 0: B_0x0 = RXACKE interrupt disabled
//        <1=> 1: B_0x1 = RXACKE interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_ARBLSTIE  -----------------------------
// SVD Line: 7015

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_ARBLSTIE
//    <name> ARBLSTIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40007814) \nArbitration lost interrupt enable The ARBLSTIE bit is set and cleared by software.\n0 : B_0x0 = ARBLST interrupt disabled\n1 : B_0x1 = ARBLST interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.7..7> ARBLSTIE
//        <0=> 0: B_0x0 = ARBLST interrupt disabled
//        <1=> 1: B_0x1 = ARBLST interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: HDMI_CEC_CEC_IER_TXBRIE  ------------------------------
// SVD Line: 7035

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXBRIE
//    <name> TXBRIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40007814) \nTx-byte request interrupt enable The TXBRIE bit is set and cleared by software.\n0 : B_0x0 = TXBR interrupt disabled\n1 : B_0x1 = TXBR interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.8..8> TXBRIE
//        <0=> 0: B_0x0 = TXBR interrupt disabled
//        <1=> 1: B_0x1 = TXBR interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_TXENDIE  ------------------------------
// SVD Line: 7055

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXENDIE
//    <name> TXENDIE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40007814) \nTx-end of message interrupt enable The TXENDIE bit is set and cleared by software.\n0 : B_0x0 = TXEND interrupt disabled\n1 : B_0x1 = TXEND interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.9..9> TXENDIE
//        <0=> 0: B_0x0 = TXEND interrupt disabled
//        <1=> 1: B_0x1 = TXEND interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_TXUDRIE  ------------------------------
// SVD Line: 7075

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXUDRIE
//    <name> TXUDRIE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40007814) \nTx-underrun interrupt enable The TXUDRIE bit is set and cleared by software.\n0 : B_0x0 = TXUDR interrupt disabled\n1 : B_0x1 = TXUDR interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.10..10> TXUDRIE
//        <0=> 0: B_0x0 = TXUDR interrupt disabled
//        <1=> 1: B_0x1 = TXUDR interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_TXERRIE  ------------------------------
// SVD Line: 7095

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXERRIE
//    <name> TXERRIE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40007814) \nTx-error interrupt enable The TXERRIE bit is set and cleared by software.\n0 : B_0x0 = TXERR interrupt disabled\n1 : B_0x1 = TXERR interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.11..11> TXERRIE
//        <0=> 0: B_0x0 = TXERR interrupt disabled
//        <1=> 1: B_0x1 = TXERR interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: HDMI_CEC_CEC_IER_TXACKIE  ------------------------------
// SVD Line: 7115

//  <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXACKIE
//    <name> TXACKIE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40007814) \nTx-missing acknowledge error interrupt enable The TXACKEIE bit is set and cleared by software.\n0 : B_0x0 = TXACKE interrupt disabled\n1 : B_0x1 = TXACKE interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) HDMI_CEC_CEC_IER ) </loc>
//      <o.12..12> TXACKIE
//        <0=> 0: B_0x0 = TXACKE interrupt disabled
//        <1=> 1: B_0x1 = TXACKE interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: HDMI_CEC_CEC_IER  --------------------------------
// SVD Line: 6866

//  <rtree> SFDITEM_REG__HDMI_CEC_CEC_IER
//    <name> CEC_IER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007814) CEC interrupt enable register </i>
//    <loc> ( (unsigned int)((HDMI_CEC_CEC_IER >> 0) & 0xFFFFFFFF), ((HDMI_CEC_CEC_IER = (HDMI_CEC_CEC_IER & ~(0x1FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXBRIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXENDIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXOVRIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_BREIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_SBPEIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_LBPEIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_RXACKIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_ARBLSTIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXBRIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXENDIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXUDRIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXERRIE </item>
//    <item> SFDITEM_FIELD__HDMI_CEC_CEC_IER_TXACKIE </item>
//  </rtree>
//  


// --------------------------------  Peripheral View: HDMI_CEC  -----------------------------------
// SVD Line: 6340

//  <view> HDMI_CEC
//    <name> HDMI_CEC </name>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_CR </item>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_CFGR </item>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_TXDR </item>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_RXDR </item>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_ISR </item>
//    <item> SFDITEM_REG__HDMI_CEC_CEC_IER </item>
//  </view>
//  


// ---------------------------  Register Item Address: I2C1_I2C_CR1  ------------------------------
// SVD Line: 7155

unsigned int I2C1_I2C_CR1 __AT (0x40005400);



// -------------------------------  Field Item: I2C1_I2C_CR1_PE  ----------------------------------
// SVD Line: 7164

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_PE
//    <name> PE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40005400) \nPeripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.\n0 : B_0x0 = Peripheral disable\n1 : B_0x1 = Peripheral enable </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = Peripheral disable
//        <1=> 1: B_0x1 = Peripheral enable
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_TXIE  ---------------------------------
// SVD Line: 7184

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_TXIE
//    <name> TXIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40005400) \nTX Interrupt enable\n0 : B_0x0 = Transmit (TXIS) interrupt disabled\n1 : B_0x1 = Transmit (TXIS) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.1..1> TXIE
//        <0=> 0: B_0x0 = Transmit (TXIS) interrupt disabled
//        <1=> 1: B_0x1 = Transmit (TXIS) interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_RXIE  ---------------------------------
// SVD Line: 7203

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_RXIE
//    <name> RXIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40005400) \nRX Interrupt enable\n0 : B_0x0 = Receive (RXNE) interrupt disabled\n1 : B_0x1 = Receive (RXNE) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.2..2> RXIE
//        <0=> 0: B_0x0 = Receive (RXNE) interrupt disabled
//        <1=> 1: B_0x1 = Receive (RXNE) interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_ADDRIE  --------------------------------
// SVD Line: 7222

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_ADDRIE
//    <name> ADDRIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40005400) \nAddress match Interrupt enable (slave only)\n0 : B_0x0 = Address match (ADDR) interrupts disabled\n1 : B_0x1 = Address match (ADDR) interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.3..3> ADDRIE
//        <0=> 0: B_0x0 = Address match (ADDR) interrupts disabled
//        <1=> 1: B_0x1 = Address match (ADDR) interrupts enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_NACKIE  --------------------------------
// SVD Line: 7241

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_NACKIE
//    <name> NACKIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40005400) \nNot acknowledge received Interrupt enable\n0 : B_0x0 = Not acknowledge (NACKF) received interrupts disabled\n1 : B_0x1 = Not acknowledge (NACKF) received interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.4..4> NACKIE
//        <0=> 0: B_0x0 = Not acknowledge (NACKF) received interrupts disabled
//        <1=> 1: B_0x1 = Not acknowledge (NACKF) received interrupts enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_STOPIE  --------------------------------
// SVD Line: 7260

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_STOPIE
//    <name> STOPIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40005400) \nStop detection Interrupt enable\n0 : B_0x0 = Stop detection (STOPF) interrupt disabled\n1 : B_0x1 = Stop detection (STOPF) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.5..5> STOPIE
//        <0=> 0: B_0x0 = Stop detection (STOPF) interrupt disabled
//        <1=> 1: B_0x1 = Stop detection (STOPF) interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_TCIE  ---------------------------------
// SVD Line: 7279

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40005400) \nTransfer Complete interrupt enable Note: Any of these events generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)\n0 : B_0x0 = Transfer Complete interrupt disabled\n1 : B_0x1 = Transfer Complete interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Transfer Complete interrupt disabled
//        <1=> 1: B_0x1 = Transfer Complete interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_ERRIE  ---------------------------------
// SVD Line: 7301

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_ERRIE
//    <name> ERRIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40005400) \nError interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)\n0 : B_0x0 = Error detection interrupts disabled\n1 : B_0x1 = Error detection interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.7..7> ERRIE
//        <0=> 0: B_0x0 = Error detection interrupts disabled
//        <1=> 1: B_0x1 = Error detection interrupts enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_DNF  ----------------------------------
// SVD Line: 7327

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_DNF
//    <name> DNF </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40005400) \nDigital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Digital filter disabled\n1 : B_0x1 = Digital filter enabled and filtering capability up to 1 tI2CCLK\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : B_0xF = digital filter enabled and filtering capability up to15 tI2CCLK </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.11..8> DNF
//        <0=> 0: B_0x0 = Digital filter disabled
//        <1=> 1: B_0x1 = Digital filter enabled and filtering capability up to 1 tI2CCLK
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: B_0xF = digital filter enabled and filtering capability up to15 tI2CCLK
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_ANFOFF  --------------------------------
// SVD Line: 7355

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_ANFOFF
//    <name> ANFOFF </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005400) \nAnalog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Analog noise filter enabled\n1 : B_0x1 = Analog noise filter disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.12..12> ANFOFF
//        <0=> 0: B_0x0 = Analog noise filter enabled
//        <1=> 1: B_0x1 = Analog noise filter disabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR1_TXDMAEN  --------------------------------
// SVD Line: 7375

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_TXDMAEN
//    <name> TXDMAEN </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40005400) \nDMA transmission requests enable\n0 : B_0x0 = DMA mode disabled for transmission\n1 : B_0x1 = DMA mode enabled for transmission </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.14..14> TXDMAEN
//        <0=> 0: B_0x0 = DMA mode disabled for transmission
//        <1=> 1: B_0x1 = DMA mode enabled for transmission
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR1_RXDMAEN  --------------------------------
// SVD Line: 7394

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_RXDMAEN
//    <name> RXDMAEN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005400) \nDMA reception requests enable\n0 : B_0x0 = DMA mode disabled for reception\n1 : B_0x1 = DMA mode enabled for reception </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.15..15> RXDMAEN
//        <0=> 0: B_0x0 = DMA mode disabled for reception
//        <1=> 1: B_0x1 = DMA mode enabled for reception
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_SBC  ----------------------------------
// SVD Line: 7413

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_SBC
//    <name> SBC </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40005400) \nSlave byte control This bit is used to enable hardware byte control in slave mode.\n0 : B_0x0 = Slave byte control disabled\n1 : B_0x1 = Slave byte control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.16..16> SBC
//        <0=> 0: B_0x0 = Slave byte control disabled
//        <1=> 1: B_0x1 = Slave byte control enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: I2C1_I2C_CR1_NOSTRETCH  -------------------------------
// SVD Line: 7433

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_NOSTRETCH
//    <name> NOSTRETCH </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40005400) \nClock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Clock stretching enabled\n1 : B_0x1 = Clock stretching disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.17..17> NOSTRETCH
//        <0=> 0: B_0x0 = Clock stretching enabled
//        <1=> 1: B_0x1 = Clock stretching disabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_WUPEN  ---------------------------------
// SVD Line: 7454

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_WUPEN
//    <name> WUPEN </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40005400) \nWakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0. Refer to . Note: WUPEN can be set only when DNF = '0000\n0 : B_0x0 = Wakeup from Stop mode disable.\n1 : B_0x1 = Wakeup from Stop mode enable. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.18..18> WUPEN
//        <0=> 0: B_0x0 = Wakeup from Stop mode disable.
//        <1=> 1: B_0x1 = Wakeup from Stop mode enable.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR1_GCEN  ---------------------------------
// SVD Line: 7475

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_GCEN
//    <name> GCEN </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40005400) \nGeneral call enable\n0 : B_0x0 = General call disabled. Address 0b00000000 is NACKed.\n1 : B_0x1 = General call enabled. Address 0b00000000 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.19..19> GCEN
//        <0=> 0: B_0x0 = General call disabled. Address 0b00000000 is NACKed.
//        <1=> 1: B_0x1 = General call enabled. Address 0b00000000 is ACKed.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_SMBHEN  --------------------------------
// SVD Line: 7494

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_SMBHEN
//    <name> SMBHEN </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40005400) \nSMBus Host Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = Host Address disabled. Address 0b0001000x is NACKed.\n1 : B_0x1 = Host Address enabled. Address 0b0001000x is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.20..20> SMBHEN
//        <0=> 0: B_0x0 = Host Address disabled. Address 0b0001000x is NACKed.
//        <1=> 1: B_0x1 = Host Address enabled. Address 0b0001000x is ACKed.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_SMBDEN  --------------------------------
// SVD Line: 7514

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_SMBDEN
//    <name> SMBDEN </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x40005400) \nSMBus Device Default Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = Device Default Address disabled. Address 0b1100001x is NACKed.\n1 : B_0x1 = Device Default Address enabled. Address 0b1100001x is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.21..21> SMBDEN
//        <0=> 0: B_0x0 = Device Default Address disabled. Address 0b1100001x is NACKed.
//        <1=> 1: B_0x1 = Device Default Address enabled. Address 0b1100001x is ACKed.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR1_ALERTEN  --------------------------------
// SVD Line: 7534

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_ALERTEN
//    <name> ALERTEN </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40005400) \nSMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).\n1 : B_0x1 = The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.22..22> ALERTEN
//        <0=> 0: B_0x0 = The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).
//        <1=> 1: B_0x1 = The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR1_PECEN  ---------------------------------
// SVD Line: 7555

//  <item> SFDITEM_FIELD__I2C1_I2C_CR1_PECEN
//    <name> PECEN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40005400) \nPEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = PEC calculation disabled\n1 : B_0x1 = PEC calculation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR1 ) </loc>
//      <o.23..23> PECEN
//        <0=> 0: B_0x0 = PEC calculation disabled
//        <1=> 1: B_0x1 = PEC calculation enabled
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_CR1  ----------------------------------
// SVD Line: 7155

//  <rtree> SFDITEM_REG__I2C1_I2C_CR1
//    <name> I2C_CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005400) Control register 1 </i>
//    <loc> ( (unsigned int)((I2C1_I2C_CR1 >> 0) & 0xFFFFFFFF), ((I2C1_I2C_CR1 = (I2C1_I2C_CR1 & ~(0xFFDFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFDFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_PE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_TXIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_RXIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_ADDRIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_NACKIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_STOPIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_TCIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_ERRIE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_DNF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_ANFOFF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_TXDMAEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_RXDMAEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_SBC </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_NOSTRETCH </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_WUPEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_GCEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_SMBHEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_SMBDEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_ALERTEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR1_PECEN </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C1_I2C_CR2  ------------------------------
// SVD Line: 7577

unsigned int I2C1_I2C_CR2 __AT (0x40005404);



// ------------------------------  Field Item: I2C1_I2C_CR2_SADD  ---------------------------------
// SVD Line: 7586

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_SADD
//    <name> SADD </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40005404) Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] should be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C1_I2C_CR2 >> 0) & 0x3FF), ((I2C1_I2C_CR2 = (I2C1_I2C_CR2 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR2_RD_WRN  --------------------------------
// SVD Line: 7598

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_RD_WRN
//    <name> RD_WRN </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40005404) \nTransfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = Master requests a write transfer.\n1 : B_0x1 = Master requests a read transfer. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.10..10> RD_WRN
//        <0=> 0: B_0x0 = Master requests a write transfer.
//        <1=> 1: B_0x1 = Master requests a read transfer.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR2_ADD10  ---------------------------------
// SVD Line: 7618

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_ADD10
//    <name> ADD10 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40005404) \n10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = The master operates in 7-bit addressing mode,\n1 : B_0x1 = The master operates in 10-bit addressing mode </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.11..11> ADD10
//        <0=> 0: B_0x0 = The master operates in 7-bit addressing mode,
//        <1=> 1: B_0x1 = The master operates in 10-bit addressing mode
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR2_HEAD10R  --------------------------------
// SVD Line: 7638

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_HEAD10R
//    <name> HEAD10R </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005404) \n10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.\n1 : B_0x1 = The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.12..12> HEAD10R
//        <0=> 0: B_0x0 = The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.
//        <1=> 1: B_0x1 = The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR2_START  ---------------------------------
// SVD Line: 7658

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_START
//    <name> START </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40005404) \nStart generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit generates a START condition once the bus is free. Note: Writing '0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.\n0 : B_0x0 = No Start generation.\n1 : B_0x1 = Restart/Start generation: </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.13..13> START
//        <0=> 0: B_0x0 = No Start generation.
//        <1=> 1: B_0x1 = Restart/Start generation:
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR2_STOP  ---------------------------------
// SVD Line: 7683

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_STOP
//    <name> STOP </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40005404) \nStop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In Master Mode: Note: Writing '0 to this bit has no effect.\n0 : B_0x0 = No Stop generation.\n1 : B_0x1 = Stop generation after current byte transfer. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.14..14> STOP
//        <0=> 0: B_0x0 = No Stop generation.
//        <1=> 1: B_0x1 = Stop generation after current byte transfer.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_CR2_NACK  ---------------------------------
// SVD Line: 7705

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_NACK
//    <name> NACK </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005404) \nNACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing '0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.\n0 : B_0x0 = an ACK is sent after current received byte.\n1 : B_0x1 = a NACK is sent after current received byte. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.15..15> NACK
//        <0=> 0: B_0x0 = an ACK is sent after current received byte.
//        <1=> 1: B_0x1 = a NACK is sent after current received byte.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR2_NBYTES  --------------------------------
// SVD Line: 7729

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_NBYTES
//    <name> NBYTES </name>
//    <rw> 
//    <i> [Bits 23..16] RW (@ 0x40005404) Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_CR2 >> 16) & 0xFF), ((I2C1_I2C_CR2 = (I2C1_I2C_CR2 & ~(0xFFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_CR2_RELOAD  --------------------------------
// SVD Line: 7738

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_RELOAD
//    <name> RELOAD </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40005404) \nNBYTES reload mode This bit is set and cleared by software.\n0 : B_0x0 = The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).\n1 : B_0x1 = The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.24..24> RELOAD
//        <0=> 0: B_0x0 = The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).
//        <1=> 1: B_0x1 = The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR2_AUTOEND  --------------------------------
// SVD Line: 7758

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_AUTOEND
//    <name> AUTOEND </name>
//    <rw> 
//    <i> [Bit 25] RW (@ 0x40005404) \nAutomatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.\n0 : B_0x0 = software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.\n1 : B_0x1 = Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.25..25> AUTOEND
//        <0=> 0: B_0x0 = software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.
//        <1=> 1: B_0x1 = Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_CR2_PECBYTE  --------------------------------
// SVD Line: 7779

//  <item> SFDITEM_FIELD__I2C1_I2C_CR2_PECBYTE
//    <name> PECBYTE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40005404) \nPacket error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing '0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = No PEC transfer.\n1 : B_0x1 = PEC transmission/reception is requested </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_CR2 ) </loc>
//      <o.26..26> PECBYTE
//        <0=> 0: B_0x0 = No PEC transfer.
//        <1=> 1: B_0x1 = PEC transmission/reception is requested
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_CR2  ----------------------------------
// SVD Line: 7577

//  <rtree> SFDITEM_REG__I2C1_I2C_CR2
//    <name> I2C_CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005404) Control register 2 </i>
//    <loc> ( (unsigned int)((I2C1_I2C_CR2 >> 0) & 0xFFFFFFFF), ((I2C1_I2C_CR2 = (I2C1_I2C_CR2 & ~(0x7FFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_SADD </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_RD_WRN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_ADD10 </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_HEAD10R </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_START </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_STOP </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_NACK </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_NBYTES </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_RELOAD </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_AUTOEND </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_CR2_PECBYTE </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C1_I2C_OAR1  ------------------------------
// SVD Line: 7805

unsigned int I2C1_I2C_OAR1 __AT (0x40005408);



// ------------------------------  Field Item: I2C1_I2C_OAR1_OA1  ---------------------------------
// SVD Line: 7814

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1
//    <name> OA1 </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40005408) Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C1_I2C_OAR1 >> 0) & 0x3FF), ((I2C1_I2C_OAR1 = (I2C1_I2C_OAR1 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_OAR1_OA1MODE  -------------------------------
// SVD Line: 7824

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1MODE
//    <name> OA1MODE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40005408) \nOwn Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.\n0 : B_0x0 = Own address 1 is a 7-bit address.\n1 : B_0x1 = Own address 1 is a 10-bit address. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_OAR1 ) </loc>
//      <o.10..10> OA1MODE
//        <0=> 0: B_0x0 = Own address 1 is a 7-bit address.
//        <1=> 1: B_0x1 = Own address 1 is a 10-bit address.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_OAR1_OA1EN  --------------------------------
// SVD Line: 7844

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1EN
//    <name> OA1EN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005408) \nOwn Address 1 enable\n0 : B_0x0 = Own address 1 disabled. The received slave address OA1 is NACKed.\n1 : B_0x1 = Own address 1 enabled. The received slave address OA1 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_OAR1 ) </loc>
//      <o.15..15> OA1EN
//        <0=> 0: B_0x0 = Own address 1 disabled. The received slave address OA1 is NACKed.
//        <1=> 1: B_0x1 = Own address 1 enabled. The received slave address OA1 is ACKed.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_OAR1  ---------------------------------
// SVD Line: 7805

//  <rtree> SFDITEM_REG__I2C1_I2C_OAR1
//    <name> I2C_OAR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005408) Own address register 1 </i>
//    <loc> ( (unsigned int)((I2C1_I2C_OAR1 >> 0) & 0xFFFFFFFF), ((I2C1_I2C_OAR1 = (I2C1_I2C_OAR1 & ~(0x87FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x87FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1 </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1MODE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR1_OA1EN </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C1_I2C_OAR2  ------------------------------
// SVD Line: 7865

unsigned int I2C1_I2C_OAR2 __AT (0x4000540C);



// ------------------------------  Field Item: I2C1_I2C_OAR2_OA2  ---------------------------------
// SVD Line: 7874

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2
//    <name> OA2 </name>
//    <rw> 
//    <i> [Bits 7..1] RW (@ 0x4000540C) Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN=0. </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_OAR2 >> 1) & 0x7F), ((I2C1_I2C_OAR2 = (I2C1_I2C_OAR2 & ~(0x7FUL << 1 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7F) << 1 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_OAR2_OA2MSK  --------------------------------
// SVD Line: 7883

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2MSK
//    <name> OA2MSK </name>
//    <rw> 
//    <i> [Bits 10..8] RW (@ 0x4000540C) \nOwn Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.\n0 : B_0x0 = No mask\n1 : B_0x1 = OA2[1] is masked and dont care. Only OA2[7:2] are compared.\n2 : B_0x2 = OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.\n3 : B_0x3 = OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.\n4 : B_0x4 = OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.\n5 : B_0x5 = OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.\n6 : B_0x6 = OA2[6:1] are masked and dont care. Only OA2[7] is compared.\n7 : B_0x7 = OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_OAR2 ) </loc>
//      <o.10..8> OA2MSK
//        <0=> 0: B_0x0 = No mask
//        <1=> 1: B_0x1 = OA2[1] is masked and dont care. Only OA2[7:2] are compared.
//        <2=> 2: B_0x2 = OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.
//        <3=> 3: B_0x3 = OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.
//        <4=> 4: B_0x4 = OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.
//        <5=> 5: B_0x5 = OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.
//        <6=> 6: B_0x6 = OA2[6:1] are masked and dont care. Only OA2[7] is compared.
//        <7=> 7: B_0x7 = OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_OAR2_OA2EN  --------------------------------
// SVD Line: 7934

//  <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2EN
//    <name> OA2EN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x4000540C) \nOwn Address 2 enable\n0 : B_0x0 = Own address 2 disabled. The received slave address OA2 is NACKed.\n1 : B_0x1 = Own address 2 enabled. The received slave address OA2 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_OAR2 ) </loc>
//      <o.15..15> OA2EN
//        <0=> 0: B_0x0 = Own address 2 disabled. The received slave address OA2 is NACKed.
//        <1=> 1: B_0x1 = Own address 2 enabled. The received slave address OA2 is ACKed.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_OAR2  ---------------------------------
// SVD Line: 7865

//  <rtree> SFDITEM_REG__I2C1_I2C_OAR2
//    <name> I2C_OAR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000540C) Own address register 2 </i>
//    <loc> ( (unsigned int)((I2C1_I2C_OAR2 >> 0) & 0xFFFFFFFF), ((I2C1_I2C_OAR2 = (I2C1_I2C_OAR2 & ~(0x87FEUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x87FE) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2 </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2MSK </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_OAR2_OA2EN </item>
//  </rtree>
//  


// -------------------------  Register Item Address: I2C1_I2C_TIMINGR  ----------------------------
// SVD Line: 7955

unsigned int I2C1_I2C_TIMINGR __AT (0x40005410);



// ----------------------------  Field Item: I2C1_I2C_TIMINGR_SCLL  -------------------------------
// SVD Line: 7964

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLL
//    <name> SCLL </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40005410) SCL low period (master  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TIMINGR >> 0) & 0xFF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_TIMINGR_SCLH  -------------------------------
// SVD Line: 7971

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLH
//    <name> SCLH </name>
//    <rw> 
//    <i> [Bits 15..8] RW (@ 0x40005410) SCL high period (master  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TIMINGR >> 8) & 0xFF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xFFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C1_I2C_TIMINGR_SDADEL  ------------------------------
// SVD Line: 7978

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SDADEL
//    <name> SDADEL </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40005410) Data hold time </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TIMINGR >> 16) & 0xF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C1_I2C_TIMINGR_SCLDEL  ------------------------------
// SVD Line: 7984

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLDEL
//    <name> SCLDEL </name>
//    <rw> 
//    <i> [Bits 23..20] RW (@ 0x40005410) Data setup time </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TIMINGR >> 20) & 0xF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xFUL << 20 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 20 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C1_I2C_TIMINGR_PRESC  -------------------------------
// SVD Line: 7990

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 31..28] RW (@ 0x40005410) Timing prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TIMINGR >> 28) & 0xF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xFUL << 28 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 28 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: I2C1_I2C_TIMINGR  --------------------------------
// SVD Line: 7955

//  <rtree> SFDITEM_REG__I2C1_I2C_TIMINGR
//    <name> I2C_TIMINGR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005410) Timing register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_TIMINGR >> 0) & 0xFFFFFFFF), ((I2C1_I2C_TIMINGR = (I2C1_I2C_TIMINGR & ~(0xF0FFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0FFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLL </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLH </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SDADEL </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_SCLDEL </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMINGR_PRESC </item>
//  </rtree>
//  


// ------------------------  Register Item Address: I2C1_I2C_TIMEOUTR  ----------------------------
// SVD Line: 7998

unsigned int I2C1_I2C_TIMEOUTR __AT (0x40005414);



// -------------------------  Field Item: I2C1_I2C_TIMEOUTR_TIMEOUTA  -----------------------------
// SVD Line: 8007

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMEOUTA
//    <name> TIMEOUTA </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40005414) Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C1_I2C_TIMEOUTR >> 0) & 0xFFF), ((I2C1_I2C_TIMEOUTR = (I2C1_I2C_TIMEOUTR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C1_I2C_TIMEOUTR_TIDLE  ------------------------------
// SVD Line: 8020

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIDLE
//    <name> TIDLE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005414) \nIdle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.\n0 : B_0x0 = TIMEOUTA is used to detect SCL low timeout\n1 : B_0x1 = TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition) </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_TIMEOUTR ) </loc>
//      <o.12..12> TIDLE
//        <0=> 0: B_0x0 = TIMEOUTA is used to detect SCL low timeout
//        <1=> 1: B_0x1 = TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
//    </combo>
//  </item>
//  


// -------------------------  Field Item: I2C1_I2C_TIMEOUTR_TIMOUTEN  -----------------------------
// SVD Line: 8040

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMOUTEN
//    <name> TIMOUTEN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005414) \nClock timeout enable\n0 : B_0x0 = SCL timeout detection is disabled\n1 : B_0x1 = SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_TIMEOUTR ) </loc>
//      <o.15..15> TIMOUTEN
//        <0=> 0: B_0x0 = SCL timeout detection is disabled
//        <1=> 1: B_0x1 = SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1).
//    </combo>
//  </item>
//  


// -------------------------  Field Item: I2C1_I2C_TIMEOUTR_TIMEOUTB  -----------------------------
// SVD Line: 8059

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMEOUTB
//    <name> TIMEOUTB </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x40005414) Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C1_I2C_TIMEOUTR >> 16) & 0xFFF), ((I2C1_I2C_TIMEOUTR = (I2C1_I2C_TIMEOUTR & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------  Field Item: I2C1_I2C_TIMEOUTR_TEXTEN  ------------------------------
// SVD Line: 8071

//  <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TEXTEN
//    <name> TEXTEN </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40005414) \nExtended clock timeout enable\n0 : B_0x0 = Extended clock timeout detection is disabled\n1 : B_0x1 = Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_TIMEOUTR ) </loc>
//      <o.31..31> TEXTEN
//        <0=> 0: B_0x0 = Extended clock timeout detection is disabled
//        <1=> 1: B_0x1 = Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1).
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: I2C1_I2C_TIMEOUTR  -------------------------------
// SVD Line: 7998

//  <rtree> SFDITEM_REG__I2C1_I2C_TIMEOUTR
//    <name> I2C_TIMEOUTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005414) Status register 1 </i>
//    <loc> ( (unsigned int)((I2C1_I2C_TIMEOUTR >> 0) & 0xFFFFFFFF), ((I2C1_I2C_TIMEOUTR = (I2C1_I2C_TIMEOUTR & ~(0x8FFF9FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x8FFF9FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMEOUTA </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIDLE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMOUTEN </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TIMEOUTB </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_TIMEOUTR_TEXTEN </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C1_I2C_ISR  ------------------------------
// SVD Line: 8092

unsigned int I2C1_I2C_ISR __AT (0x40005418);



// ----------------------------  Field Item: I2C1_I2C_ISR_ADDCODE  --------------------------------
// SVD Line: 8100

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_ADDCODE
//    <name> ADDCODE </name>
//    <r> 
//    <i> [Bits 23..17] RO (@ 0x40005418) Address match code (Slave  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_ISR >> 17) & 0x7F) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_DIR  ----------------------------------
// SVD Line: 8108

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_DIR
//    <name> DIR </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x40005418) \nTransfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).\n0 : B_0x0 = Write transfer, slave enters receiver mode.\n1 : B_0x1 = Read transfer, slave enters transmitter mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.16..16> DIR
//        <0=> 0: B_0x0 = Write transfer, slave enters receiver mode.
//        <1=> 1: B_0x1 = Read transfer, slave enters transmitter mode.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_BUSY  ---------------------------------
// SVD Line: 8128

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x40005418) Bus busy </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.15..15> BUSY
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ISR_ALERT  ---------------------------------
// SVD Line: 8135

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_ALERT
//    <name> ALERT </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x40005418) SMBus alert </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.13..13> ALERT
//    </check>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_ISR_TIMEOUT  --------------------------------
// SVD Line: 8142

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_TIMEOUT
//    <name> TIMEOUT </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x40005418) Timeout or t_low detection  flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.12..12> TIMEOUT
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ISR_PECERR  --------------------------------
// SVD Line: 8150

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_PECERR
//    <name> PECERR </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x40005418) PEC Error in reception </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.11..11> PECERR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_OVR  ----------------------------------
// SVD Line: 8157

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_OVR
//    <name> OVR </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x40005418) Overrun/Underrun (slave  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.10..10> OVR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_ARLO  ---------------------------------
// SVD Line: 8165

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_ARLO
//    <name> ARLO </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x40005418) Arbitration lost </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.9..9> ARLO
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_BERR  ---------------------------------
// SVD Line: 8172

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_BERR
//    <name> BERR </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x40005418) Bus error </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.8..8> BERR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_TCR  ----------------------------------
// SVD Line: 8179

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_TCR
//    <name> TCR </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x40005418) Transfer Complete Reload </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.7..7> TCR
//    </check>
//  </item>
//  


// -------------------------------  Field Item: I2C1_I2C_ISR_TC  ----------------------------------
// SVD Line: 8186

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x40005418) Transfer Complete (master  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.6..6> TC
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ISR_STOPF  ---------------------------------
// SVD Line: 8194

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_STOPF
//    <name> STOPF </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x40005418) Stop detection flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.5..5> STOPF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ISR_NACKF  ---------------------------------
// SVD Line: 8201

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_NACKF
//    <name> NACKF </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x40005418) Not acknowledge received  flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.4..4> NACKF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_ADDR  ---------------------------------
// SVD Line: 8209

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_ADDR
//    <name> ADDR </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40005418) Address matched (slave  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.3..3> ADDR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_RXNE  ---------------------------------
// SVD Line: 8217

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_RXNE
//    <name> RXNE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40005418) Receive data register not empty  (receivers) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.2..2> RXNE
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_TXIS  ---------------------------------
// SVD Line: 8225

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_TXIS
//    <name> TXIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40005418) Transmit interrupt status  (transmitters) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.1..1> TXIS
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C1_I2C_ISR_TXE  ----------------------------------
// SVD Line: 8233

//  <item> SFDITEM_FIELD__I2C1_I2C_ISR_TXE
//    <name> TXE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40005418) Transmit data register empty  (transmitters) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ISR ) </loc>
//      <o.0..0> TXE
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_ISR  ----------------------------------
// SVD Line: 8092

//  <rtree> SFDITEM_REG__I2C1_I2C_ISR
//    <name> I2C_ISR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005418) Interrupt and Status register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_ISR >> 0) & 0xFFFFFFFF), ((I2C1_I2C_ISR = (I2C1_I2C_ISR & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_ADDCODE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_DIR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_BUSY </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_ALERT </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_TIMEOUT </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_PECERR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_OVR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_ARLO </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_BERR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_TCR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_TC </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_STOPF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_NACKF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_ADDR </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_RXNE </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_TXIS </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ISR_TXE </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C1_I2C_ICR  ------------------------------
// SVD Line: 8243

unsigned int I2C1_I2C_ICR __AT (0x4000541C);



// ----------------------------  Field Item: I2C1_I2C_ICR_ALERTCF  --------------------------------
// SVD Line: 8252

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_ALERTCF
//    <name> ALERTCF </name>
//    <w> 
//    <i> [Bit 13] WO (@ 0x4000541C) Alert flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.13..13> ALERTCF
//    </check>
//  </item>
//  


// ----------------------------  Field Item: I2C1_I2C_ICR_TIMOUTCF  -------------------------------
// SVD Line: 8258

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_TIMOUTCF
//    <name> TIMOUTCF </name>
//    <w> 
//    <i> [Bit 12] WO (@ 0x4000541C) Timeout detection flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.12..12> TIMOUTCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_PECCF  ---------------------------------
// SVD Line: 8265

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_PECCF
//    <name> PECCF </name>
//    <w> 
//    <i> [Bit 11] WO (@ 0x4000541C) PEC Error flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.11..11> PECCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_OVRCF  ---------------------------------
// SVD Line: 8271

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_OVRCF
//    <name> OVRCF </name>
//    <w> 
//    <i> [Bit 10] WO (@ 0x4000541C) Overrun/Underrun flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.10..10> OVRCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_ARLOCF  --------------------------------
// SVD Line: 8278

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_ARLOCF
//    <name> ARLOCF </name>
//    <w> 
//    <i> [Bit 9] WO (@ 0x4000541C) Arbitration lost flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.9..9> ARLOCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_BERRCF  --------------------------------
// SVD Line: 8285

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_BERRCF
//    <name> BERRCF </name>
//    <w> 
//    <i> [Bit 8] WO (@ 0x4000541C) Bus error flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.8..8> BERRCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_STOPCF  --------------------------------
// SVD Line: 8291

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_STOPCF
//    <name> STOPCF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x4000541C) Stop detection flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.5..5> STOPCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_NACKCF  --------------------------------
// SVD Line: 8297

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_NACKCF
//    <name> NACKCF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x4000541C) Not Acknowledge flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.4..4> NACKCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C1_I2C_ICR_ADDRCF  --------------------------------
// SVD Line: 8303

//  <item> SFDITEM_FIELD__I2C1_I2C_ICR_ADDRCF
//    <name> ADDRCF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x4000541C) Address Matched flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C1_I2C_ICR ) </loc>
//      <o.3..3> ADDRCF
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_ICR  ----------------------------------
// SVD Line: 8243

//  <rtree> SFDITEM_REG__I2C1_I2C_ICR
//    <name> I2C_ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x4000541C) Interrupt clear register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_ICR >> 0) & 0xFFFFFFFF), ((I2C1_I2C_ICR = (I2C1_I2C_ICR & ~(0x3F38UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3F38) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_ALERTCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_TIMOUTCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_PECCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_OVRCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_ARLOCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_BERRCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_STOPCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_NACKCF </item>
//    <item> SFDITEM_FIELD__I2C1_I2C_ICR_ADDRCF </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C1_I2C_PECR  ------------------------------
// SVD Line: 8311

unsigned int I2C1_I2C_PECR __AT (0x40005420);



// ------------------------------  Field Item: I2C1_I2C_PECR_PEC  ---------------------------------
// SVD Line: 8320

//  <item> SFDITEM_FIELD__I2C1_I2C_PECR_PEC
//    <name> PEC </name>
//    <r> 
//    <i> [Bits 7..0] RO (@ 0x40005420) Packet error checking  register </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_PECR >> 0) & 0xFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_PECR  ---------------------------------
// SVD Line: 8311

//  <rtree> SFDITEM_REG__I2C1_I2C_PECR
//    <name> I2C_PECR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40005420) PEC register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_PECR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_PECR_PEC </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C1_I2C_RXDR  ------------------------------
// SVD Line: 8329

unsigned int I2C1_I2C_RXDR __AT (0x40005424);



// ----------------------------  Field Item: I2C1_I2C_RXDR_RXDATA  --------------------------------
// SVD Line: 8338

//  <item> SFDITEM_FIELD__I2C1_I2C_RXDR_RXDATA
//    <name> RXDATA </name>
//    <r> 
//    <i> [Bits 7..0] RO (@ 0x40005424) 8-bit receive data </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_RXDR >> 0) & 0xFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_RXDR  ---------------------------------
// SVD Line: 8329

//  <rtree> SFDITEM_REG__I2C1_I2C_RXDR
//    <name> I2C_RXDR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40005424) Receive data register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_RXDR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_RXDR_RXDATA </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C1_I2C_TXDR  ------------------------------
// SVD Line: 8346

unsigned int I2C1_I2C_TXDR __AT (0x40005428);



// ----------------------------  Field Item: I2C1_I2C_TXDR_TXDATA  --------------------------------
// SVD Line: 8355

//  <item> SFDITEM_FIELD__I2C1_I2C_TXDR_TXDATA
//    <name> TXDATA </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40005428) 8-bit transmit data </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C1_I2C_TXDR >> 0) & 0xFF), ((I2C1_I2C_TXDR = (I2C1_I2C_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C1_I2C_TXDR  ---------------------------------
// SVD Line: 8346

//  <rtree> SFDITEM_REG__I2C1_I2C_TXDR
//    <name> I2C_TXDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005428) Transmit data register </i>
//    <loc> ( (unsigned int)((I2C1_I2C_TXDR >> 0) & 0xFFFFFFFF), ((I2C1_I2C_TXDR = (I2C1_I2C_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C1_I2C_TXDR_TXDATA </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: I2C1  -------------------------------------
// SVD Line: 7139

//  <view> I2C1
//    <name> I2C1 </name>
//    <item> SFDITEM_REG__I2C1_I2C_CR1 </item>
//    <item> SFDITEM_REG__I2C1_I2C_CR2 </item>
//    <item> SFDITEM_REG__I2C1_I2C_OAR1 </item>
//    <item> SFDITEM_REG__I2C1_I2C_OAR2 </item>
//    <item> SFDITEM_REG__I2C1_I2C_TIMINGR </item>
//    <item> SFDITEM_REG__I2C1_I2C_TIMEOUTR </item>
//    <item> SFDITEM_REG__I2C1_I2C_ISR </item>
//    <item> SFDITEM_REG__I2C1_I2C_ICR </item>
//    <item> SFDITEM_REG__I2C1_I2C_PECR </item>
//    <item> SFDITEM_REG__I2C1_I2C_RXDR </item>
//    <item> SFDITEM_REG__I2C1_I2C_TXDR </item>
//  </view>
//  


// ---------------------------  Register Item Address: I2C2_I2C_CR1  ------------------------------
// SVD Line: 7155

unsigned int I2C2_I2C_CR1 __AT (0x40005800);



// -------------------------------  Field Item: I2C2_I2C_CR1_PE  ----------------------------------
// SVD Line: 7164

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_PE
//    <name> PE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40005800) \nPeripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.\n0 : B_0x0 = Peripheral disable\n1 : B_0x1 = Peripheral enable </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = Peripheral disable
//        <1=> 1: B_0x1 = Peripheral enable
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_TXIE  ---------------------------------
// SVD Line: 7184

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_TXIE
//    <name> TXIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40005800) \nTX Interrupt enable\n0 : B_0x0 = Transmit (TXIS) interrupt disabled\n1 : B_0x1 = Transmit (TXIS) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.1..1> TXIE
//        <0=> 0: B_0x0 = Transmit (TXIS) interrupt disabled
//        <1=> 1: B_0x1 = Transmit (TXIS) interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_RXIE  ---------------------------------
// SVD Line: 7203

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_RXIE
//    <name> RXIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40005800) \nRX Interrupt enable\n0 : B_0x0 = Receive (RXNE) interrupt disabled\n1 : B_0x1 = Receive (RXNE) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.2..2> RXIE
//        <0=> 0: B_0x0 = Receive (RXNE) interrupt disabled
//        <1=> 1: B_0x1 = Receive (RXNE) interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_ADDRIE  --------------------------------
// SVD Line: 7222

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_ADDRIE
//    <name> ADDRIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40005800) \nAddress match Interrupt enable (slave only)\n0 : B_0x0 = Address match (ADDR) interrupts disabled\n1 : B_0x1 = Address match (ADDR) interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.3..3> ADDRIE
//        <0=> 0: B_0x0 = Address match (ADDR) interrupts disabled
//        <1=> 1: B_0x1 = Address match (ADDR) interrupts enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_NACKIE  --------------------------------
// SVD Line: 7241

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_NACKIE
//    <name> NACKIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40005800) \nNot acknowledge received Interrupt enable\n0 : B_0x0 = Not acknowledge (NACKF) received interrupts disabled\n1 : B_0x1 = Not acknowledge (NACKF) received interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.4..4> NACKIE
//        <0=> 0: B_0x0 = Not acknowledge (NACKF) received interrupts disabled
//        <1=> 1: B_0x1 = Not acknowledge (NACKF) received interrupts enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_STOPIE  --------------------------------
// SVD Line: 7260

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_STOPIE
//    <name> STOPIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40005800) \nStop detection Interrupt enable\n0 : B_0x0 = Stop detection (STOPF) interrupt disabled\n1 : B_0x1 = Stop detection (STOPF) interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.5..5> STOPIE
//        <0=> 0: B_0x0 = Stop detection (STOPF) interrupt disabled
//        <1=> 1: B_0x1 = Stop detection (STOPF) interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_TCIE  ---------------------------------
// SVD Line: 7279

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40005800) \nTransfer Complete interrupt enable Note: Any of these events generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)\n0 : B_0x0 = Transfer Complete interrupt disabled\n1 : B_0x1 = Transfer Complete interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Transfer Complete interrupt disabled
//        <1=> 1: B_0x1 = Transfer Complete interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_ERRIE  ---------------------------------
// SVD Line: 7301

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_ERRIE
//    <name> ERRIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40005800) \nError interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)\n0 : B_0x0 = Error detection interrupts disabled\n1 : B_0x1 = Error detection interrupts enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.7..7> ERRIE
//        <0=> 0: B_0x0 = Error detection interrupts disabled
//        <1=> 1: B_0x1 = Error detection interrupts enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_DNF  ----------------------------------
// SVD Line: 7327

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_DNF
//    <name> DNF </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40005800) \nDigital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Digital filter disabled\n1 : B_0x1 = Digital filter enabled and filtering capability up to 1 tI2CCLK\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : B_0xF = digital filter enabled and filtering capability up to15 tI2CCLK </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.11..8> DNF
//        <0=> 0: B_0x0 = Digital filter disabled
//        <1=> 1: B_0x1 = Digital filter enabled and filtering capability up to 1 tI2CCLK
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: B_0xF = digital filter enabled and filtering capability up to15 tI2CCLK
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_ANFOFF  --------------------------------
// SVD Line: 7355

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_ANFOFF
//    <name> ANFOFF </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005800) \nAnalog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Analog noise filter enabled\n1 : B_0x1 = Analog noise filter disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.12..12> ANFOFF
//        <0=> 0: B_0x0 = Analog noise filter enabled
//        <1=> 1: B_0x1 = Analog noise filter disabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR1_TXDMAEN  --------------------------------
// SVD Line: 7375

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_TXDMAEN
//    <name> TXDMAEN </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40005800) \nDMA transmission requests enable\n0 : B_0x0 = DMA mode disabled for transmission\n1 : B_0x1 = DMA mode enabled for transmission </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.14..14> TXDMAEN
//        <0=> 0: B_0x0 = DMA mode disabled for transmission
//        <1=> 1: B_0x1 = DMA mode enabled for transmission
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR1_RXDMAEN  --------------------------------
// SVD Line: 7394

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_RXDMAEN
//    <name> RXDMAEN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005800) \nDMA reception requests enable\n0 : B_0x0 = DMA mode disabled for reception\n1 : B_0x1 = DMA mode enabled for reception </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.15..15> RXDMAEN
//        <0=> 0: B_0x0 = DMA mode disabled for reception
//        <1=> 1: B_0x1 = DMA mode enabled for reception
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_SBC  ----------------------------------
// SVD Line: 7413

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_SBC
//    <name> SBC </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40005800) \nSlave byte control This bit is used to enable hardware byte control in slave mode.\n0 : B_0x0 = Slave byte control disabled\n1 : B_0x1 = Slave byte control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.16..16> SBC
//        <0=> 0: B_0x0 = Slave byte control disabled
//        <1=> 1: B_0x1 = Slave byte control enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: I2C2_I2C_CR1_NOSTRETCH  -------------------------------
// SVD Line: 7433

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_NOSTRETCH
//    <name> NOSTRETCH </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40005800) \nClock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).\n0 : B_0x0 = Clock stretching enabled\n1 : B_0x1 = Clock stretching disabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.17..17> NOSTRETCH
//        <0=> 0: B_0x0 = Clock stretching enabled
//        <1=> 1: B_0x1 = Clock stretching disabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_WUPEN  ---------------------------------
// SVD Line: 7454

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_WUPEN
//    <name> WUPEN </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40005800) \nWakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0. Refer to . Note: WUPEN can be set only when DNF = '0000\n0 : B_0x0 = Wakeup from Stop mode disable.\n1 : B_0x1 = Wakeup from Stop mode enable. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.18..18> WUPEN
//        <0=> 0: B_0x0 = Wakeup from Stop mode disable.
//        <1=> 1: B_0x1 = Wakeup from Stop mode enable.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR1_GCEN  ---------------------------------
// SVD Line: 7475

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_GCEN
//    <name> GCEN </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40005800) \nGeneral call enable\n0 : B_0x0 = General call disabled. Address 0b00000000 is NACKed.\n1 : B_0x1 = General call enabled. Address 0b00000000 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.19..19> GCEN
//        <0=> 0: B_0x0 = General call disabled. Address 0b00000000 is NACKed.
//        <1=> 1: B_0x1 = General call enabled. Address 0b00000000 is ACKed.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_SMBHEN  --------------------------------
// SVD Line: 7494

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_SMBHEN
//    <name> SMBHEN </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40005800) \nSMBus Host Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = Host Address disabled. Address 0b0001000x is NACKed.\n1 : B_0x1 = Host Address enabled. Address 0b0001000x is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.20..20> SMBHEN
//        <0=> 0: B_0x0 = Host Address disabled. Address 0b0001000x is NACKed.
//        <1=> 1: B_0x1 = Host Address enabled. Address 0b0001000x is ACKed.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_SMBDEN  --------------------------------
// SVD Line: 7514

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_SMBDEN
//    <name> SMBDEN </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x40005800) \nSMBus Device Default Address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = Device Default Address disabled. Address 0b1100001x is NACKed.\n1 : B_0x1 = Device Default Address enabled. Address 0b1100001x is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.21..21> SMBDEN
//        <0=> 0: B_0x0 = Device Default Address disabled. Address 0b1100001x is NACKed.
//        <1=> 1: B_0x1 = Device Default Address enabled. Address 0b1100001x is ACKed.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR1_ALERTEN  --------------------------------
// SVD Line: 7534

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_ALERTEN
//    <name> ALERTEN </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40005800) \nSMBus alert enable Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).\n1 : B_0x1 = The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.22..22> ALERTEN
//        <0=> 0: B_0x0 = The SMBus alert pin (SMBA) is not supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is released and the Alert Response Address header is disabled (0001100x followed by NACK).
//        <1=> 1: B_0x1 = The SMBus alert pin is supported in host mode (SMBHEN=1). In device mode (SMBHEN=0), the SMBA pin is driven low and the Alert Response Address header is enabled (0001100x followed by ACK).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR1_PECEN  ---------------------------------
// SVD Line: 7555

//  <item> SFDITEM_FIELD__I2C2_I2C_CR1_PECEN
//    <name> PECEN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40005800) \nPEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = PEC calculation disabled\n1 : B_0x1 = PEC calculation enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR1 ) </loc>
//      <o.23..23> PECEN
//        <0=> 0: B_0x0 = PEC calculation disabled
//        <1=> 1: B_0x1 = PEC calculation enabled
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_CR1  ----------------------------------
// SVD Line: 7155

//  <rtree> SFDITEM_REG__I2C2_I2C_CR1
//    <name> I2C_CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005800) Control register 1 </i>
//    <loc> ( (unsigned int)((I2C2_I2C_CR1 >> 0) & 0xFFFFFFFF), ((I2C2_I2C_CR1 = (I2C2_I2C_CR1 & ~(0xFFDFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFDFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_PE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_TXIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_RXIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_ADDRIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_NACKIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_STOPIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_TCIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_ERRIE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_DNF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_ANFOFF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_TXDMAEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_RXDMAEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_SBC </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_NOSTRETCH </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_WUPEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_GCEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_SMBHEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_SMBDEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_ALERTEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR1_PECEN </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C2_I2C_CR2  ------------------------------
// SVD Line: 7577

unsigned int I2C2_I2C_CR2 __AT (0x40005804);



// ------------------------------  Field Item: I2C2_I2C_CR2_SADD  ---------------------------------
// SVD Line: 7586

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_SADD
//    <name> SADD </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40005804) Slave address (master mode) In 7-bit addressing mode (ADD10 = 0): SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care. In 10-bit addressing mode (ADD10 = 1): SADD[9:0] should be written with the 10-bit slave address to be sent. Note: Changing these bits when the START bit is set is not allowed. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C2_I2C_CR2 >> 0) & 0x3FF), ((I2C2_I2C_CR2 = (I2C2_I2C_CR2 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR2_RD_WRN  --------------------------------
// SVD Line: 7598

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_RD_WRN
//    <name> RD_WRN </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40005804) \nTransfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = Master requests a write transfer.\n1 : B_0x1 = Master requests a read transfer. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.10..10> RD_WRN
//        <0=> 0: B_0x0 = Master requests a write transfer.
//        <1=> 1: B_0x1 = Master requests a read transfer.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR2_ADD10  ---------------------------------
// SVD Line: 7618

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_ADD10
//    <name> ADD10 </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40005804) \n10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = The master operates in 7-bit addressing mode,\n1 : B_0x1 = The master operates in 10-bit addressing mode </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.11..11> ADD10
//        <0=> 0: B_0x0 = The master operates in 7-bit addressing mode,
//        <1=> 1: B_0x1 = The master operates in 10-bit addressing mode
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR2_HEAD10R  --------------------------------
// SVD Line: 7638

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_HEAD10R
//    <name> HEAD10R </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005804) \n10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.\n0 : B_0x0 = The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.\n1 : B_0x1 = The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.12..12> HEAD10R
//        <0=> 0: B_0x0 = The master sends the complete 10 bit slave address read sequence: Start + 2 bytes 10bit address in write direction + Restart + 1st 7 bits of the 10 bit address in read direction.
//        <1=> 1: B_0x1 = The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR2_START  ---------------------------------
// SVD Line: 7658

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_START
//    <name> START </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40005804) \nStart generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit generates a START condition once the bus is free. Note: Writing '0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.\n0 : B_0x0 = No Start generation.\n1 : B_0x1 = Restart/Start generation: </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.13..13> START
//        <0=> 0: B_0x0 = No Start generation.
//        <1=> 1: B_0x1 = Restart/Start generation:
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR2_STOP  ---------------------------------
// SVD Line: 7683

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_STOP
//    <name> STOP </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40005804) \nStop generation (master mode) The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0. In Master Mode: Note: Writing '0 to this bit has no effect.\n0 : B_0x0 = No Stop generation.\n1 : B_0x1 = Stop generation after current byte transfer. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.14..14> STOP
//        <0=> 0: B_0x0 = No Stop generation.
//        <1=> 1: B_0x1 = Stop generation after current byte transfer.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_CR2_NACK  ---------------------------------
// SVD Line: 7705

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_NACK
//    <name> NACK </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005804) \nNACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing '0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.\n0 : B_0x0 = an ACK is sent after current received byte.\n1 : B_0x1 = a NACK is sent after current received byte. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.15..15> NACK
//        <0=> 0: B_0x0 = an ACK is sent after current received byte.
//        <1=> 1: B_0x1 = a NACK is sent after current received byte.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR2_NBYTES  --------------------------------
// SVD Line: 7729

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_NBYTES
//    <name> NBYTES </name>
//    <rw> 
//    <i> [Bits 23..16] RW (@ 0x40005804) Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_CR2 >> 16) & 0xFF), ((I2C2_I2C_CR2 = (I2C2_I2C_CR2 & ~(0xFFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_CR2_RELOAD  --------------------------------
// SVD Line: 7738

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_RELOAD
//    <name> RELOAD </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40005804) \nNBYTES reload mode This bit is set and cleared by software.\n0 : B_0x0 = The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).\n1 : B_0x1 = The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.24..24> RELOAD
//        <0=> 0: B_0x0 = The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).
//        <1=> 1: B_0x1 = The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR flag is set when NBYTES data are transferred, stretching SCL low.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR2_AUTOEND  --------------------------------
// SVD Line: 7758

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_AUTOEND
//    <name> AUTOEND </name>
//    <rw> 
//    <i> [Bit 25] RW (@ 0x40005804) \nAutomatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.\n0 : B_0x0 = software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.\n1 : B_0x1 = Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.25..25> AUTOEND
//        <0=> 0: B_0x0 = software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.
//        <1=> 1: B_0x1 = Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_CR2_PECBYTE  --------------------------------
// SVD Line: 7779

//  <item> SFDITEM_FIELD__I2C2_I2C_CR2_PECBYTE
//    <name> PECBYTE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40005804) \nPacket error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing '0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0. Refer to .\n0 : B_0x0 = No PEC transfer.\n1 : B_0x1 = PEC transmission/reception is requested </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_CR2 ) </loc>
//      <o.26..26> PECBYTE
//        <0=> 0: B_0x0 = No PEC transfer.
//        <1=> 1: B_0x1 = PEC transmission/reception is requested
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_CR2  ----------------------------------
// SVD Line: 7577

//  <rtree> SFDITEM_REG__I2C2_I2C_CR2
//    <name> I2C_CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005804) Control register 2 </i>
//    <loc> ( (unsigned int)((I2C2_I2C_CR2 >> 0) & 0xFFFFFFFF), ((I2C2_I2C_CR2 = (I2C2_I2C_CR2 & ~(0x7FFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_SADD </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_RD_WRN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_ADD10 </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_HEAD10R </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_START </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_STOP </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_NACK </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_NBYTES </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_RELOAD </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_AUTOEND </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_CR2_PECBYTE </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C2_I2C_OAR1  ------------------------------
// SVD Line: 7805

unsigned int I2C2_I2C_OAR1 __AT (0x40005808);



// ------------------------------  Field Item: I2C2_I2C_OAR1_OA1  ---------------------------------
// SVD Line: 7814

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1
//    <name> OA1 </name>
//    <rw> 
//    <i> [Bits 9..0] RW (@ 0x40005808) Interface own slave address 7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care. 10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address. Note: These bits can be written only when OA1EN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C2_I2C_OAR1 >> 0) & 0x3FF), ((I2C2_I2C_OAR1 = (I2C2_I2C_OAR1 & ~(0x3FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x3FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_OAR1_OA1MODE  -------------------------------
// SVD Line: 7824

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1MODE
//    <name> OA1MODE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40005808) \nOwn Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.\n0 : B_0x0 = Own address 1 is a 7-bit address.\n1 : B_0x1 = Own address 1 is a 10-bit address. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_OAR1 ) </loc>
//      <o.10..10> OA1MODE
//        <0=> 0: B_0x0 = Own address 1 is a 7-bit address.
//        <1=> 1: B_0x1 = Own address 1 is a 10-bit address.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_OAR1_OA1EN  --------------------------------
// SVD Line: 7844

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1EN
//    <name> OA1EN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005808) \nOwn Address 1 enable\n0 : B_0x0 = Own address 1 disabled. The received slave address OA1 is NACKed.\n1 : B_0x1 = Own address 1 enabled. The received slave address OA1 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_OAR1 ) </loc>
//      <o.15..15> OA1EN
//        <0=> 0: B_0x0 = Own address 1 disabled. The received slave address OA1 is NACKed.
//        <1=> 1: B_0x1 = Own address 1 enabled. The received slave address OA1 is ACKed.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_OAR1  ---------------------------------
// SVD Line: 7805

//  <rtree> SFDITEM_REG__I2C2_I2C_OAR1
//    <name> I2C_OAR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005808) Own address register 1 </i>
//    <loc> ( (unsigned int)((I2C2_I2C_OAR1 >> 0) & 0xFFFFFFFF), ((I2C2_I2C_OAR1 = (I2C2_I2C_OAR1 & ~(0x87FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x87FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1 </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1MODE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR1_OA1EN </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C2_I2C_OAR2  ------------------------------
// SVD Line: 7865

unsigned int I2C2_I2C_OAR2 __AT (0x4000580C);



// ------------------------------  Field Item: I2C2_I2C_OAR2_OA2  ---------------------------------
// SVD Line: 7874

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2
//    <name> OA2 </name>
//    <rw> 
//    <i> [Bits 7..1] RW (@ 0x4000580C) Interface address 7-bit addressing mode: 7-bit address Note: These bits can be written only when OA2EN=0. </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_OAR2 >> 1) & 0x7F), ((I2C2_I2C_OAR2 = (I2C2_I2C_OAR2 & ~(0x7FUL << 1 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7F) << 1 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_OAR2_OA2MSK  --------------------------------
// SVD Line: 7883

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2MSK
//    <name> OA2MSK </name>
//    <rw> 
//    <i> [Bits 10..8] RW (@ 0x4000580C) \nOwn Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.\n0 : B_0x0 = No mask\n1 : B_0x1 = OA2[1] is masked and dont care. Only OA2[7:2] are compared.\n2 : B_0x2 = OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.\n3 : B_0x3 = OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.\n4 : B_0x4 = OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.\n5 : B_0x5 = OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.\n6 : B_0x6 = OA2[6:1] are masked and dont care. Only OA2[7] is compared.\n7 : B_0x7 = OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_OAR2 ) </loc>
//      <o.10..8> OA2MSK
//        <0=> 0: B_0x0 = No mask
//        <1=> 1: B_0x1 = OA2[1] is masked and dont care. Only OA2[7:2] are compared.
//        <2=> 2: B_0x2 = OA2[2:1] are masked and dont care. Only OA2[7:3] are compared.
//        <3=> 3: B_0x3 = OA2[3:1] are masked and dont care. Only OA2[7:4] are compared.
//        <4=> 4: B_0x4 = OA2[4:1] are masked and dont care. Only OA2[7:5] are compared.
//        <5=> 5: B_0x5 = OA2[5:1] are masked and dont care. Only OA2[7:6] are compared.
//        <6=> 6: B_0x6 = OA2[6:1] are masked and dont care. Only OA2[7] is compared.
//        <7=> 7: B_0x7 = OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_OAR2_OA2EN  --------------------------------
// SVD Line: 7934

//  <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2EN
//    <name> OA2EN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x4000580C) \nOwn Address 2 enable\n0 : B_0x0 = Own address 2 disabled. The received slave address OA2 is NACKed.\n1 : B_0x1 = Own address 2 enabled. The received slave address OA2 is ACKed. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_OAR2 ) </loc>
//      <o.15..15> OA2EN
//        <0=> 0: B_0x0 = Own address 2 disabled. The received slave address OA2 is NACKed.
//        <1=> 1: B_0x1 = Own address 2 enabled. The received slave address OA2 is ACKed.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_OAR2  ---------------------------------
// SVD Line: 7865

//  <rtree> SFDITEM_REG__I2C2_I2C_OAR2
//    <name> I2C_OAR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000580C) Own address register 2 </i>
//    <loc> ( (unsigned int)((I2C2_I2C_OAR2 >> 0) & 0xFFFFFFFF), ((I2C2_I2C_OAR2 = (I2C2_I2C_OAR2 & ~(0x87FEUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x87FE) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2 </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2MSK </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_OAR2_OA2EN </item>
//  </rtree>
//  


// -------------------------  Register Item Address: I2C2_I2C_TIMINGR  ----------------------------
// SVD Line: 7955

unsigned int I2C2_I2C_TIMINGR __AT (0x40005810);



// ----------------------------  Field Item: I2C2_I2C_TIMINGR_SCLL  -------------------------------
// SVD Line: 7964

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLL
//    <name> SCLL </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40005810) SCL low period (master  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TIMINGR >> 0) & 0xFF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_TIMINGR_SCLH  -------------------------------
// SVD Line: 7971

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLH
//    <name> SCLH </name>
//    <rw> 
//    <i> [Bits 15..8] RW (@ 0x40005810) SCL high period (master  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TIMINGR >> 8) & 0xFF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xFFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C2_I2C_TIMINGR_SDADEL  ------------------------------
// SVD Line: 7978

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SDADEL
//    <name> SDADEL </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40005810) Data hold time </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TIMINGR >> 16) & 0xF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xFUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C2_I2C_TIMINGR_SCLDEL  ------------------------------
// SVD Line: 7984

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLDEL
//    <name> SCLDEL </name>
//    <rw> 
//    <i> [Bits 23..20] RW (@ 0x40005810) Data setup time </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TIMINGR >> 20) & 0xF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xFUL << 20 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 20 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C2_I2C_TIMINGR_PRESC  -------------------------------
// SVD Line: 7990

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 31..28] RW (@ 0x40005810) Timing prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TIMINGR >> 28) & 0xF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xFUL << 28 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 28 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: I2C2_I2C_TIMINGR  --------------------------------
// SVD Line: 7955

//  <rtree> SFDITEM_REG__I2C2_I2C_TIMINGR
//    <name> I2C_TIMINGR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005810) Timing register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_TIMINGR >> 0) & 0xFFFFFFFF), ((I2C2_I2C_TIMINGR = (I2C2_I2C_TIMINGR & ~(0xF0FFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0FFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLL </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLH </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SDADEL </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_SCLDEL </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMINGR_PRESC </item>
//  </rtree>
//  


// ------------------------  Register Item Address: I2C2_I2C_TIMEOUTR  ----------------------------
// SVD Line: 7998

unsigned int I2C2_I2C_TIMEOUTR __AT (0x40005814);



// -------------------------  Field Item: I2C2_I2C_TIMEOUTR_TIMEOUTA  -----------------------------
// SVD Line: 8007

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMEOUTA
//    <name> TIMEOUTA </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40005814) Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C2_I2C_TIMEOUTR >> 0) & 0xFFF), ((I2C2_I2C_TIMEOUTR = (I2C2_I2C_TIMEOUTR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: I2C2_I2C_TIMEOUTR_TIDLE  ------------------------------
// SVD Line: 8020

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIDLE
//    <name> TIDLE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40005814) \nIdle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.\n0 : B_0x0 = TIMEOUTA is used to detect SCL low timeout\n1 : B_0x1 = TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition) </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_TIMEOUTR ) </loc>
//      <o.12..12> TIDLE
//        <0=> 0: B_0x0 = TIMEOUTA is used to detect SCL low timeout
//        <1=> 1: B_0x1 = TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
//    </combo>
//  </item>
//  


// -------------------------  Field Item: I2C2_I2C_TIMEOUTR_TIMOUTEN  -----------------------------
// SVD Line: 8040

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMOUTEN
//    <name> TIMOUTEN </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40005814) \nClock timeout enable\n0 : B_0x0 = SCL timeout detection is disabled\n1 : B_0x1 = SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_TIMEOUTR ) </loc>
//      <o.15..15> TIMOUTEN
//        <0=> 0: B_0x0 = SCL timeout detection is disabled
//        <1=> 1: B_0x1 = SCL timeout detection is enabled: when SCL is low for more than tTIMEOUT (TIDLE=0) or high for more than tIDLE (TIDLE=1), a timeout error is detected (TIMEOUT=1).
//    </combo>
//  </item>
//  


// -------------------------  Field Item: I2C2_I2C_TIMEOUTR_TIMEOUTB  -----------------------------
// SVD Line: 8059

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMEOUTB
//    <name> TIMEOUTB </name>
//    <rw> 
//    <i> [Bits 27..16] RW (@ 0x40005814) Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. </i>
//    <edit> 
//      <loc> ( (unsigned short)((I2C2_I2C_TIMEOUTR >> 16) & 0xFFF), ((I2C2_I2C_TIMEOUTR = (I2C2_I2C_TIMEOUTR & ~(0xFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------  Field Item: I2C2_I2C_TIMEOUTR_TEXTEN  ------------------------------
// SVD Line: 8071

//  <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TEXTEN
//    <name> TEXTEN </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40005814) \nExtended clock timeout enable\n0 : B_0x0 = Extended clock timeout detection is disabled\n1 : B_0x1 = Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1). </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_TIMEOUTR ) </loc>
//      <o.31..31> TEXTEN
//        <0=> 0: B_0x0 = Extended clock timeout detection is disabled
//        <1=> 1: B_0x1 = Extended clock timeout detection is enabled. When a cumulative SCL stretch for more than tLOW:EXT is done by the I2C interface, a timeout error is detected (TIMEOUT=1).
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: I2C2_I2C_TIMEOUTR  -------------------------------
// SVD Line: 7998

//  <rtree> SFDITEM_REG__I2C2_I2C_TIMEOUTR
//    <name> I2C_TIMEOUTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005814) Status register 1 </i>
//    <loc> ( (unsigned int)((I2C2_I2C_TIMEOUTR >> 0) & 0xFFFFFFFF), ((I2C2_I2C_TIMEOUTR = (I2C2_I2C_TIMEOUTR & ~(0x8FFF9FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x8FFF9FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMEOUTA </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIDLE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMOUTEN </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TIMEOUTB </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_TIMEOUTR_TEXTEN </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C2_I2C_ISR  ------------------------------
// SVD Line: 8092

unsigned int I2C2_I2C_ISR __AT (0x40005818);



// ----------------------------  Field Item: I2C2_I2C_ISR_ADDCODE  --------------------------------
// SVD Line: 8100

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_ADDCODE
//    <name> ADDCODE </name>
//    <r> 
//    <i> [Bits 23..17] RO (@ 0x40005818) Address match code (Slave  mode) </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_ISR >> 17) & 0x7F) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_DIR  ----------------------------------
// SVD Line: 8108

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_DIR
//    <name> DIR </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x40005818) \nTransfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).\n0 : B_0x0 = Write transfer, slave enters receiver mode.\n1 : B_0x1 = Read transfer, slave enters transmitter mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.16..16> DIR
//        <0=> 0: B_0x0 = Write transfer, slave enters receiver mode.
//        <1=> 1: B_0x1 = Read transfer, slave enters transmitter mode.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_BUSY  ---------------------------------
// SVD Line: 8128

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x40005818) Bus busy </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.15..15> BUSY
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ISR_ALERT  ---------------------------------
// SVD Line: 8135

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_ALERT
//    <name> ALERT </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x40005818) SMBus alert </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.13..13> ALERT
//    </check>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_ISR_TIMEOUT  --------------------------------
// SVD Line: 8142

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_TIMEOUT
//    <name> TIMEOUT </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x40005818) Timeout or t_low detection  flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.12..12> TIMEOUT
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ISR_PECERR  --------------------------------
// SVD Line: 8150

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_PECERR
//    <name> PECERR </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x40005818) PEC Error in reception </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.11..11> PECERR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_OVR  ----------------------------------
// SVD Line: 8157

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_OVR
//    <name> OVR </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x40005818) Overrun/Underrun (slave  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.10..10> OVR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_ARLO  ---------------------------------
// SVD Line: 8165

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_ARLO
//    <name> ARLO </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x40005818) Arbitration lost </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.9..9> ARLO
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_BERR  ---------------------------------
// SVD Line: 8172

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_BERR
//    <name> BERR </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x40005818) Bus error </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.8..8> BERR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_TCR  ----------------------------------
// SVD Line: 8179

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_TCR
//    <name> TCR </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x40005818) Transfer Complete Reload </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.7..7> TCR
//    </check>
//  </item>
//  


// -------------------------------  Field Item: I2C2_I2C_ISR_TC  ----------------------------------
// SVD Line: 8186

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x40005818) Transfer Complete (master  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.6..6> TC
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ISR_STOPF  ---------------------------------
// SVD Line: 8194

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_STOPF
//    <name> STOPF </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x40005818) Stop detection flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.5..5> STOPF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ISR_NACKF  ---------------------------------
// SVD Line: 8201

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_NACKF
//    <name> NACKF </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x40005818) Not acknowledge received  flag </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.4..4> NACKF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_ADDR  ---------------------------------
// SVD Line: 8209

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_ADDR
//    <name> ADDR </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40005818) Address matched (slave  mode) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.3..3> ADDR
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_RXNE  ---------------------------------
// SVD Line: 8217

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_RXNE
//    <name> RXNE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40005818) Receive data register not empty  (receivers) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.2..2> RXNE
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_TXIS  ---------------------------------
// SVD Line: 8225

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_TXIS
//    <name> TXIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40005818) Transmit interrupt status  (transmitters) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.1..1> TXIS
//    </check>
//  </item>
//  


// ------------------------------  Field Item: I2C2_I2C_ISR_TXE  ----------------------------------
// SVD Line: 8233

//  <item> SFDITEM_FIELD__I2C2_I2C_ISR_TXE
//    <name> TXE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40005818) Transmit data register empty  (transmitters) </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ISR ) </loc>
//      <o.0..0> TXE
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_ISR  ----------------------------------
// SVD Line: 8092

//  <rtree> SFDITEM_REG__I2C2_I2C_ISR
//    <name> I2C_ISR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005818) Interrupt and Status register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_ISR >> 0) & 0xFFFFFFFF), ((I2C2_I2C_ISR = (I2C2_I2C_ISR & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_ADDCODE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_DIR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_BUSY </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_ALERT </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_TIMEOUT </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_PECERR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_OVR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_ARLO </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_BERR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_TCR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_TC </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_STOPF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_NACKF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_ADDR </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_RXNE </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_TXIS </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ISR_TXE </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: I2C2_I2C_ICR  ------------------------------
// SVD Line: 8243

unsigned int I2C2_I2C_ICR __AT (0x4000581C);



// ----------------------------  Field Item: I2C2_I2C_ICR_ALERTCF  --------------------------------
// SVD Line: 8252

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_ALERTCF
//    <name> ALERTCF </name>
//    <w> 
//    <i> [Bit 13] WO (@ 0x4000581C) Alert flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.13..13> ALERTCF
//    </check>
//  </item>
//  


// ----------------------------  Field Item: I2C2_I2C_ICR_TIMOUTCF  -------------------------------
// SVD Line: 8258

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_TIMOUTCF
//    <name> TIMOUTCF </name>
//    <w> 
//    <i> [Bit 12] WO (@ 0x4000581C) Timeout detection flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.12..12> TIMOUTCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_PECCF  ---------------------------------
// SVD Line: 8265

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_PECCF
//    <name> PECCF </name>
//    <w> 
//    <i> [Bit 11] WO (@ 0x4000581C) PEC Error flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.11..11> PECCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_OVRCF  ---------------------------------
// SVD Line: 8271

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_OVRCF
//    <name> OVRCF </name>
//    <w> 
//    <i> [Bit 10] WO (@ 0x4000581C) Overrun/Underrun flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.10..10> OVRCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_ARLOCF  --------------------------------
// SVD Line: 8278

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_ARLOCF
//    <name> ARLOCF </name>
//    <w> 
//    <i> [Bit 9] WO (@ 0x4000581C) Arbitration lost flag  clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.9..9> ARLOCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_BERRCF  --------------------------------
// SVD Line: 8285

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_BERRCF
//    <name> BERRCF </name>
//    <w> 
//    <i> [Bit 8] WO (@ 0x4000581C) Bus error flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.8..8> BERRCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_STOPCF  --------------------------------
// SVD Line: 8291

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_STOPCF
//    <name> STOPCF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x4000581C) Stop detection flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.5..5> STOPCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_NACKCF  --------------------------------
// SVD Line: 8297

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_NACKCF
//    <name> NACKCF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x4000581C) Not Acknowledge flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.4..4> NACKCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: I2C2_I2C_ICR_ADDRCF  --------------------------------
// SVD Line: 8303

//  <item> SFDITEM_FIELD__I2C2_I2C_ICR_ADDRCF
//    <name> ADDRCF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x4000581C) Address Matched flag clear </i>
//    <check> 
//      <loc> ( (unsigned int) I2C2_I2C_ICR ) </loc>
//      <o.3..3> ADDRCF
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_ICR  ----------------------------------
// SVD Line: 8243

//  <rtree> SFDITEM_REG__I2C2_I2C_ICR
//    <name> I2C_ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x4000581C) Interrupt clear register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_ICR >> 0) & 0xFFFFFFFF), ((I2C2_I2C_ICR = (I2C2_I2C_ICR & ~(0x3F38UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3F38) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_ALERTCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_TIMOUTCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_PECCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_OVRCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_ARLOCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_BERRCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_STOPCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_NACKCF </item>
//    <item> SFDITEM_FIELD__I2C2_I2C_ICR_ADDRCF </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C2_I2C_PECR  ------------------------------
// SVD Line: 8311

unsigned int I2C2_I2C_PECR __AT (0x40005820);



// ------------------------------  Field Item: I2C2_I2C_PECR_PEC  ---------------------------------
// SVD Line: 8320

//  <item> SFDITEM_FIELD__I2C2_I2C_PECR_PEC
//    <name> PEC </name>
//    <r> 
//    <i> [Bits 7..0] RO (@ 0x40005820) Packet error checking  register </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_PECR >> 0) & 0xFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_PECR  ---------------------------------
// SVD Line: 8311

//  <rtree> SFDITEM_REG__I2C2_I2C_PECR
//    <name> I2C_PECR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40005820) PEC register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_PECR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_PECR_PEC </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C2_I2C_RXDR  ------------------------------
// SVD Line: 8329

unsigned int I2C2_I2C_RXDR __AT (0x40005824);



// ----------------------------  Field Item: I2C2_I2C_RXDR_RXDATA  --------------------------------
// SVD Line: 8338

//  <item> SFDITEM_FIELD__I2C2_I2C_RXDR_RXDATA
//    <name> RXDATA </name>
//    <r> 
//    <i> [Bits 7..0] RO (@ 0x40005824) 8-bit receive data </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_RXDR >> 0) & 0xFF) ) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_RXDR  ---------------------------------
// SVD Line: 8329

//  <rtree> SFDITEM_REG__I2C2_I2C_RXDR
//    <name> I2C_RXDR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40005824) Receive data register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_RXDR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_RXDR_RXDATA </item>
//  </rtree>
//  


// --------------------------  Register Item Address: I2C2_I2C_TXDR  ------------------------------
// SVD Line: 8346

unsigned int I2C2_I2C_TXDR __AT (0x40005828);



// ----------------------------  Field Item: I2C2_I2C_TXDR_TXDATA  --------------------------------
// SVD Line: 8355

//  <item> SFDITEM_FIELD__I2C2_I2C_TXDR_TXDATA
//    <name> TXDATA </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40005828) 8-bit transmit data </i>
//    <edit> 
//      <loc> ( (unsigned char)((I2C2_I2C_TXDR >> 0) & 0xFF), ((I2C2_I2C_TXDR = (I2C2_I2C_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: I2C2_I2C_TXDR  ---------------------------------
// SVD Line: 8346

//  <rtree> SFDITEM_REG__I2C2_I2C_TXDR
//    <name> I2C_TXDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40005828) Transmit data register </i>
//    <loc> ( (unsigned int)((I2C2_I2C_TXDR >> 0) & 0xFFFFFFFF), ((I2C2_I2C_TXDR = (I2C2_I2C_TXDR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__I2C2_I2C_TXDR_TXDATA </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: I2C2  -------------------------------------
// SVD Line: 8365

//  <view> I2C2
//    <name> I2C2 </name>
//    <item> SFDITEM_REG__I2C2_I2C_CR1 </item>
//    <item> SFDITEM_REG__I2C2_I2C_CR2 </item>
//    <item> SFDITEM_REG__I2C2_I2C_OAR1 </item>
//    <item> SFDITEM_REG__I2C2_I2C_OAR2 </item>
//    <item> SFDITEM_REG__I2C2_I2C_TIMINGR </item>
//    <item> SFDITEM_REG__I2C2_I2C_TIMEOUTR </item>
//    <item> SFDITEM_REG__I2C2_I2C_ISR </item>
//    <item> SFDITEM_REG__I2C2_I2C_ICR </item>
//    <item> SFDITEM_REG__I2C2_I2C_PECR </item>
//    <item> SFDITEM_REG__I2C2_I2C_RXDR </item>
//    <item> SFDITEM_REG__I2C2_I2C_TXDR </item>
//  </view>
//  


// ---------------------------  Register Item Address: IWDG_IWDG_KR  ------------------------------
// SVD Line: 8385

unsigned int IWDG_IWDG_KR __AT (0x40003000);



// ------------------------------  Field Item: IWDG_IWDG_KR_KEY  ----------------------------------
// SVD Line: 8394

//  <item> SFDITEM_FIELD__IWDG_IWDG_KR_KEY
//    <name> KEY </name>
//    <w> 
//    <i> [Bits 15..0] WO (@ 0x40003000) Key value (write only, read  0x0000) </i>
//    <edit> 
//      <loc> ( (unsigned short)((IWDG_IWDG_KR >> 0) & 0x0), ((IWDG_IWDG_KR = (IWDG_IWDG_KR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: IWDG_IWDG_KR  ----------------------------------
// SVD Line: 8385

//  <rtree> SFDITEM_REG__IWDG_IWDG_KR
//    <name> IWDG_KR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40003000) Key register </i>
//    <loc> ( (unsigned int)((IWDG_IWDG_KR >> 0) & 0xFFFFFFFF), ((IWDG_IWDG_KR = (IWDG_IWDG_KR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__IWDG_IWDG_KR_KEY </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: IWDG_IWDG_PR  ------------------------------
// SVD Line: 8403

unsigned int IWDG_IWDG_PR __AT (0x40003004);



// -------------------------------  Field Item: IWDG_IWDG_PR_PR  ----------------------------------
// SVD Line: 8412

//  <item> SFDITEM_FIELD__IWDG_IWDG_PR_PR
//    <name> PR </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40003004) \nPrescaler divider These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.\n0 : B_0x0 = divider /4\n1 : B_0x1 = divider /8\n2 : B_0x2 = divider /16\n3 : B_0x3 = divider /32\n4 : B_0x4 = divider /64\n5 : B_0x5 = divider /128\n6 : B_0x6 = divider /256\n7 : B_0x7 = divider /256 </i>
//    <combo> 
//      <loc> ( (unsigned int) IWDG_IWDG_PR ) </loc>
//      <o.2..0> PR
//        <0=> 0: B_0x0 = divider /4
//        <1=> 1: B_0x1 = divider /8
//        <2=> 2: B_0x2 = divider /16
//        <3=> 3: B_0x3 = divider /32
//        <4=> 4: B_0x4 = divider /64
//        <5=> 5: B_0x5 = divider /128
//        <6=> 6: B_0x6 = divider /256
//        <7=> 7: B_0x7 = divider /256
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: IWDG_IWDG_PR  ----------------------------------
// SVD Line: 8403

//  <rtree> SFDITEM_REG__IWDG_IWDG_PR
//    <name> IWDG_PR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40003004) Prescaler register </i>
//    <loc> ( (unsigned int)((IWDG_IWDG_PR >> 0) & 0xFFFFFFFF), ((IWDG_IWDG_PR = (IWDG_IWDG_PR & ~(0x7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__IWDG_IWDG_PR_PR </item>
//  </rtree>
//  


// --------------------------  Register Item Address: IWDG_IWDG_RLR  ------------------------------
// SVD Line: 8465

unsigned int IWDG_IWDG_RLR __AT (0x40003008);



// ------------------------------  Field Item: IWDG_IWDG_RLR_RL  ----------------------------------
// SVD Line: 8474

//  <item> SFDITEM_FIELD__IWDG_IWDG_RLR_RL
//    <name> RL </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40003008) Watchdog counter reload  value </i>
//    <edit> 
//      <loc> ( (unsigned short)((IWDG_IWDG_RLR >> 0) & 0xFFF), ((IWDG_IWDG_RLR = (IWDG_IWDG_RLR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: IWDG_IWDG_RLR  ---------------------------------
// SVD Line: 8465

//  <rtree> SFDITEM_REG__IWDG_IWDG_RLR
//    <name> IWDG_RLR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40003008) Reload register </i>
//    <loc> ( (unsigned int)((IWDG_IWDG_RLR >> 0) & 0xFFFFFFFF), ((IWDG_IWDG_RLR = (IWDG_IWDG_RLR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__IWDG_IWDG_RLR_RL </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: IWDG_IWDG_SR  ------------------------------
// SVD Line: 8483

unsigned int IWDG_IWDG_SR __AT (0x4000300C);



// ------------------------------  Field Item: IWDG_IWDG_SR_PVU  ----------------------------------
// SVD Line: 8492

//  <item> SFDITEM_FIELD__IWDG_IWDG_SR_PVU
//    <name> PVU </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x4000300C) Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Prescaler value can be updated only when PVU bit is reset. </i>
//    <check> 
//      <loc> ( (unsigned int) IWDG_IWDG_SR ) </loc>
//      <o.0..0> PVU
//    </check>
//  </item>
//  


// ------------------------------  Field Item: IWDG_IWDG_SR_RVU  ----------------------------------
// SVD Line: 8501

//  <item> SFDITEM_FIELD__IWDG_IWDG_SR_RVU
//    <name> RVU </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x4000300C) Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Reload value can be updated only when RVU bit is reset. </i>
//    <check> 
//      <loc> ( (unsigned int) IWDG_IWDG_SR ) </loc>
//      <o.1..1> RVU
//    </check>
//  </item>
//  


// ------------------------------  Field Item: IWDG_IWDG_SR_WVU  ----------------------------------
// SVD Line: 8510

//  <item> SFDITEM_FIELD__IWDG_IWDG_SR_WVU
//    <name> WVU </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x4000300C) Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles). Window value can be updated only when WVU bit is reset. </i>
//    <check> 
//      <loc> ( (unsigned int) IWDG_IWDG_SR ) </loc>
//      <o.2..2> WVU
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: IWDG_IWDG_SR  ----------------------------------
// SVD Line: 8483

//  <rtree> SFDITEM_REG__IWDG_IWDG_SR
//    <name> IWDG_SR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000300C) Status register </i>
//    <loc> ( (unsigned int)((IWDG_IWDG_SR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__IWDG_IWDG_SR_PVU </item>
//    <item> SFDITEM_FIELD__IWDG_IWDG_SR_RVU </item>
//    <item> SFDITEM_FIELD__IWDG_IWDG_SR_WVU </item>
//  </rtree>
//  


// --------------------------  Register Item Address: IWDG_IWDG_WINR  -----------------------------
// SVD Line: 8521

unsigned int IWDG_IWDG_WINR __AT (0x40003010);



// -----------------------------  Field Item: IWDG_IWDG_WINR_WIN  ---------------------------------
// SVD Line: 8530

//  <item> SFDITEM_FIELD__IWDG_IWDG_WINR_WIN
//    <name> WIN </name>
//    <rw> 
//    <i> [Bits 11..0] RW (@ 0x40003010) Watchdog counter window  value </i>
//    <edit> 
//      <loc> ( (unsigned short)((IWDG_IWDG_WINR >> 0) & 0xFFF), ((IWDG_IWDG_WINR = (IWDG_IWDG_WINR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: IWDG_IWDG_WINR  ---------------------------------
// SVD Line: 8521

//  <rtree> SFDITEM_REG__IWDG_IWDG_WINR
//    <name> IWDG_WINR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40003010) Window register </i>
//    <loc> ( (unsigned int)((IWDG_IWDG_WINR >> 0) & 0xFFFFFFFF), ((IWDG_IWDG_WINR = (IWDG_IWDG_WINR & ~(0xFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__IWDG_IWDG_WINR_WIN </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: IWDG  -------------------------------------
// SVD Line: 8374

//  <view> IWDG
//    <name> IWDG </name>
//    <item> SFDITEM_REG__IWDG_IWDG_KR </item>
//    <item> SFDITEM_REG__IWDG_IWDG_PR </item>
//    <item> SFDITEM_REG__IWDG_IWDG_RLR </item>
//    <item> SFDITEM_REG__IWDG_IWDG_SR </item>
//    <item> SFDITEM_REG__IWDG_IWDG_WINR </item>
//  </view>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_ISR  ----------------------------
// SVD Line: 8552

unsigned int LPTIM1_LPTIM_ISR __AT (0x40007C00);



// ----------------------------  Field Item: LPTIM1_LPTIM_ISR_CMPM  -------------------------------
// SVD Line: 8561

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_CMPM
//    <name> CMPM </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x40007C00) Compare match The CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registers value. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.0..0> CMPM
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM1_LPTIM_ISR_ARRM  -------------------------------
// SVD Line: 8569

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_ARRM
//    <name> ARRM </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x40007C00) Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.1..1> ARRM
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_ISR_EXTTRIG  ------------------------------
// SVD Line: 8577

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_EXTTRIG
//    <name> EXTTRIG </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40007C00) External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.2..2> EXTTRIG
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_ISR_CMPOK  -------------------------------
// SVD Line: 8585

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_CMPOK
//    <name> CMPOK </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40007C00) Compare register update OK CMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.3..3> CMPOK
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_ISR_ARROK  -------------------------------
// SVD Line: 8593

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_ARROK
//    <name> ARROK </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x40007C00) Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.4..4> ARROK
//    </check>
//  </item>
//  


// -----------------------------  Field Item: LPTIM1_LPTIM_ISR_UP  --------------------------------
// SVD Line: 8601

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_UP
//    <name> UP </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x40007C00) Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.5..5> UP
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM1_LPTIM_ISR_DOWN  -------------------------------
// SVD Line: 8610

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_DOWN
//    <name> DOWN </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x40007C00) Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ISR ) </loc>
//      <o.6..6> DOWN
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_ISR  --------------------------------
// SVD Line: 8552

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_ISR
//    <name> LPTIM_ISR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40007C00) Interrupt and Status Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_ISR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_CMPM </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_ARRM </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_EXTTRIG </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_CMPOK </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_ARROK </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_UP </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ISR_DOWN </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_ICR  ----------------------------
// SVD Line: 8621

unsigned int LPTIM1_LPTIM_ICR __AT (0x40007C04);



// ---------------------------  Field Item: LPTIM1_LPTIM_ICR_CMPMCF  ------------------------------
// SVD Line: 8630

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_CMPMCF
//    <name> CMPMCF </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40007C04) Compare match clear flag Writing 1 to this bit clears the CMP flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.0..0> CMPMCF
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_ICR_ARRMCF  ------------------------------
// SVD Line: 8638

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_ARRMCF
//    <name> ARRMCF </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40007C04) Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.1..1> ARRMCF
//    </check>
//  </item>
//  


// -------------------------  Field Item: LPTIM1_LPTIM_ICR_EXTTRIGCF  -----------------------------
// SVD Line: 8646

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_EXTTRIGCF
//    <name> EXTTRIGCF </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40007C04) External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.2..2> EXTTRIGCF
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_ICR_CMPOKCF  ------------------------------
// SVD Line: 8654

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_CMPOKCF
//    <name> CMPOKCF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40007C04) Compare register update OK clear flag Writing 1 to this bit clears the CMPOK flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.3..3> CMPOKCF
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_ICR_ARROKCF  ------------------------------
// SVD Line: 8662

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_ARROKCF
//    <name> ARROKCF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40007C04) Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.4..4> ARROKCF
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM1_LPTIM_ICR_UPCF  -------------------------------
// SVD Line: 8670

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_UPCF
//    <name> UPCF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40007C04) Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.5..5> UPCF
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_ICR_DOWNCF  ------------------------------
// SVD Line: 8679

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_DOWNCF
//    <name> DOWNCF </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40007C04) Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_ICR ) </loc>
//      <o.6..6> DOWNCF
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_ICR  --------------------------------
// SVD Line: 8621

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_ICR
//    <name> LPTIM_ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40007C04) Interrupt Clear Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_ICR >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_ICR = (LPTIM1_LPTIM_ICR & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_CMPMCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_ARRMCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_EXTTRIGCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_CMPOKCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_ARROKCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_UPCF </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ICR_DOWNCF </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_IER  ----------------------------
// SVD Line: 8690

unsigned int LPTIM1_LPTIM_IER __AT (0x40007C08);



// ---------------------------  Field Item: LPTIM1_LPTIM_IER_CMPMIE  ------------------------------
// SVD Line: 8699

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_CMPMIE
//    <name> CMPMIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007C08) \nCompare match Interrupt Enable\n0 : B_0x0 = CMPM interrupt disabled\n1 : B_0x1 = CMPM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.0..0> CMPMIE
//        <0=> 0: B_0x0 = CMPM interrupt disabled
//        <1=> 1: B_0x1 = CMPM interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_IER_ARRMIE  ------------------------------
// SVD Line: 8718

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_ARRMIE
//    <name> ARRMIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007C08) \nAutoreload match Interrupt Enable\n0 : B_0x0 = ARRM interrupt disabled\n1 : B_0x1 = ARRM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.1..1> ARRMIE
//        <0=> 0: B_0x0 = ARRM interrupt disabled
//        <1=> 1: B_0x1 = ARRM interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------  Field Item: LPTIM1_LPTIM_IER_EXTTRIGIE  -----------------------------
// SVD Line: 8737

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_EXTTRIGIE
//    <name> EXTTRIGIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40007C08) \nExternal trigger valid edge Interrupt Enable\n0 : B_0x0 = EXTTRIG interrupt disabled\n1 : B_0x1 = EXTTRIG interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.2..2> EXTTRIGIE
//        <0=> 0: B_0x0 = EXTTRIG interrupt disabled
//        <1=> 1: B_0x1 = EXTTRIG interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_IER_CMPOKIE  ------------------------------
// SVD Line: 8756

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_CMPOKIE
//    <name> CMPOKIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40007C08) \nCompare register update OK Interrupt Enable\n0 : B_0x0 = CMPOK interrupt disabled\n1 : B_0x1 = CMPOK interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.3..3> CMPOKIE
//        <0=> 0: B_0x0 = CMPOK interrupt disabled
//        <1=> 1: B_0x1 = CMPOK interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_IER_ARROKIE  ------------------------------
// SVD Line: 8775

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_ARROKIE
//    <name> ARROKIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40007C08) \nAutoreload register update OK Interrupt Enable\n0 : B_0x0 = ARROK interrupt disabled\n1 : B_0x1 = ARROK interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.4..4> ARROKIE
//        <0=> 0: B_0x0 = ARROK interrupt disabled
//        <1=> 1: B_0x1 = ARROK interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: LPTIM1_LPTIM_IER_UPIE  -------------------------------
// SVD Line: 8794

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_UPIE
//    <name> UPIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40007C08) \nDirection change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = UP interrupt disabled\n1 : B_0x1 = UP interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.5..5> UPIE
//        <0=> 0: B_0x0 = UP interrupt disabled
//        <1=> 1: B_0x1 = UP interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_IER_DOWNIE  ------------------------------
// SVD Line: 8814

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_DOWNIE
//    <name> DOWNIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40007C08) \nDirection change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = DOWN interrupt disabled\n1 : B_0x1 = DOWN interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_IER ) </loc>
//      <o.6..6> DOWNIE
//        <0=> 0: B_0x0 = DOWN interrupt disabled
//        <1=> 1: B_0x1 = DOWN interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_IER  --------------------------------
// SVD Line: 8690

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_IER
//    <name> LPTIM_IER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C08) Interrupt Enable Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_IER >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_IER = (LPTIM1_LPTIM_IER & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_CMPMIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_ARRMIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_EXTTRIGIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_CMPOKIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_ARROKIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_UPIE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_IER_DOWNIE </item>
//  </rtree>
//  


// ------------------------  Register Item Address: LPTIM1_LPTIM_CFGR  ----------------------------
// SVD Line: 8836

unsigned int LPTIM1_LPTIM_CFGR __AT (0x40007C0C);



// ---------------------------  Field Item: LPTIM1_LPTIM_CFGR_CKSEL  ------------------------------
// SVD Line: 8845

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKSEL
//    <name> CKSEL </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007C0C) \nClock selector The CKSEL bit selects which clock source the LPTIM will use:\n0 : B_0x0 = LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)\n1 : B_0x1 = LPTIM is clocked by an external clock source through the LPTIM external Input1 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.0..0> CKSEL
//        <0=> 0: B_0x0 = LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
//        <1=> 1: B_0x1 = LPTIM is clocked by an external clock source through the LPTIM external Input1
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CFGR_CKPOL  ------------------------------
// SVD Line: 8865

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKPOL
//    <name> CKPOL </name>
//    <rw> 
//    <i> [Bits 2..1] RW (@ 0x40007C0C) \nClock Polarity If LPTIM is clocked by an external clock source: When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. Refer to for more details about Encoder mode sub-modes.\n0 : B_0x0 = the rising edge is the active edge used for counting.\n1 : B_0x1 = the falling edge is the active edge used for counting\n2 : B_0x2 = both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.\n3 : B_0x3 = not allowed </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.2..1> CKPOL
//        <0=> 0: B_0x0 = the rising edge is the active edge used for counting.
//        <1=> 1: B_0x1 = the falling edge is the active edge used for counting
//        <2=> 2: B_0x2 = both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.
//        <3=> 3: B_0x3 = not allowed
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CFGR_CKFLT  ------------------------------
// SVD Line: 8899

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKFLT
//    <name> CKFLT </name>
//    <rw> 
//    <i> [Bits 4..3] RW (@ 0x40007C0C) \nConfigurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature\n0 : B_0x0 = any external clock signal level change is considered as a valid transition\n1 : B_0x1 = external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.\n2 : B_0x2 = external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.\n3 : B_0x3 = external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition. </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.4..3> CKFLT
//        <0=> 0: B_0x0 = any external clock signal level change is considered as a valid transition
//        <1=> 1: B_0x1 = external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
//        <2=> 2: B_0x2 = external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
//        <3=> 3: B_0x3 = external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_TRGFLT  ------------------------------
// SVD Line: 8929

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRGFLT
//    <name> TRGFLT </name>
//    <rw> 
//    <i> [Bits 7..6] RW (@ 0x40007C0C) \nConfigurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature\n0 : B_0x0 = any trigger active level change is considered as a valid trigger\n1 : B_0x1 = trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.\n2 : B_0x2 = trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.\n3 : B_0x3 = trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger. </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.7..6> TRGFLT
//        <0=> 0: B_0x0 = any trigger active level change is considered as a valid trigger
//        <1=> 1: B_0x1 = trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
//        <2=> 2: B_0x2 = trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
//        <3=> 3: B_0x3 = trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CFGR_PRESC  ------------------------------
// SVD Line: 8959

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 11..9] RW (@ 0x40007C0C) \nClock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:\n0 : B_0x0 = /1\n1 : B_0x1 = /2\n2 : B_0x2 = /4\n3 : B_0x3 = /8\n4 : B_0x4 = /16\n5 : B_0x5 = /32\n6 : B_0x6 = /64\n7 : B_0x7 = /128 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.11..9> PRESC
//        <0=> 0: B_0x0 = /1
//        <1=> 1: B_0x1 = /2
//        <2=> 2: B_0x2 = /4
//        <3=> 3: B_0x3 = /8
//        <4=> 4: B_0x4 = /16
//        <5=> 5: B_0x5 = /32
//        <6=> 6: B_0x6 = /64
//        <7=> 7: B_0x7 = /128
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_TRIGSEL  -----------------------------
// SVD Line: 9009

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRIGSEL
//    <name> TRIGSEL </name>
//    <rw> 
//    <i> [Bits 15..13] RW (@ 0x40007C0C) \nTrigger selector The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources: See for details.\n0 : B_0x0 = lptim_ext_trig0\n1 : B_0x1 = lptim_ext_trig1\n2 : B_0x2 = lptim_ext_trig2\n3 : B_0x3 = lptim_ext_trig3\n4 : B_0x4 = lptim_ext_trig4\n5 : B_0x5 = lptim_ext_trig5\n6 : B_0x6 = lptim_ext_trig6\n7 : B_0x7 = lptim_ext_trig7 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.15..13> TRIGSEL
//        <0=> 0: B_0x0 = lptim_ext_trig0
//        <1=> 1: B_0x1 = lptim_ext_trig1
//        <2=> 2: B_0x2 = lptim_ext_trig2
//        <3=> 3: B_0x3 = lptim_ext_trig3
//        <4=> 4: B_0x4 = lptim_ext_trig4
//        <5=> 5: B_0x5 = lptim_ext_trig5
//        <6=> 6: B_0x6 = lptim_ext_trig6
//        <7=> 7: B_0x7 = lptim_ext_trig7
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_TRIGEN  ------------------------------
// SVD Line: 9060

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRIGEN
//    <name> TRIGEN </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x40007C0C) \nTrigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:\n0 : B_0x0 = software trigger (counting start is initiated by software)\n1 : B_0x1 = rising edge is the active edge\n2 : B_0x2 = falling edge is the active edge\n3 : B_0x3 = both edges are active edges </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.18..17> TRIGEN
//        <0=> 0: B_0x0 = software trigger (counting start is initiated by software)
//        <1=> 1: B_0x1 = rising edge is the active edge
//        <2=> 2: B_0x2 = falling edge is the active edge
//        <3=> 3: B_0x3 = both edges are active edges
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_TIMOUT  ------------------------------
// SVD Line: 9090

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TIMOUT
//    <name> TIMOUT </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40007C0C) \nTimeout enable The TIMOUT bit controls the Timeout feature\n0 : B_0x0 = A trigger event arriving when the timer is already started will be ignored\n1 : B_0x1 = A trigger event arriving when the timer is already started will reset and restart the counter </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.19..19> TIMOUT
//        <0=> 0: B_0x0 = A trigger event arriving when the timer is already started will be ignored
//        <1=> 1: B_0x1 = A trigger event arriving when the timer is already started will reset and restart the counter
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CFGR_WAVE  -------------------------------
// SVD Line: 9110

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_WAVE
//    <name> WAVE </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40007C0C) \nWaveform shape The WAVE bit controls the output shape\n0 : B_0x0 = Deactivate Set-once mode, PWM or One Pulse waveform depending on how the timer was started, CNTSTRT for PWM or SNGSTRT for One Pulse waveform.\n1 : B_0x1 = Activate the Set-once mode </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.20..20> WAVE
//        <0=> 0: B_0x0 = Deactivate Set-once mode, PWM or One Pulse waveform depending on how the timer was started, CNTSTRT for PWM or SNGSTRT for One Pulse waveform.
//        <1=> 1: B_0x1 = Activate the Set-once mode
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_WAVPOL  ------------------------------
// SVD Line: 9130

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_WAVPOL
//    <name> WAVPOL </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x40007C0C) \nWaveform shape polarity The WAVEPOL bit controls the output polarity\n0 : B_0x0 = The LPTIM output reflects the compare results between LPTIM_CNT and LPTIM_CMP registers\n1 : B_0x1 = The LPTIM output reflects the inverse of the compare results between LPTIM_CNT and LPTIM_CMP registers </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.21..21> WAVPOL
//        <0=> 0: B_0x0 = The LPTIM output reflects the compare results between LPTIM_CNT and LPTIM_CMP registers
//        <1=> 1: B_0x1 = The LPTIM output reflects the inverse of the compare results between LPTIM_CNT and LPTIM_CMP registers
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR_PRELOAD  -----------------------------
// SVD Line: 9150

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_PRELOAD
//    <name> PRELOAD </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40007C0C) \nRegisters update mode The PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality\n0 : B_0x0 = Registers are updated after each APB bus write access\n1 : B_0x1 = Registers are updated at the end of the current LPTIM period </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.22..22> PRELOAD
//        <0=> 0: B_0x0 = Registers are updated after each APB bus write access
//        <1=> 1: B_0x1 = Registers are updated at the end of the current LPTIM period
//    </combo>
//  </item>
//  


// -------------------------  Field Item: LPTIM1_LPTIM_CFGR_COUNTMODE  ----------------------------
// SVD Line: 9170

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_COUNTMODE
//    <name> COUNTMODE </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40007C0C) \ncounter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:\n0 : B_0x0 = the counter is incremented following each internal clock pulse\n1 : B_0x1 = the counter is incremented following each valid clock pulse on the LPTIM external Input1 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.23..23> COUNTMODE
//        <0=> 0: B_0x0 = the counter is incremented following each internal clock pulse
//        <1=> 1: B_0x1 = the counter is incremented following each valid clock pulse on the LPTIM external Input1
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: LPTIM1_LPTIM_CFGR_ENC  -------------------------------
// SVD Line: 9190

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_ENC
//    <name> ENC </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40007C0C) \nEncoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = Encoder mode disabled\n1 : B_0x1 = Encoder mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR ) </loc>
//      <o.24..24> ENC
//        <0=> 0: B_0x0 = Encoder mode disabled
//        <1=> 1: B_0x1 = Encoder mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_CFGR  -------------------------------
// SVD Line: 8836

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_CFGR
//    <name> LPTIM_CFGR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C0C) Configuration Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_CFGR >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_CFGR = (LPTIM1_LPTIM_CFGR & ~(0x1FEEEDFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FEEEDF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKSEL </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKPOL </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_CKFLT </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRGFLT </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_PRESC </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRIGSEL </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TRIGEN </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_TIMOUT </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_WAVE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_WAVPOL </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_PRELOAD </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_COUNTMODE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR_ENC </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_CR  -----------------------------
// SVD Line: 9213

unsigned int LPTIM1_LPTIM_CR __AT (0x40007C10);



// ---------------------------  Field Item: LPTIM1_LPTIM_CR_ENABLE  -------------------------------
// SVD Line: 9222

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_ENABLE
//    <name> ENABLE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40007C10) \nLPTIM enable The ENABLE bit is set and cleared by software.\n0 : B_0x0 = LPTIM is disabled\n1 : B_0x1 = LPTIM is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CR ) </loc>
//      <o.0..0> ENABLE
//        <0=> 0: B_0x0 = LPTIM is disabled
//        <1=> 1: B_0x1 = LPTIM is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CR_SNGSTRT  ------------------------------
// SVD Line: 9242

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_SNGSTRT
//    <name> SNGSTRT </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40007C10) LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than '00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers. This bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CR ) </loc>
//      <o.1..1> SNGSTRT
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CR_CNTSTRT  ------------------------------
// SVD Line: 9254

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_CNTSTRT
//    <name> CNTSTRT </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40007C10) Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than '00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CR ) </loc>
//      <o.2..2> CNTSTRT
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CR_COUNTRST  ------------------------------
// SVD Line: 9266

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_COUNTRST
//    <name> COUNTRST </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40007C10) Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CR ) </loc>
//      <o.3..3> COUNTRST
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM1_LPTIM_CR_RSTARE  -------------------------------
// SVD Line: 9275

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_RSTARE
//    <name> RSTARE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40007C10) Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CR ) </loc>
//      <o.4..4> RSTARE
//    </check>
//  </item>
//  


// -----------------------------  Register RTree: LPTIM1_LPTIM_CR  --------------------------------
// SVD Line: 9213

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_CR
//    <name> LPTIM_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C10) Control Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_CR >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_CR = (LPTIM1_LPTIM_CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_ENABLE </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_SNGSTRT </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_CNTSTRT </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_COUNTRST </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CR_RSTARE </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_CMP  ----------------------------
// SVD Line: 9285

unsigned int LPTIM1_LPTIM_CMP __AT (0x40007C14);



// ----------------------------  Field Item: LPTIM1_LPTIM_CMP_CMP  --------------------------------
// SVD Line: 9294

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CMP_CMP
//    <name> CMP </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40007C14) Compare value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM1_LPTIM_CMP >> 0) & 0xFFFF), ((LPTIM1_LPTIM_CMP = (LPTIM1_LPTIM_CMP & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_CMP  --------------------------------
// SVD Line: 9285

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_CMP
//    <name> LPTIM_CMP </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C14) Compare Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_CMP >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_CMP = (LPTIM1_LPTIM_CMP & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CMP_CMP </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_ARR  ----------------------------
// SVD Line: 9302

unsigned int LPTIM1_LPTIM_ARR __AT (0x40007C18);



// ----------------------------  Field Item: LPTIM1_LPTIM_ARR_ARR  --------------------------------
// SVD Line: 9311

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40007C18) Auto reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM1_LPTIM_ARR >> 0) & 0xFFFF), ((LPTIM1_LPTIM_ARR = (LPTIM1_LPTIM_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_ARR  --------------------------------
// SVD Line: 9302

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_ARR
//    <name> LPTIM_ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C18) Autoreload Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_ARR >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_ARR = (LPTIM1_LPTIM_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_ARR_ARR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM1_LPTIM_CNT  ----------------------------
// SVD Line: 9319

unsigned int LPTIM1_LPTIM_CNT __AT (0x40007C1C);



// ----------------------------  Field Item: LPTIM1_LPTIM_CNT_CNT  --------------------------------
// SVD Line: 9328

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CNT_CNT
//    <name> CNT </name>
//    <r> 
//    <i> [Bits 15..0] RO (@ 0x40007C1C) Counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM1_LPTIM_CNT >> 0) & 0xFFFF) ) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM1_LPTIM_CNT  --------------------------------
// SVD Line: 9319

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_CNT
//    <name> LPTIM_CNT </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40007C1C) Counter Register </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_CNT >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CNT_CNT </item>
//  </rtree>
//  


// ------------------------  Register Item Address: LPTIM1_LPTIM_CFGR2  ---------------------------
// SVD Line: 9336

unsigned int LPTIM1_LPTIM_CFGR2 __AT (0x40007C24);



// --------------------------  Field Item: LPTIM1_LPTIM_CFGR2_IN1SEL  -----------------------------
// SVD Line: 9345

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR2_IN1SEL
//    <name> IN1SEL </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40007C24) \nLPTIM input 1 selection The IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs. For connection details refer to .\n0 : B_0x0 = lptim_in1_mux0\n1 : B_0x1 = lptim_in1_mux1\n2 : B_0x2 = lptim_in1_mux2\n3 : B_0x3 = lptim_in1_mux3 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR2 ) </loc>
//      <o.1..0> IN1SEL
//        <0=> 0: B_0x0 = lptim_in1_mux0
//        <1=> 1: B_0x1 = lptim_in1_mux1
//        <2=> 2: B_0x2 = lptim_in1_mux2
//        <3=> 3: B_0x3 = lptim_in1_mux3
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM1_LPTIM_CFGR2_IN2SEL  -----------------------------
// SVD Line: 9376

//  <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR2_IN2SEL
//    <name> IN2SEL </name>
//    <rw> 
//    <i> [Bits 5..4] RW (@ 0x40007C24) \nLPTIM input 2 selection The IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs. For connection details refer to . Note: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to .\n0 : B_0x0 = lptim_in2_mux0\n1 : B_0x1 = lptim_in2_mux1\n2 : B_0x2 = lptim_in2_mux2\n3 : B_0x3 = lptim_in2_mux3 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM1_LPTIM_CFGR2 ) </loc>
//      <o.5..4> IN2SEL
//        <0=> 0: B_0x0 = lptim_in2_mux0
//        <1=> 1: B_0x1 = lptim_in2_mux1
//        <2=> 2: B_0x2 = lptim_in2_mux2
//        <3=> 3: B_0x3 = lptim_in2_mux3
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: LPTIM1_LPTIM_CFGR2  -------------------------------
// SVD Line: 9336

//  <rtree> SFDITEM_REG__LPTIM1_LPTIM_CFGR2
//    <name> LPTIM_CFGR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40007C24) LPTIM configuration register 2 </i>
//    <loc> ( (unsigned int)((LPTIM1_LPTIM_CFGR2 >> 0) & 0xFFFFFFFF), ((LPTIM1_LPTIM_CFGR2 = (LPTIM1_LPTIM_CFGR2 & ~(0x33UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x33) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR2_IN1SEL </item>
//    <item> SFDITEM_FIELD__LPTIM1_LPTIM_CFGR2_IN2SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: LPTIM1  ------------------------------------
// SVD Line: 8541

//  <view> LPTIM1
//    <name> LPTIM1 </name>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_ISR </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_ICR </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_IER </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_CFGR </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_CR </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_CMP </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_ARR </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_CNT </item>
//    <item> SFDITEM_REG__LPTIM1_LPTIM_CFGR2 </item>
//  </view>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_ISR  ----------------------------
// SVD Line: 8552

unsigned int LPTIM2_LPTIM_ISR __AT (0x40009400);



// ----------------------------  Field Item: LPTIM2_LPTIM_ISR_CMPM  -------------------------------
// SVD Line: 8561

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_CMPM
//    <name> CMPM </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x40009400) Compare match The CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registers value. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.0..0> CMPM
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM2_LPTIM_ISR_ARRM  -------------------------------
// SVD Line: 8569

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_ARRM
//    <name> ARRM </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x40009400) Autoreload match ARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.1..1> ARRM
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_ISR_EXTTRIG  ------------------------------
// SVD Line: 8577

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_EXTTRIG
//    <name> EXTTRIG </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x40009400) External trigger edge event EXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.2..2> EXTTRIG
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_ISR_CMPOK  -------------------------------
// SVD Line: 8585

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_CMPOK
//    <name> CMPOK </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40009400) Compare register update OK CMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.3..3> CMPOK
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_ISR_ARROK  -------------------------------
// SVD Line: 8593

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_ARROK
//    <name> ARROK </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x40009400) Autoreload register update OK ARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.4..4> ARROK
//    </check>
//  </item>
//  


// -----------------------------  Field Item: LPTIM2_LPTIM_ISR_UP  --------------------------------
// SVD Line: 8601

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_UP
//    <name> UP </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x40009400) Counter direction change down to up In Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.5..5> UP
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM2_LPTIM_ISR_DOWN  -------------------------------
// SVD Line: 8610

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_DOWN
//    <name> DOWN </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x40009400) Counter direction change up to down In Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ISR ) </loc>
//      <o.6..6> DOWN
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_ISR  --------------------------------
// SVD Line: 8552

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_ISR
//    <name> LPTIM_ISR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40009400) Interrupt and Status Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_ISR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_CMPM </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_ARRM </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_EXTTRIG </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_CMPOK </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_ARROK </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_UP </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ISR_DOWN </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_ICR  ----------------------------
// SVD Line: 8621

unsigned int LPTIM2_LPTIM_ICR __AT (0x40009404);



// ---------------------------  Field Item: LPTIM2_LPTIM_ICR_CMPMCF  ------------------------------
// SVD Line: 8630

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_CMPMCF
//    <name> CMPMCF </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40009404) Compare match clear flag Writing 1 to this bit clears the CMP flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.0..0> CMPMCF
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_ICR_ARRMCF  ------------------------------
// SVD Line: 8638

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_ARRMCF
//    <name> ARRMCF </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40009404) Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.1..1> ARRMCF
//    </check>
//  </item>
//  


// -------------------------  Field Item: LPTIM2_LPTIM_ICR_EXTTRIGCF  -----------------------------
// SVD Line: 8646

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_EXTTRIGCF
//    <name> EXTTRIGCF </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40009404) External trigger valid edge clear flag Writing 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.2..2> EXTTRIGCF
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_ICR_CMPOKCF  ------------------------------
// SVD Line: 8654

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_CMPOKCF
//    <name> CMPOKCF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40009404) Compare register update OK clear flag Writing 1 to this bit clears the CMPOK flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.3..3> CMPOKCF
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_ICR_ARROKCF  ------------------------------
// SVD Line: 8662

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_ARROKCF
//    <name> ARROKCF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40009404) Autoreload register update OK clear flag Writing 1 to this bit clears the ARROK flag in the LPTIM_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.4..4> ARROKCF
//    </check>
//  </item>
//  


// ----------------------------  Field Item: LPTIM2_LPTIM_ICR_UPCF  -------------------------------
// SVD Line: 8670

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_UPCF
//    <name> UPCF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40009404) Direction change to UP clear flag Writing 1 to this bit clear the UP flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.5..5> UPCF
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_ICR_DOWNCF  ------------------------------
// SVD Line: 8679

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_DOWNCF
//    <name> DOWNCF </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40009404) Direction change to down clear flag Writing 1 to this bit clear the DOWN flag in the LPTIM_ISR register. Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_ICR ) </loc>
//      <o.6..6> DOWNCF
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_ICR  --------------------------------
// SVD Line: 8621

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_ICR
//    <name> LPTIM_ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40009404) Interrupt Clear Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_ICR >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_ICR = (LPTIM2_LPTIM_ICR & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_CMPMCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_ARRMCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_EXTTRIGCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_CMPOKCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_ARROKCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_UPCF </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ICR_DOWNCF </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_IER  ----------------------------
// SVD Line: 8690

unsigned int LPTIM2_LPTIM_IER __AT (0x40009408);



// ---------------------------  Field Item: LPTIM2_LPTIM_IER_CMPMIE  ------------------------------
// SVD Line: 8699

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_CMPMIE
//    <name> CMPMIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40009408) \nCompare match Interrupt Enable\n0 : B_0x0 = CMPM interrupt disabled\n1 : B_0x1 = CMPM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.0..0> CMPMIE
//        <0=> 0: B_0x0 = CMPM interrupt disabled
//        <1=> 1: B_0x1 = CMPM interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_IER_ARRMIE  ------------------------------
// SVD Line: 8718

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_ARRMIE
//    <name> ARRMIE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40009408) \nAutoreload match Interrupt Enable\n0 : B_0x0 = ARRM interrupt disabled\n1 : B_0x1 = ARRM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.1..1> ARRMIE
//        <0=> 0: B_0x0 = ARRM interrupt disabled
//        <1=> 1: B_0x1 = ARRM interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------  Field Item: LPTIM2_LPTIM_IER_EXTTRIGIE  -----------------------------
// SVD Line: 8737

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_EXTTRIGIE
//    <name> EXTTRIGIE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40009408) \nExternal trigger valid edge Interrupt Enable\n0 : B_0x0 = EXTTRIG interrupt disabled\n1 : B_0x1 = EXTTRIG interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.2..2> EXTTRIGIE
//        <0=> 0: B_0x0 = EXTTRIG interrupt disabled
//        <1=> 1: B_0x1 = EXTTRIG interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_IER_CMPOKIE  ------------------------------
// SVD Line: 8756

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_CMPOKIE
//    <name> CMPOKIE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40009408) \nCompare register update OK Interrupt Enable\n0 : B_0x0 = CMPOK interrupt disabled\n1 : B_0x1 = CMPOK interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.3..3> CMPOKIE
//        <0=> 0: B_0x0 = CMPOK interrupt disabled
//        <1=> 1: B_0x1 = CMPOK interrupt enabled
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_IER_ARROKIE  ------------------------------
// SVD Line: 8775

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_ARROKIE
//    <name> ARROKIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40009408) \nAutoreload register update OK Interrupt Enable\n0 : B_0x0 = ARROK interrupt disabled\n1 : B_0x1 = ARROK interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.4..4> ARROKIE
//        <0=> 0: B_0x0 = ARROK interrupt disabled
//        <1=> 1: B_0x1 = ARROK interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: LPTIM2_LPTIM_IER_UPIE  -------------------------------
// SVD Line: 8794

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_UPIE
//    <name> UPIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40009408) \nDirection change to UP Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = UP interrupt disabled\n1 : B_0x1 = UP interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.5..5> UPIE
//        <0=> 0: B_0x0 = UP interrupt disabled
//        <1=> 1: B_0x1 = UP interrupt enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_IER_DOWNIE  ------------------------------
// SVD Line: 8814

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_DOWNIE
//    <name> DOWNIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40009408) \nDirection change to down Interrupt Enable Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = DOWN interrupt disabled\n1 : B_0x1 = DOWN interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_IER ) </loc>
//      <o.6..6> DOWNIE
//        <0=> 0: B_0x0 = DOWN interrupt disabled
//        <1=> 1: B_0x1 = DOWN interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_IER  --------------------------------
// SVD Line: 8690

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_IER
//    <name> LPTIM_IER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40009408) Interrupt Enable Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_IER >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_IER = (LPTIM2_LPTIM_IER & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_CMPMIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_ARRMIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_EXTTRIGIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_CMPOKIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_ARROKIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_UPIE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_IER_DOWNIE </item>
//  </rtree>
//  


// ------------------------  Register Item Address: LPTIM2_LPTIM_CFGR  ----------------------------
// SVD Line: 8836

unsigned int LPTIM2_LPTIM_CFGR __AT (0x4000940C);



// ---------------------------  Field Item: LPTIM2_LPTIM_CFGR_CKSEL  ------------------------------
// SVD Line: 8845

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKSEL
//    <name> CKSEL </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000940C) \nClock selector The CKSEL bit selects which clock source the LPTIM will use:\n0 : B_0x0 = LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)\n1 : B_0x1 = LPTIM is clocked by an external clock source through the LPTIM external Input1 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.0..0> CKSEL
//        <0=> 0: B_0x0 = LPTIM is clocked by internal clock source (APB clock or any of the embedded oscillators)
//        <1=> 1: B_0x1 = LPTIM is clocked by an external clock source through the LPTIM external Input1
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CFGR_CKPOL  ------------------------------
// SVD Line: 8865

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKPOL
//    <name> CKPOL </name>
//    <rw> 
//    <i> [Bits 2..1] RW (@ 0x4000940C) \nClock Polarity If LPTIM is clocked by an external clock source: When the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter: If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active. If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active. Refer to for more details about Encoder mode sub-modes.\n0 : B_0x0 = the rising edge is the active edge used for counting.\n1 : B_0x1 = the falling edge is the active edge used for counting\n2 : B_0x2 = both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.\n3 : B_0x3 = not allowed </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.2..1> CKPOL
//        <0=> 0: B_0x0 = the rising edge is the active edge used for counting.
//        <1=> 1: B_0x1 = the falling edge is the active edge used for counting
//        <2=> 2: B_0x2 = both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four times the external clock frequency.If the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.
//        <3=> 3: B_0x3 = not allowed
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CFGR_CKFLT  ------------------------------
// SVD Line: 8899

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKFLT
//    <name> CKFLT </name>
//    <rw> 
//    <i> [Bits 4..3] RW (@ 0x4000940C) \nConfigurable digital filter for external clock The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature\n0 : B_0x0 = any external clock signal level change is considered as a valid transition\n1 : B_0x1 = external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.\n2 : B_0x2 = external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.\n3 : B_0x3 = external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition. </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.4..3> CKFLT
//        <0=> 0: B_0x0 = any external clock signal level change is considered as a valid transition
//        <1=> 1: B_0x1 = external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
//        <2=> 2: B_0x2 = external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
//        <3=> 3: B_0x3 = external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_TRGFLT  ------------------------------
// SVD Line: 8929

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRGFLT
//    <name> TRGFLT </name>
//    <rw> 
//    <i> [Bits 7..6] RW (@ 0x4000940C) \nConfigurable digital filter for trigger The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature\n0 : B_0x0 = any trigger active level change is considered as a valid trigger\n1 : B_0x1 = trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.\n2 : B_0x2 = trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.\n3 : B_0x3 = trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger. </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.7..6> TRGFLT
//        <0=> 0: B_0x0 = any trigger active level change is considered as a valid trigger
//        <1=> 1: B_0x1 = trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
//        <2=> 2: B_0x2 = trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
//        <3=> 3: B_0x3 = trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CFGR_PRESC  ------------------------------
// SVD Line: 8959

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 11..9] RW (@ 0x4000940C) \nClock prescaler The PRESC bits configure the prescaler division factor. It can be one among the following division factors:\n0 : B_0x0 = /1\n1 : B_0x1 = /2\n2 : B_0x2 = /4\n3 : B_0x3 = /8\n4 : B_0x4 = /16\n5 : B_0x5 = /32\n6 : B_0x6 = /64\n7 : B_0x7 = /128 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.11..9> PRESC
//        <0=> 0: B_0x0 = /1
//        <1=> 1: B_0x1 = /2
//        <2=> 2: B_0x2 = /4
//        <3=> 3: B_0x3 = /8
//        <4=> 4: B_0x4 = /16
//        <5=> 5: B_0x5 = /32
//        <6=> 6: B_0x6 = /64
//        <7=> 7: B_0x7 = /128
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_TRIGSEL  -----------------------------
// SVD Line: 9009

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRIGSEL
//    <name> TRIGSEL </name>
//    <rw> 
//    <i> [Bits 15..13] RW (@ 0x4000940C) \nTrigger selector The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources: See for details.\n0 : B_0x0 = lptim_ext_trig0\n1 : B_0x1 = lptim_ext_trig1\n2 : B_0x2 = lptim_ext_trig2\n3 : B_0x3 = lptim_ext_trig3\n4 : B_0x4 = lptim_ext_trig4\n5 : B_0x5 = lptim_ext_trig5\n6 : B_0x6 = lptim_ext_trig6\n7 : B_0x7 = lptim_ext_trig7 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.15..13> TRIGSEL
//        <0=> 0: B_0x0 = lptim_ext_trig0
//        <1=> 1: B_0x1 = lptim_ext_trig1
//        <2=> 2: B_0x2 = lptim_ext_trig2
//        <3=> 3: B_0x3 = lptim_ext_trig3
//        <4=> 4: B_0x4 = lptim_ext_trig4
//        <5=> 5: B_0x5 = lptim_ext_trig5
//        <6=> 6: B_0x6 = lptim_ext_trig6
//        <7=> 7: B_0x7 = lptim_ext_trig7
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_TRIGEN  ------------------------------
// SVD Line: 9060

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRIGEN
//    <name> TRIGEN </name>
//    <rw> 
//    <i> [Bits 18..17] RW (@ 0x4000940C) \nTrigger enable and polarity The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:\n0 : B_0x0 = software trigger (counting start is initiated by software)\n1 : B_0x1 = rising edge is the active edge\n2 : B_0x2 = falling edge is the active edge\n3 : B_0x3 = both edges are active edges </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.18..17> TRIGEN
//        <0=> 0: B_0x0 = software trigger (counting start is initiated by software)
//        <1=> 1: B_0x1 = rising edge is the active edge
//        <2=> 2: B_0x2 = falling edge is the active edge
//        <3=> 3: B_0x3 = both edges are active edges
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_TIMOUT  ------------------------------
// SVD Line: 9090

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TIMOUT
//    <name> TIMOUT </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x4000940C) \nTimeout enable The TIMOUT bit controls the Timeout feature\n0 : B_0x0 = A trigger event arriving when the timer is already started will be ignored\n1 : B_0x1 = A trigger event arriving when the timer is already started will reset and restart the counter </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.19..19> TIMOUT
//        <0=> 0: B_0x0 = A trigger event arriving when the timer is already started will be ignored
//        <1=> 1: B_0x1 = A trigger event arriving when the timer is already started will reset and restart the counter
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CFGR_WAVE  -------------------------------
// SVD Line: 9110

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_WAVE
//    <name> WAVE </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x4000940C) \nWaveform shape The WAVE bit controls the output shape\n0 : B_0x0 = Deactivate Set-once mode, PWM or One Pulse waveform depending on how the timer was started, CNTSTRT for PWM or SNGSTRT for One Pulse waveform.\n1 : B_0x1 = Activate the Set-once mode </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.20..20> WAVE
//        <0=> 0: B_0x0 = Deactivate Set-once mode, PWM or One Pulse waveform depending on how the timer was started, CNTSTRT for PWM or SNGSTRT for One Pulse waveform.
//        <1=> 1: B_0x1 = Activate the Set-once mode
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_WAVPOL  ------------------------------
// SVD Line: 9130

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_WAVPOL
//    <name> WAVPOL </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x4000940C) \nWaveform shape polarity The WAVEPOL bit controls the output polarity\n0 : B_0x0 = The LPTIM output reflects the compare results between LPTIM_CNT and LPTIM_CMP registers\n1 : B_0x1 = The LPTIM output reflects the inverse of the compare results between LPTIM_CNT and LPTIM_CMP registers </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.21..21> WAVPOL
//        <0=> 0: B_0x0 = The LPTIM output reflects the compare results between LPTIM_CNT and LPTIM_CMP registers
//        <1=> 1: B_0x1 = The LPTIM output reflects the inverse of the compare results between LPTIM_CNT and LPTIM_CMP registers
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR_PRELOAD  -----------------------------
// SVD Line: 9150

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_PRELOAD
//    <name> PRELOAD </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x4000940C) \nRegisters update mode The PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality\n0 : B_0x0 = Registers are updated after each APB bus write access\n1 : B_0x1 = Registers are updated at the end of the current LPTIM period </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.22..22> PRELOAD
//        <0=> 0: B_0x0 = Registers are updated after each APB bus write access
//        <1=> 1: B_0x1 = Registers are updated at the end of the current LPTIM period
//    </combo>
//  </item>
//  


// -------------------------  Field Item: LPTIM2_LPTIM_CFGR_COUNTMODE  ----------------------------
// SVD Line: 9170

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_COUNTMODE
//    <name> COUNTMODE </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x4000940C) \ncounter mode enabled The COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:\n0 : B_0x0 = the counter is incremented following each internal clock pulse\n1 : B_0x1 = the counter is incremented following each valid clock pulse on the LPTIM external Input1 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.23..23> COUNTMODE
//        <0=> 0: B_0x0 = the counter is incremented following each internal clock pulse
//        <1=> 1: B_0x1 = the counter is incremented following each valid clock pulse on the LPTIM external Input1
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: LPTIM2_LPTIM_CFGR_ENC  -------------------------------
// SVD Line: 9190

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_ENC
//    <name> ENC </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x4000940C) \nEncoder mode enable The ENC bit controls the Encoder mode Note: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to .\n0 : B_0x0 = Encoder mode disabled\n1 : B_0x1 = Encoder mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR ) </loc>
//      <o.24..24> ENC
//        <0=> 0: B_0x0 = Encoder mode disabled
//        <1=> 1: B_0x1 = Encoder mode enabled
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_CFGR  -------------------------------
// SVD Line: 8836

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_CFGR
//    <name> LPTIM_CFGR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000940C) Configuration Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_CFGR >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_CFGR = (LPTIM2_LPTIM_CFGR & ~(0x1FEEEDFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FEEEDF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKSEL </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKPOL </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_CKFLT </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRGFLT </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_PRESC </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRIGSEL </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TRIGEN </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_TIMOUT </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_WAVE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_WAVPOL </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_PRELOAD </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_COUNTMODE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR_ENC </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_CR  -----------------------------
// SVD Line: 9213

unsigned int LPTIM2_LPTIM_CR __AT (0x40009410);



// ---------------------------  Field Item: LPTIM2_LPTIM_CR_ENABLE  -------------------------------
// SVD Line: 9222

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_ENABLE
//    <name> ENABLE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40009410) \nLPTIM enable The ENABLE bit is set and cleared by software.\n0 : B_0x0 = LPTIM is disabled\n1 : B_0x1 = LPTIM is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CR ) </loc>
//      <o.0..0> ENABLE
//        <0=> 0: B_0x0 = LPTIM is disabled
//        <1=> 1: B_0x1 = LPTIM is enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CR_SNGSTRT  ------------------------------
// SVD Line: 9242

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_SNGSTRT
//    <name> SNGSTRT </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40009410) LPTIM start in Single mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00), setting this bit starts the LPTIM in single pulse mode. If the software start is disabled (TRIGEN[1:0] different than '00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected. If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers. This bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CR ) </loc>
//      <o.1..1> SNGSTRT
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CR_CNTSTRT  ------------------------------
// SVD Line: 9254

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_CNTSTRT
//    <name> CNTSTRT </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40009410) Timer start in Continuous mode This bit is set by software and cleared by hardware. In case of software start (TRIGEN[1:0] = '00), setting this bit starts the LPTIM in Continuous mode. If the software start is disabled (TRIGEN[1:0] different than '00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected. If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode. This bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CR ) </loc>
//      <o.2..2> CNTSTRT
//    </check>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CR_COUNTRST  ------------------------------
// SVD Line: 9266

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_COUNTRST
//    <name> COUNTRST </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40009410) Counter reset This bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock). COUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CR ) </loc>
//      <o.3..3> COUNTRST
//    </check>
//  </item>
//  


// ---------------------------  Field Item: LPTIM2_LPTIM_CR_RSTARE  -------------------------------
// SVD Line: 9275

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_RSTARE
//    <name> RSTARE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40009410) Reset after read enable This bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content. </i>
//    <check> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CR ) </loc>
//      <o.4..4> RSTARE
//    </check>
//  </item>
//  


// -----------------------------  Register RTree: LPTIM2_LPTIM_CR  --------------------------------
// SVD Line: 9213

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_CR
//    <name> LPTIM_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40009410) Control Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_CR >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_CR = (LPTIM2_LPTIM_CR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_ENABLE </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_SNGSTRT </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_CNTSTRT </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_COUNTRST </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CR_RSTARE </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_CMP  ----------------------------
// SVD Line: 9285

unsigned int LPTIM2_LPTIM_CMP __AT (0x40009414);



// ----------------------------  Field Item: LPTIM2_LPTIM_CMP_CMP  --------------------------------
// SVD Line: 9294

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CMP_CMP
//    <name> CMP </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40009414) Compare value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM2_LPTIM_CMP >> 0) & 0xFFFF), ((LPTIM2_LPTIM_CMP = (LPTIM2_LPTIM_CMP & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_CMP  --------------------------------
// SVD Line: 9285

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_CMP
//    <name> LPTIM_CMP </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40009414) Compare Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_CMP >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_CMP = (LPTIM2_LPTIM_CMP & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CMP_CMP </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_ARR  ----------------------------
// SVD Line: 9302

unsigned int LPTIM2_LPTIM_ARR __AT (0x40009418);



// ----------------------------  Field Item: LPTIM2_LPTIM_ARR_ARR  --------------------------------
// SVD Line: 9311

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40009418) Auto reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM2_LPTIM_ARR >> 0) & 0xFFFF), ((LPTIM2_LPTIM_ARR = (LPTIM2_LPTIM_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_ARR  --------------------------------
// SVD Line: 9302

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_ARR
//    <name> LPTIM_ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40009418) Autoreload Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_ARR >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_ARR = (LPTIM2_LPTIM_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_ARR_ARR </item>
//  </rtree>
//  


// -------------------------  Register Item Address: LPTIM2_LPTIM_CNT  ----------------------------
// SVD Line: 9319

unsigned int LPTIM2_LPTIM_CNT __AT (0x4000941C);



// ----------------------------  Field Item: LPTIM2_LPTIM_CNT_CNT  --------------------------------
// SVD Line: 9328

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CNT_CNT
//    <name> CNT </name>
//    <r> 
//    <i> [Bits 15..0] RO (@ 0x4000941C) Counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((LPTIM2_LPTIM_CNT >> 0) & 0xFFFF) ) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: LPTIM2_LPTIM_CNT  --------------------------------
// SVD Line: 9319

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_CNT
//    <name> LPTIM_CNT </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000941C) Counter Register </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_CNT >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CNT_CNT </item>
//  </rtree>
//  


// ------------------------  Register Item Address: LPTIM2_LPTIM_CFGR2  ---------------------------
// SVD Line: 9336

unsigned int LPTIM2_LPTIM_CFGR2 __AT (0x40009424);



// --------------------------  Field Item: LPTIM2_LPTIM_CFGR2_IN1SEL  -----------------------------
// SVD Line: 9345

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR2_IN1SEL
//    <name> IN1SEL </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40009424) \nLPTIM input 1 selection The IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs. For connection details refer to .\n0 : B_0x0 = lptim_in1_mux0\n1 : B_0x1 = lptim_in1_mux1\n2 : B_0x2 = lptim_in1_mux2\n3 : B_0x3 = lptim_in1_mux3 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR2 ) </loc>
//      <o.1..0> IN1SEL
//        <0=> 0: B_0x0 = lptim_in1_mux0
//        <1=> 1: B_0x1 = lptim_in1_mux1
//        <2=> 2: B_0x2 = lptim_in1_mux2
//        <3=> 3: B_0x3 = lptim_in1_mux3
//    </combo>
//  </item>
//  


// --------------------------  Field Item: LPTIM2_LPTIM_CFGR2_IN2SEL  -----------------------------
// SVD Line: 9376

//  <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR2_IN2SEL
//    <name> IN2SEL </name>
//    <rw> 
//    <i> [Bits 5..4] RW (@ 0x40009424) \nLPTIM input 2 selection The IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs. For connection details refer to . Note: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to .\n0 : B_0x0 = lptim_in2_mux0\n1 : B_0x1 = lptim_in2_mux1\n2 : B_0x2 = lptim_in2_mux2\n3 : B_0x3 = lptim_in2_mux3 </i>
//    <combo> 
//      <loc> ( (unsigned int) LPTIM2_LPTIM_CFGR2 ) </loc>
//      <o.5..4> IN2SEL
//        <0=> 0: B_0x0 = lptim_in2_mux0
//        <1=> 1: B_0x1 = lptim_in2_mux1
//        <2=> 2: B_0x2 = lptim_in2_mux2
//        <3=> 3: B_0x3 = lptim_in2_mux3
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: LPTIM2_LPTIM_CFGR2  -------------------------------
// SVD Line: 9336

//  <rtree> SFDITEM_REG__LPTIM2_LPTIM_CFGR2
//    <name> LPTIM_CFGR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40009424) LPTIM configuration register 2 </i>
//    <loc> ( (unsigned int)((LPTIM2_LPTIM_CFGR2 >> 0) & 0xFFFFFFFF), ((LPTIM2_LPTIM_CFGR2 = (LPTIM2_LPTIM_CFGR2 & ~(0x33UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x33) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR2_IN1SEL </item>
//    <item> SFDITEM_FIELD__LPTIM2_LPTIM_CFGR2_IN2SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: LPTIM2  ------------------------------------
// SVD Line: 9412

//  <view> LPTIM2
//    <name> LPTIM2 </name>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_ISR </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_ICR </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_IER </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_CFGR </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_CR </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_CMP </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_ARR </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_CNT </item>
//    <item> SFDITEM_REG__LPTIM2_LPTIM_CFGR2 </item>
//  </view>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CR1  ------------------------------
// SVD Line: 9437

unsigned int TIM1_TIM1_CR1 __AT (0x40012C00);



// ------------------------------  Field Item: TIM1_TIM1_CR1_CEN  ---------------------------------
// SVD Line: 9446

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C00) \nCounter enable Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR1_UDIS  ---------------------------------
// SVD Line: 9466

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C00) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR1_URS  ---------------------------------
// SVD Line: 9490

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C00) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR1_OPM  ---------------------------------
// SVD Line: 9513

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C00) \nOne pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR1_DIR  ---------------------------------
// SVD Line: 9532

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_DIR
//    <name> DIR </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012C00) \nDirection Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.\n0 : B_0x0 = Counter used as upcounter\n1 : B_0x1 = Counter used as downcounter </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.4..4> DIR
//        <0=> 0: B_0x0 = Counter used as upcounter
//        <1=> 1: B_0x1 = Counter used as downcounter
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR1_CMS  ---------------------------------
// SVD Line: 9552

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CMS
//    <name> CMS </name>
//    <rw> 
//    <i> [Bits 6..5] RW (@ 0x40012C00) \nCenter-aligned mode selection Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed\n0 : B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).\n1 : B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.\n2 : B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.\n3 : B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.6..5> CMS
//        <0=> 0: B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
//        <1=> 1: B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.
//        <2=> 2: B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.
//        <3=> 3: B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR1_ARPE  ---------------------------------
// SVD Line: 9582

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C00) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR1_CKD  ---------------------------------
// SVD Line: 9601

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C00) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx): Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.\n0 : B_0x0 = tDTS=tCK_INT\n1 : B_0x1 = tDTS=2*tCK_INT\n2 : B_0x2 = tDTS=4*tCK_INT\n3 : B_0x3 = Reserved, do not program this value </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS=tCK_INT
//        <1=> 1: B_0x1 = tDTS=2*tCK_INT
//        <2=> 2: B_0x2 = tDTS=4*tCK_INT
//        <3=> 3: B_0x3 = Reserved, do not program this value
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_CR1_UIFREMAP  -------------------------------
// SVD Line: 9632

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C00) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_CR1  ---------------------------------
// SVD Line: 9437

//  <rtree> SFDITEM_REG__TIM1_TIM1_CR1
//    <name> TIM1_CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C00) control register 1 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CR1 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CR1 = (TIM1_TIM1_CR1 & ~(0xBFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_DIR </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CMS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR1_UIFREMAP </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CR2  ------------------------------
// SVD Line: 9653

unsigned int TIM1_TIM1_CR2 __AT (0x40012C04);



// -----------------------------  Field Item: TIM1_TIM1_CR2_CCPC  ---------------------------------
// SVD Line: 9662

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCPC
//    <name> CCPC </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C04) \nCapture/compare preloaded control Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded\n1 : B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.0..0> CCPC
//        <0=> 0: B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded
//        <1=> 1: B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_CCUS  ---------------------------------
// SVD Line: 9682

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCUS
//    <name> CCUS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C04) \nCapture/compare control update selection Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only\n1 : B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.2..2> CCUS
//        <0=> 0: B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only
//        <1=> 1: B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_CCDS  ---------------------------------
// SVD Line: 9702

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C04) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_CR2_MMS  ---------------------------------
// SVD Line: 9721

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012C04) \nMaster mode selection These bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\n2 : B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).\n4 : B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)\n5 : B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)\n6 : B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)\n7 : B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
//        <2=> 2: B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).
//        <4=> 4: B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)
//        <5=> 5: B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)
//        <6=> 6: B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)
//        <7=> 7: B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO)
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_TI1S  ---------------------------------
// SVD Line: 9772

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_TI1S
//    <name> TI1S </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C04) \nTI1 selection\n0 : B_0x0 = The TIMx_CH1 pin is connected to TI1 input\n1 : B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.7..7> TI1S
//        <0=> 0: B_0x0 = The TIMx_CH1 pin is connected to TI1 input
//        <1=> 1: B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS1  ---------------------------------
// SVD Line: 9791

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS1
//    <name> OIS1 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012C04) \nOutput Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0\n1 : B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.8..8> OIS1
//        <0=> 0: B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
//        <1=> 1: B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS1N  --------------------------------
// SVD Line: 9811

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS1N
//    <name> OIS1N </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C04) \nOutput Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1N=0 after a dead-time when MOE=0\n1 : B_0x1 = OC1N=1 after a dead-time when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.9..9> OIS1N
//        <0=> 0: B_0x0 = OC1N=0 after a dead-time when MOE=0
//        <1=> 1: B_0x1 = OC1N=1 after a dead-time when MOE=0
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS2  ---------------------------------
// SVD Line: 9831

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS2
//    <name> OIS2 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C04) Output Idle state 2 (OC2 output) Refer to OIS1 bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.10..10> OIS2
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS2N  --------------------------------
// SVD Line: 9839

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS2N
//    <name> OIS2N </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C04) Output Idle state 2 (OC2N output) Refer to OIS1N bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.11..11> OIS2N
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS3  ---------------------------------
// SVD Line: 9847

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS3
//    <name> OIS3 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012C04) Output Idle state 3 (OC3 output) Refer to OIS1 bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.12..12> OIS3
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS3N  --------------------------------
// SVD Line: 9855

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS3N
//    <name> OIS3N </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012C04) Output Idle state 3 (OC3N output) Refer to OIS1N bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.13..13> OIS3N
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS4  ---------------------------------
// SVD Line: 9863

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS4
//    <name> OIS4 </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012C04) Output Idle state 4 (OC4 output) Refer to OIS1 bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.14..14> OIS4
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS5  ---------------------------------
// SVD Line: 9871

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS5
//    <name> OIS5 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C04) Output Idle state 5 (OC5 output) Refer to OIS1 bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.16..16> OIS5
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_OIS6  ---------------------------------
// SVD Line: 9879

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS6
//    <name> OIS6 </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40012C04) Output Idle state 6 (OC6 output) Refer to OIS1 bit </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.18..18> OIS6
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CR2_MMS2  ---------------------------------
// SVD Line: 9887

//  <item> SFDITEM_FIELD__TIM1_TIM1_CR2_MMS2
//    <name> MMS2 </name>
//    <rw> 
//    <i> [Bits 23..20] RW (@ 0x40012C04) \nMaster mode selection 2 These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows: Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register).\n2 : B_0x2 = Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer.\n3 : B_0x3 = Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2).\n4 : B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO2)\n5 : B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO2)\n6 : B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO2)\n7 : B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO2)\n8 : B_0x8 = Compare - OC5REFC signal is used as trigger output (TRGO2)\n9 : B_0x9 = Compare - OC6REFC signal is used as trigger output (TRGO2)\n10 : B_0xA = Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2\n11 : B_0xB = Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2\n12 : B_0xC = Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2\n13 : B_0xD = Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2\n14 : B_0xE = Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2\n15 : B_0xF = Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CR2 ) </loc>
//      <o.23..20> MMS2
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR register).
//        <2=> 2: B_0x2 = Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: B_0x3 = Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or compare match occurs (TRGO2).
//        <4=> 4: B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO2)
//        <5=> 5: B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO2)
//        <6=> 6: B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO2)
//        <7=> 7: B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO2)
//        <8=> 8: B_0x8 = Compare - OC5REFC signal is used as trigger output (TRGO2)
//        <9=> 9: B_0x9 = Compare - OC6REFC signal is used as trigger output (TRGO2)
//        <10=> 10: B_0xA = Compare Pulse - OC4REFC rising or falling edges generate pulses on TRGO2
//        <11=> 11: B_0xB = Compare Pulse - OC6REFC rising or falling edges generate pulses on TRGO2
//        <12=> 12: B_0xC = Compare Pulse - OC4REFC or OC6REFC rising edges generate pulses on TRGO2
//        <13=> 13: B_0xD = Compare Pulse - OC4REFC rising or OC6REFC falling edges generate pulses on TRGO2
//        <14=> 14: B_0xE = Compare Pulse - OC5REFC or OC6REFC rising edges generate pulses on TRGO2
//        <15=> 15: B_0xF = Compare Pulse - OC5REFC rising or OC6REFC falling edges generate pulses on TRGO2
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_CR2  ---------------------------------
// SVD Line: 9653

//  <rtree> SFDITEM_REG__TIM1_TIM1_CR2
//    <name> TIM1_CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C04) control register 2 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CR2 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CR2 = (TIM1_TIM1_CR2 & ~(0xF57FFDUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF57FFD) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCPC </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCUS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_MMS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_TI1S </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS1 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS1N </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS2 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS2N </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS3 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS3N </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS4 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS5 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_OIS6 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CR2_MMS2 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_SMCR  -----------------------------
// SVD Line: 9980

unsigned int TIM1_TIM1_SMCR __AT (0x40012C08);



// -----------------------------  Field Item: TIM1_TIM1_SMCR_SMS1  --------------------------------
// SVD Line: 9989

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_SMS1
//    <name> SMS1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40012C08) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.\n2 : B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.\n3 : B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.\n4 : B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.\n5 : B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.\n6 : B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.\n7 : B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.2..0> SMS1
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//        <2=> 2: B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
//        <3=> 3: B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
//        <4=> 4: B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
//        <5=> 5: B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
//        <6=> 6: B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
//        <7=> 7: B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_OCCS  --------------------------------
// SVD Line: 10046

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_OCCS
//    <name> OCCS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C08) \nOCREF clear selection This bit is used to select the OCREF clear source.\n0 : B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIM1_OR1.OCREF_CLR\n1 : B_0x1 = OCREF_CLR_INT is connected to ETRF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.3..3> OCCS
//        <0=> 0: B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIM1_OR1.OCREF_CLR
//        <1=> 1: B_0x1 = OCREF_CLR_INT is connected to ETRF
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_TS1  ---------------------------------
// SVD Line: 10066

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_TS1
//    <name> TS1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012C08) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3)\n4 : B_0x4 = TI1 Edge Detector (TI1F_ED)\n5 : B_0x5 = Filtered Timer Input 1 (TI1FP1)\n6 : B_0x6 = Filtered Timer Input 2 (TI2FP2)\n7 : B_0x7 = External Trigger input (ETRF) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.6..4> TS1
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//        <4=> 4: B_0x4 = TI1 Edge Detector (TI1F_ED)
//        <5=> 5: B_0x5 = Filtered Timer Input 1 (TI1FP1)
//        <6=> 6: B_0x6 = Filtered Timer Input 2 (TI2FP2)
//        <7=> 7: B_0x7 = External Trigger input (ETRF)
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_MSM  ---------------------------------
// SVD Line: 10119

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_MSM
//    <name> MSM </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C08) \nMaster/slave mode\n0 : B_0x0 = No action\n1 : B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.7..7> MSM
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_ETF  ---------------------------------
// SVD Line: 10138

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETF
//    <name> ETF </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40012C08) \nExternal trigger filter This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.11..8> ETF
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_ETPS  --------------------------------
// SVD Line: 10228

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETPS
//    <name> ETPS </name>
//    <rw> 
//    <i> [Bits 13..12] RW (@ 0x40012C08) \nExternal trigger prescaler External trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.\n0 : B_0x0 = Prescaler OFF\n1 : B_0x1 = ETRP frequency divided by 2\n2 : B_0x2 = ETRP frequency divided by 4\n3 : B_0x3 = ETRP frequency divided by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.13..12> ETPS
//        <0=> 0: B_0x0 = Prescaler OFF
//        <1=> 1: B_0x1 = ETRP frequency divided by 2
//        <2=> 2: B_0x2 = ETRP frequency divided by 4
//        <3=> 3: B_0x3 = ETRP frequency divided by 8
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_ECE  ---------------------------------
// SVD Line: 10258

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ECE
//    <name> ECE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012C08) \nExternal clock enable This bit enables External clock mode 2. Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111). If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.\n0 : B_0x0 = External clock mode 2 disabled\n1 : B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.14..14> ECE
//        <0=> 0: B_0x0 = External clock mode 2 disabled
//        <1=> 1: B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_ETP  ---------------------------------
// SVD Line: 10281

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETP
//    <name> ETP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C08) \nExternal trigger polarity This bit selects whether ETR or ETR is used for trigger operations\n0 : B_0x0 = ETR is non-inverted, active at high level or rising edge.\n1 : B_0x1 = ETR is inverted, active at low level or falling edge. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.15..15> ETP
//        <0=> 0: B_0x0 = ETR is non-inverted, active at high level or rising edge.
//        <1=> 1: B_0x1 = ETR is inverted, active at low level or falling edge.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_SMS2  --------------------------------
// SVD Line: 10301

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_SMS2
//    <name> SMS2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C08) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.16..16> SMS2
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SMCR_TS2  ---------------------------------
// SVD Line: 10358

//  <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_TS2
//    <name> TS2 </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40012C08) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SMCR ) </loc>
//      <o.21..20> TS2
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_SMCR  ---------------------------------
// SVD Line: 9980

//  <rtree> SFDITEM_REG__TIM1_TIM1_SMCR
//    <name> TIM1_SMCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C08) slave mode control register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_SMCR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_SMCR = (TIM1_TIM1_SMCR & ~(0x31FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x31FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_SMS1 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_OCCS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_TS1 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_MSM </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETPS </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ECE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_ETP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_SMS2 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SMCR_TS2 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_DIER  -----------------------------
// SVD Line: 10413

unsigned int TIM1_TIM1_DIER __AT (0x40012C0C);



// -----------------------------  Field Item: TIM1_TIM1_DIER_UIE  ---------------------------------
// SVD Line: 10422

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C0C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled\n1 : B_0x1 = Update interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled
//        <1=> 1: B_0x1 = Update interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC1IE  --------------------------------
// SVD Line: 10441

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C0C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled\n1 : B_0x1 = CC1 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled
//        <1=> 1: B_0x1 = CC1 interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC2IE  --------------------------------
// SVD Line: 10460

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC2IE
//    <name> CC2IE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C0C) \nCapture/Compare 2 interrupt enable\n0 : B_0x0 = CC2 interrupt disabled\n1 : B_0x1 = CC2 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.2..2> CC2IE
//        <0=> 0: B_0x0 = CC2 interrupt disabled
//        <1=> 1: B_0x1 = CC2 interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC3IE  --------------------------------
// SVD Line: 10479

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC3IE
//    <name> CC3IE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C0C) \nCapture/Compare 3 interrupt enable\n0 : B_0x0 = CC3 interrupt disabled\n1 : B_0x1 = CC3 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.3..3> CC3IE
//        <0=> 0: B_0x0 = CC3 interrupt disabled
//        <1=> 1: B_0x1 = CC3 interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC4IE  --------------------------------
// SVD Line: 10498

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC4IE
//    <name> CC4IE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012C0C) \nCapture/Compare 4 interrupt enable\n0 : B_0x0 = CC4 interrupt disabled\n1 : B_0x1 = CC4 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.4..4> CC4IE
//        <0=> 0: B_0x0 = CC4 interrupt disabled
//        <1=> 1: B_0x1 = CC4 interrupt enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_COMIE  --------------------------------
// SVD Line: 10517

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_COMIE
//    <name> COMIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40012C0C) \nCOM interrupt enable\n0 : B_0x0 = COM interrupt disabled\n1 : B_0x1 = COM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.5..5> COMIE
//        <0=> 0: B_0x0 = COM interrupt disabled
//        <1=> 1: B_0x1 = COM interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_DIER_TIE  ---------------------------------
// SVD Line: 10536

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_TIE
//    <name> TIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40012C0C) \nTrigger interrupt enable\n0 : B_0x0 = Trigger interrupt disabled\n1 : B_0x1 = Trigger interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.6..6> TIE
//        <0=> 0: B_0x0 = Trigger interrupt disabled
//        <1=> 1: B_0x1 = Trigger interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_DIER_BIE  ---------------------------------
// SVD Line: 10555

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_BIE
//    <name> BIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C0C) \nBreak interrupt enable\n0 : B_0x0 = Break interrupt disabled\n1 : B_0x1 = Break interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.7..7> BIE
//        <0=> 0: B_0x0 = Break interrupt disabled
//        <1=> 1: B_0x1 = Break interrupt enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_DIER_UDE  ---------------------------------
// SVD Line: 10574

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012C0C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled\n1 : B_0x1 = Update DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled
//        <1=> 1: B_0x1 = Update DMA request enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC1DE  --------------------------------
// SVD Line: 10593

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C0C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled\n1 : B_0x1 = CC1 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled
//        <1=> 1: B_0x1 = CC1 DMA request enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC2DE  --------------------------------
// SVD Line: 10612

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC2DE
//    <name> CC2DE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C0C) \nCapture/Compare 2 DMA request enable\n0 : B_0x0 = CC2 DMA request disabled\n1 : B_0x1 = CC2 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.10..10> CC2DE
//        <0=> 0: B_0x0 = CC2 DMA request disabled
//        <1=> 1: B_0x1 = CC2 DMA request enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC3DE  --------------------------------
// SVD Line: 10631

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC3DE
//    <name> CC3DE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C0C) \nCapture/Compare 3 DMA request enable\n0 : B_0x0 = CC3 DMA request disabled\n1 : B_0x1 = CC3 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.11..11> CC3DE
//        <0=> 0: B_0x0 = CC3 DMA request disabled
//        <1=> 1: B_0x1 = CC3 DMA request enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_CC4DE  --------------------------------
// SVD Line: 10650

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC4DE
//    <name> CC4DE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012C0C) \nCapture/Compare 4 DMA request enable\n0 : B_0x0 = CC4 DMA request disabled\n1 : B_0x1 = CC4 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.12..12> CC4DE
//        <0=> 0: B_0x0 = CC4 DMA request disabled
//        <1=> 1: B_0x1 = CC4 DMA request enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_DIER_COMDE  --------------------------------
// SVD Line: 10669

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_COMDE
//    <name> COMDE </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012C0C) \nCOM DMA request enable\n0 : B_0x0 = COM DMA request disabled\n1 : B_0x1 = COM DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.13..13> COMDE
//        <0=> 0: B_0x0 = COM DMA request disabled
//        <1=> 1: B_0x1 = COM DMA request enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_DIER_TDE  ---------------------------------
// SVD Line: 10688

//  <item> SFDITEM_FIELD__TIM1_TIM1_DIER_TDE
//    <name> TDE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012C0C) \nTrigger DMA request enable\n0 : B_0x0 = Trigger DMA request disabled\n1 : B_0x1 = Trigger DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DIER ) </loc>
//      <o.14..14> TDE
//        <0=> 0: B_0x0 = Trigger DMA request disabled
//        <1=> 1: B_0x1 = Trigger DMA request enabled
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_DIER  ---------------------------------
// SVD Line: 10413

//  <rtree> SFDITEM_REG__TIM1_TIM1_DIER
//    <name> TIM1_DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C0C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_DIER >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_DIER = (TIM1_TIM1_DIER & ~(0x7FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC2IE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC3IE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC4IE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_COMIE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_TIE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_BIE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC1DE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC2DE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC3DE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_CC4DE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_COMDE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DIER_TDE </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: TIM1_TIM1_SR  ------------------------------
// SVD Line: 10709

unsigned int TIM1_TIM1_SR __AT (0x40012C10);



// ------------------------------  Field Item: TIM1_TIM1_SR_UIF  ----------------------------------
// SVD Line: 10718

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C10) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC1IF  ---------------------------------
// SVD Line: 10741

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C10) \nCapture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC2IF  ---------------------------------
// SVD Line: 10763

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC2IF
//    <name> CC2IF </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C10) Capture/Compare 2 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.2..2> CC2IF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC3IF  ---------------------------------
// SVD Line: 10771

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC3IF
//    <name> CC3IF </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C10) Capture/Compare 3 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.3..3> CC3IF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC4IF  ---------------------------------
// SVD Line: 10779

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC4IF
//    <name> CC4IF </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012C10) Capture/Compare 4 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.4..4> CC4IF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_COMIF  ---------------------------------
// SVD Line: 10787

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_COMIF
//    <name> COMIF </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40012C10) \nCOM interrupt flag This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.\n0 : B_0x0 = No COM event occurred.\n1 : B_0x1 = COM interrupt pending. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.5..5> COMIF
//        <0=> 0: B_0x0 = No COM event occurred.
//        <1=> 1: B_0x1 = COM interrupt pending.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_SR_TIF  ----------------------------------
// SVD Line: 10807

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_TIF
//    <name> TIF </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40012C10) \nTrigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.\n0 : B_0x0 = No trigger event occurred.\n1 : B_0x1 = Trigger interrupt pending. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.6..6> TIF
//        <0=> 0: B_0x0 = No trigger event occurred.
//        <1=> 1: B_0x1 = Trigger interrupt pending.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_SR_BIF  ----------------------------------
// SVD Line: 10827

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_BIF
//    <name> BIF </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C10) \nBreak interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.\n0 : B_0x0 = No break event occurred.\n1 : B_0x1 = An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.7..7> BIF
//        <0=> 0: B_0x0 = No break event occurred.
//        <1=> 1: B_0x1 = An active level has been detected on the break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_SR_B2IF  ---------------------------------
// SVD Line: 10847

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_B2IF
//    <name> B2IF </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012C10) \nBreak 2 interrupt flag This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.\n0 : B_0x0 = No break event occurred.\n1 : B_0x1 = An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.8..8> B2IF
//        <0=> 0: B_0x0 = No break event occurred.
//        <1=> 1: B_0x1 = An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC1OF  ---------------------------------
// SVD Line: 10867

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C10) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected.\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected.
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC2OF  ---------------------------------
// SVD Line: 10887

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC2OF
//    <name> CC2OF </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C10) Capture/Compare 2 overcapture flag Refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.10..10> CC2OF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC3OF  ---------------------------------
// SVD Line: 10895

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC3OF
//    <name> CC3OF </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C10) Capture/Compare 3 overcapture flag Refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.11..11> CC3OF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC4OF  ---------------------------------
// SVD Line: 10903

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC4OF
//    <name> CC4OF </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012C10) Capture/Compare 4 overcapture flag Refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.12..12> CC4OF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_SR_SBIF  ---------------------------------
// SVD Line: 10911

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_SBIF
//    <name> SBIF </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012C10) \nSystem Break interrupt flag This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active. This flag must be reset to re-start PWM operation.\n0 : B_0x0 = No break event occurred.\n1 : B_0x1 = An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.13..13> SBIF
//        <0=> 0: B_0x0 = No break event occurred.
//        <1=> 1: B_0x1 = An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the TIMx_DIER register.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC5IF  ---------------------------------
// SVD Line: 10932

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC5IF
//    <name> CC5IF </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C10) Compare 5 interrupt flag Refer to CC1IF description (Note: Channel 5 can only be configured as output) </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.16..16> CC5IF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_SR_CC6IF  ---------------------------------
// SVD Line: 10940

//  <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC6IF
//    <name> CC6IF </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40012C10) Compare 6 interrupt flag Refer to CC1IF description (Note: Channel 6 can only be configured as output) </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_SR ) </loc>
//      <o.17..17> CC6IF
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_SR  ----------------------------------
// SVD Line: 10709

//  <rtree> SFDITEM_REG__TIM1_TIM1_SR
//    <name> TIM1_SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C10) status register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_SR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_SR = (TIM1_TIM1_SR & ~(0x33FFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x33FFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC2IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC3IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC4IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_COMIF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_TIF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_BIF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_B2IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC1OF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC2OF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC3OF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC4OF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_SBIF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC5IF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_SR_CC6IF </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_EGR  ------------------------------
// SVD Line: 10950

unsigned int TIM1_TIM1_EGR __AT (0x40012C14);



// ------------------------------  Field Item: TIM1_TIM1_EGR_UG  ----------------------------------
// SVD Line: 10959

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40012C14) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = Reinitialize the counter and generates an update of the registers. The prescaler internal counter is also cleared (the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_EGR_CC1G  ---------------------------------
// SVD Line: 10979

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40012C14) \nCapture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_EGR_CC2G  ---------------------------------
// SVD Line: 11003

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC2G
//    <name> CC2G </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40012C14) Capture/Compare 2 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.2..2> CC2G
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_EGR_CC3G  ---------------------------------
// SVD Line: 11011

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC3G
//    <name> CC3G </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40012C14) Capture/Compare 3 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.3..3> CC3G
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_EGR_CC4G  ---------------------------------
// SVD Line: 11019

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC4G
//    <name> CC4G </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40012C14) Capture/Compare 4 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.4..4> CC4G
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_EGR_COMG  ---------------------------------
// SVD Line: 11027

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_COMG
//    <name> COMG </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40012C14) \nCapture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware Note: This bit acts only on channels having a complementary output.\n0 : B_0x0 = No action\n1 : B_0x1 = When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.5..5> COMG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = When CCPC bit is set, it allows CCxE, CCxNE and OCxM bits to be updated.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_EGR_TG  ----------------------------------
// SVD Line: 11048

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_TG
//    <name> TG </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40012C14) \nTrigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.6..6> TG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_EGR_BG  ----------------------------------
// SVD Line: 11068

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_BG
//    <name> BG </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40012C14) \nBreak generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.7..7> BG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_EGR_B2G  ---------------------------------
// SVD Line: 11088

//  <item> SFDITEM_FIELD__TIM1_TIM1_EGR_B2G
//    <name> B2G </name>
//    <w> 
//    <i> [Bit 8] WO (@ 0x40012C14) \nBreak 2 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_EGR ) </loc>
//      <o.8..8> B2G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_EGR  ---------------------------------
// SVD Line: 10950

//  <rtree> SFDITEM_REG__TIM1_TIM1_EGR
//    <name> TIM1_EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40012C14) event generation register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_EGR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_EGR = (TIM1_TIM1_EGR & ~(0x1FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC2G </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC3G </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_CC4G </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_COMG </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_TG </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_BG </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_EGR_B2G </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM1_CCMR1_Output  ----------------------------
// SVD Line: 11110

unsigned int TIM1_CCMR1_Output __AT (0x40012C18);



// ---------------------------  Field Item: TIM1_CCMR1_Output_CC1S  -------------------------------
// SVD Line: 11120

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40012C18) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 11151

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C18) \nOutput Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.\n0 : B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.\n1 : B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//        <0=> 0: B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.
//        <1=> 1: B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 11171

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C18) \nOutput Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 11192

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012C18) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).\n7 : B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).
//        <7=> 7: B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC1CE  ------------------------------
// SVD Line: 11276

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1CE
//    <name> OC1CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C18) \nOutput Compare 1 clear enable\n0 : B_0x0 = OC1Ref is not affected by the ocref_clr_int signal\n1 : B_0x1 = OC1Ref is cleared as soon as a High level is detected on ocref_clr_int signal (OCREF_CLR input or ETRF input) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.7..7> OC1CE
//        <0=> 0: B_0x0 = OC1Ref is not affected by the ocref_clr_int signal
//        <1=> 1: B_0x1 = OC1Ref is cleared as soon as a High level is detected on ocref_clr_int signal (OCREF_CLR input or ETRF input)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_CC2S  -------------------------------
// SVD Line: 11295

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C18) \nCapture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC2FE  ------------------------------
// SVD Line: 11326

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2FE
//    <name> OC2FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C18) Output Compare 2 fast enable Refer to OC1FE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.10..10> OC2FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC2PE  ------------------------------
// SVD Line: 11334

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2PE
//    <name> OC2PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C18) Output Compare 2 preload enable Refer to OC1PE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.11..11> OC2PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC2M1  ------------------------------
// SVD Line: 11342

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2M1
//    <name> OC2M1 </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40012C18) Output Compare 2 mode Refer to OC1M[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR1_Output >> 12) & 0x7), ((TIM1_CCMR1_Output = (TIM1_CCMR1_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC2CE  ------------------------------
// SVD Line: 11350

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2CE
//    <name> OC2CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C18) Output Compare 2 clear enable Refer to OC1CE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.15..15> OC2CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC1M2  ------------------------------
// SVD Line: 11358

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1M2
//    <name> OC1M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C18) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.16..16> OC1M2
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Output_OC2M2  ------------------------------
// SVD Line: 11442

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2M2
//    <name> OC2M2 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012C18) Output Compare 2 mode Refer to OC1M[3:0] description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Output ) </loc>
//      <o.24..24> OC2M2
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: TIM1_CCMR1_Output  -------------------------------
// SVD Line: 11110

//  <rtree> SFDITEM_REG__TIM1_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C18) capture/compare mode register 1 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM1_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM1_CCMR1_Output = (TIM1_CCMR1_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_CC1S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_CC2S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2FE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2M1 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC1M2 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Output_OC2M2 </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM1_CCMR1_Input  ----------------------------
// SVD Line: 11452

unsigned int TIM1_CCMR1_Input __AT (0x40012C18);



// ----------------------------  Field Item: TIM1_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 11463

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40012C18) \nCapture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Input ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 11494

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40012C18) \nInput capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).\n0 : B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input\n1 : B_0x1 = capture is done once every 2 events\n2 : B_0x2 = capture is done once every 4 events\n3 : B_0x3 = capture is done once every 8 events </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Input ) </loc>
//      <o.3..2> IC1PSC
//        <0=> 0: B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input
//        <1=> 1: B_0x1 = capture is done once every 2 events
//        <2=> 2: B_0x2 = capture is done once every 4 events
//        <3=> 3: B_0x3 = capture is done once every 8 events
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 11524

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40012C18) \nInput capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Input ) </loc>
//      <o.7..4> IC1F
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR1_Input_CC2S  -------------------------------
// SVD Line: 11614

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C18) \nCapture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR1_Input ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR1_Input_IC2PSC  ------------------------------
// SVD Line: 11645

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC2PSC
//    <name> IC2PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x40012C18) Input capture 2 prescaler Refer to IC1PSC[1:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR1_Input >> 10) & 0x3), ((TIM1_CCMR1_Input = (TIM1_CCMR1_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR1_Input_IC2F  -------------------------------
// SVD Line: 11653

//  <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC2F
//    <name> IC2F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40012C18) Input capture 2 filter Refer to IC1F[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR1_Input >> 12) & 0xF), ((TIM1_CCMR1_Input = (TIM1_CCMR1_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM1_CCMR1_Input  --------------------------------
// SVD Line: 11452

//  <rtree> SFDITEM_REG__TIM1_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C18) capture/compare mode register 1 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM1_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM1_CCMR1_Input = (TIM1_CCMR1_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_CC1S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC1F </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_CC2S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC2PSC </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR1_Input_IC2F </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM1_CCMR2_Output  ----------------------------
// SVD Line: 11663

unsigned int TIM1_CCMR2_Output __AT (0x40012C1C);



// ---------------------------  Field Item: TIM1_CCMR2_Output_CC3S  -------------------------------
// SVD Line: 11673

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40012C1C) \nCapture/Compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = '0 in TIMx_CCER).\n0 : B_0x0 = CC3 channel is configured as output\n1 : B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3\n2 : B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4\n3 : B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.1..0> CC3S
//        <0=> 0: B_0x0 = CC3 channel is configured as output
//        <1=> 1: B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3
//        <2=> 2: B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4
//        <3=> 3: B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC3FE  ------------------------------
// SVD Line: 11704

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3FE
//    <name> OC3FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C1C) Output compare 3 fast enable Refer to OC1FE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.2..2> OC3FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC3PE  ------------------------------
// SVD Line: 11712

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3PE
//    <name> OC3PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C1C) Output compare 3 preload enable Refer to OC1PE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.3..3> OC3PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC3M1  ------------------------------
// SVD Line: 11720

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3M1
//    <name> OC3M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012C1C) Output compare 3 mode Refer to OC1M[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Output >> 4) & 0x7), ((TIM1_CCMR2_Output = (TIM1_CCMR2_Output & ~(0x7UL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC3CE  ------------------------------
// SVD Line: 11728

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3CE
//    <name> OC3CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C1C) Output compare 3 clear enable Refer to OC1CE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.7..7> OC3CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_CC4S  -------------------------------
// SVD Line: 11736

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C1C) \nCapture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = '0 in TIMx_CCER).\n0 : B_0x0 = CC4 channel is configured as output\n1 : B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4\n2 : B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3\n3 : B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.9..8> CC4S
//        <0=> 0: B_0x0 = CC4 channel is configured as output
//        <1=> 1: B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4
//        <2=> 2: B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3
//        <3=> 3: B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC4FE  ------------------------------
// SVD Line: 11767

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4FE
//    <name> OC4FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C1C) Output compare 4 fast enable Refer to OC1FE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.10..10> OC4FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC4PE  ------------------------------
// SVD Line: 11775

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4PE
//    <name> OC4PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C1C) Output compare 4 preload enable Refer to OC1PE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.11..11> OC4PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC4M1  ------------------------------
// SVD Line: 11783

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4M1
//    <name> OC4M1 </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40012C1C) Output compare 4 mode Refer to OC3M[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Output >> 12) & 0x7), ((TIM1_CCMR2_Output = (TIM1_CCMR2_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC4CE  ------------------------------
// SVD Line: 11791

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4CE
//    <name> OC4CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C1C) Output compare 4 clear enable Refer to OC1CE description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.15..15> OC4CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC3M2  ------------------------------
// SVD Line: 11799

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3M2
//    <name> OC3M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C1C) Output compare 3 mode Refer to OC1M[3:0] description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.16..16> OC3M2
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Output_OC4M2  ------------------------------
// SVD Line: 11807

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4M2
//    <name> OC4M2 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012C1C) Output compare 4 mode Refer to OC3M[3:0] description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Output ) </loc>
//      <o.24..24> OC4M2
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: TIM1_CCMR2_Output  -------------------------------
// SVD Line: 11663

//  <rtree> SFDITEM_REG__TIM1_CCMR2_Output
//    <name> CCMR2_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C1C) capture/compare mode register 2 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM1_CCMR2_Output >> 0) & 0xFFFFFFFF), ((TIM1_CCMR2_Output = (TIM1_CCMR2_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_CC3S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3FE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3M1 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_CC4S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4FE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4M1 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC3M2 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Output_OC4M2 </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM1_CCMR2_Input  ----------------------------
// SVD Line: 11817

unsigned int TIM1_CCMR2_Input __AT (0x40012C1C);



// ----------------------------  Field Item: TIM1_CCMR2_Input_CC3S  -------------------------------
// SVD Line: 11828

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40012C1C) \nCapture/compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = '0 in TIMx_CCER).\n0 : B_0x0 = CC3 channel is configured as output\n1 : B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3\n2 : B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4\n3 : B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Input ) </loc>
//      <o.1..0> CC3S
//        <0=> 0: B_0x0 = CC3 channel is configured as output
//        <1=> 1: B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3
//        <2=> 2: B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4
//        <3=> 3: B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Input_IC3PSC  ------------------------------
// SVD Line: 11859

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC3PSC
//    <name> IC3PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40012C1C) Input capture 3 prescaler Refer to IC1PSC[1:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Input >> 2) & 0x3), ((TIM1_CCMR2_Input = (TIM1_CCMR2_Input & ~(0x3UL << 2 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 2 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR2_Input_IC3F  -------------------------------
// SVD Line: 11867

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC3F
//    <name> IC3F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40012C1C) Input capture 3 filter Refer to IC1F[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Input >> 4) & 0xF), ((TIM1_CCMR2_Input = (TIM1_CCMR2_Input & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR2_Input_CC4S  -------------------------------
// SVD Line: 11875

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C1C) \nCapture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = '0 in TIMx_CCER).\n0 : B_0x0 = CC4 channel is configured as output\n1 : B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4\n2 : B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3\n3 : B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_CCMR2_Input ) </loc>
//      <o.9..8> CC4S
//        <0=> 0: B_0x0 = CC4 channel is configured as output
//        <1=> 1: B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4
//        <2=> 2: B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3
//        <3=> 3: B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR2_Input_IC4PSC  ------------------------------
// SVD Line: 11906

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC4PSC
//    <name> IC4PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x40012C1C) Input capture 4 prescaler Refer to IC1PSC[1:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Input >> 10) & 0x3), ((TIM1_CCMR2_Input = (TIM1_CCMR2_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_CCMR2_Input_IC4F  -------------------------------
// SVD Line: 11914

//  <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC4F
//    <name> IC4F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40012C1C) Input capture 4 filter Refer to IC1F[3:0] description. </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR2_Input >> 12) & 0xF), ((TIM1_CCMR2_Input = (TIM1_CCMR2_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM1_CCMR2_Input  --------------------------------
// SVD Line: 11817

//  <rtree> SFDITEM_REG__TIM1_CCMR2_Input
//    <name> CCMR2_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C1C) capture/compare mode register 2 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM1_CCMR2_Input >> 0) & 0xFFFFFFFF), ((TIM1_CCMR2_Input = (TIM1_CCMR2_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_CC3S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC3PSC </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC3F </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_CC4S </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC4PSC </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR2_Input_IC4F </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCER  -----------------------------
// SVD Line: 11924

unsigned int TIM1_TIM1_CCER __AT (0x40012C20);



// -----------------------------  Field Item: TIM1_TIM1_CCER_CC1E  --------------------------------
// SVD Line: 11934

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C20) \nCapture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details. Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = Capture mode disabled / OC1 is not active (see below)\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active (see below)
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC1P  --------------------------------
// SVD Line: 11955

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C20) \nCapture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: The configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC1NE  --------------------------------
// SVD Line: 11981

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1NE
//    <name> CC1NE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C20) \nCapture/Compare 1 complementary output enable On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.\n1 : B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.2..2> CC1NE
//        <0=> 0: B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//        <1=> 1: B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC1NP  --------------------------------
// SVD Line: 12001

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C20) \nCapture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (channel configured as output). On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1N active high.\n1 : B_0x1 = OC1N active low. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.3..3> CC1NP
//        <0=> 0: B_0x0 = OC1N active high.
//        <1=> 1: B_0x1 = OC1N active low.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC2E  --------------------------------
// SVD Line: 12025

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2E
//    <name> CC2E </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40012C20) Capture/Compare 2 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.4..4> CC2E
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC2P  --------------------------------
// SVD Line: 12033

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2P
//    <name> CC2P </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40012C20) Capture/Compare 2 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.5..5> CC2P
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC2NE  --------------------------------
// SVD Line: 12041

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2NE
//    <name> CC2NE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40012C20) Capture/Compare 2 complementary output enable Refer to CC1NE description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.6..6> CC2NE
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC2NP  --------------------------------
// SVD Line: 12049

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2NP
//    <name> CC2NP </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C20) Capture/Compare 2 complementary output polarity Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.7..7> CC2NP
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC3E  --------------------------------
// SVD Line: 12057

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3E
//    <name> CC3E </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40012C20) Capture/Compare 3 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.8..8> CC3E
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC3P  --------------------------------
// SVD Line: 12065

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3P
//    <name> CC3P </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C20) Capture/Compare 3 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.9..9> CC3P
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC3NE  --------------------------------
// SVD Line: 12073

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3NE
//    <name> CC3NE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C20) Capture/Compare 3 complementary output enable Refer to CC1NE description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.10..10> CC3NE
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC3NP  --------------------------------
// SVD Line: 12081

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3NP
//    <name> CC3NP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C20) Capture/Compare 3 complementary output polarity Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.11..11> CC3NP
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC4E  --------------------------------
// SVD Line: 12089

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4E
//    <name> CC4E </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012C20) Capture/Compare 4 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.12..12> CC4E
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC4P  --------------------------------
// SVD Line: 12097

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4P
//    <name> CC4P </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012C20) Capture/Compare 4 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.13..13> CC4P
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCER_CC4NP  --------------------------------
// SVD Line: 12105

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4NP
//    <name> CC4NP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C20) Capture/Compare 4 complementary output polarity Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.15..15> CC4NP
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC5E  --------------------------------
// SVD Line: 12113

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC5E
//    <name> CC5E </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C20) Capture/Compare 5 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.16..16> CC5E
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC5P  --------------------------------
// SVD Line: 12121

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC5P
//    <name> CC5P </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40012C20) Capture/Compare 5 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.17..17> CC5P
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC6E  --------------------------------
// SVD Line: 12129

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC6E
//    <name> CC6E </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40012C20) Capture/Compare 6 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.20..20> CC6E
//    </check>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_CCER_CC6P  --------------------------------
// SVD Line: 12137

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC6P
//    <name> CC6P </name>
//    <rw> 
//    <i> [Bit 21] RW (@ 0x40012C20) Capture/Compare 6 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCER ) </loc>
//      <o.21..21> CC6P
//    </check>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCER  ---------------------------------
// SVD Line: 11924

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCER
//    <name> TIM1_CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C20) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCER >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCER = (TIM1_TIM1_CCER & ~(0x33BFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x33BFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1NE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC1NP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2NE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC2NP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3NE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC3NP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC4NP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC5E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC5P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC6E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCER_CC6P </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CNT  ------------------------------
// SVD Line: 12147

unsigned int TIM1_TIM1_CNT __AT (0x40012C24);



// ------------------------------  Field Item: TIM1_TIM1_CNT_CNT  ---------------------------------
// SVD Line: 12155

//  <item> SFDITEM_FIELD__TIM1_TIM1_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C24) Counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CNT >> 0) & 0xFFFF), ((TIM1_TIM1_CNT = (TIM1_TIM1_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CNT_UIFCPY  --------------------------------
// SVD Line: 12162

//  <item> SFDITEM_FIELD__TIM1_TIM1_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40012C24) UIF copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_CNT  ---------------------------------
// SVD Line: 12147

//  <rtree> SFDITEM_REG__TIM1_TIM1_CNT
//    <name> TIM1_CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C24) counter </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CNT >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CNT = (TIM1_TIM1_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CNT_UIFCPY </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_PSC  ------------------------------
// SVD Line: 12172

unsigned int TIM1_TIM1_PSC __AT (0x40012C28);



// ------------------------------  Field Item: TIM1_TIM1_PSC_PSC  ---------------------------------
// SVD Line: 12181

//  <item> SFDITEM_FIELD__TIM1_TIM1_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C28) Prescaler value The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1). PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode). </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_PSC >> 0) & 0xFFFF), ((TIM1_TIM1_PSC = (TIM1_TIM1_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_PSC  ---------------------------------
// SVD Line: 12172

//  <rtree> SFDITEM_REG__TIM1_TIM1_PSC
//    <name> TIM1_PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C28) prescaler </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_PSC >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_PSC = (TIM1_TIM1_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_PSC_PSC </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_ARR  ------------------------------
// SVD Line: 12192

unsigned int TIM1_TIM1_ARR __AT (0x40012C2C);



// ------------------------------  Field Item: TIM1_TIM1_ARR_ARR  ---------------------------------
// SVD Line: 12201

//  <item> SFDITEM_FIELD__TIM1_TIM1_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C2C) Auto-reload value ARR is the value to be loaded in the actual auto-reload register. Refer to the for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null. </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_ARR >> 0) & 0xFFFF), ((TIM1_TIM1_ARR = (TIM1_TIM1_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_ARR  ---------------------------------
// SVD Line: 12192

//  <rtree> SFDITEM_REG__TIM1_TIM1_ARR
//    <name> TIM1_ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C2C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_ARR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_ARR = (TIM1_TIM1_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_ARR_ARR </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_RCR  ------------------------------
// SVD Line: 12213

unsigned int TIM1_TIM1_RCR __AT (0x40012C30);



// ------------------------------  Field Item: TIM1_TIM1_RCR_REP  ---------------------------------
// SVD Line: 12222

//  <item> SFDITEM_FIELD__TIM1_TIM1_RCR_REP
//    <name> REP </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C30) Repetition counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_RCR >> 0) & 0xFFFF), ((TIM1_TIM1_RCR = (TIM1_TIM1_RCR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_RCR  ---------------------------------
// SVD Line: 12213

//  <rtree> SFDITEM_REG__TIM1_TIM1_RCR
//    <name> TIM1_RCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C30) repetition counter register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_RCR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_RCR = (TIM1_TIM1_RCR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_RCR_REP </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR1  -----------------------------
// SVD Line: 12230

unsigned int TIM1_TIM1_CCR1 __AT (0x40012C34);



// -----------------------------  Field Item: TIM1_TIM1_CCR1_CCR1  --------------------------------
// SVD Line: 12239

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C34) Capture/Compare 1 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR1 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR1 = (TIM1_TIM1_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR1  ---------------------------------
// SVD Line: 12230

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR1
//    <name> TIM1_CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C34) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR1 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR1 = (TIM1_TIM1_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR1_CCR1 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR2  -----------------------------
// SVD Line: 12247

unsigned int TIM1_TIM1_CCR2 __AT (0x40012C38);



// -----------------------------  Field Item: TIM1_TIM1_CCR2_CCR2  --------------------------------
// SVD Line: 12256

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR2_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C38) Capture/Compare 2 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR2 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR2 = (TIM1_TIM1_CCR2 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR2  ---------------------------------
// SVD Line: 12247

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR2
//    <name> TIM1_CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C38) capture/compare register 2 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR2 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR2 = (TIM1_TIM1_CCR2 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR2_CCR2 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR3  -----------------------------
// SVD Line: 12264

unsigned int TIM1_TIM1_CCR3 __AT (0x40012C3C);



// -----------------------------  Field Item: TIM1_TIM1_CCR3_CCR3  --------------------------------
// SVD Line: 12273

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR3_CCR3
//    <name> CCR3 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C3C) Capture/Compare value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR3 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR3 = (TIM1_TIM1_CCR3 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR3  ---------------------------------
// SVD Line: 12264

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR3
//    <name> TIM1_CCR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C3C) capture/compare register 3 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR3 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR3 = (TIM1_TIM1_CCR3 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR3_CCR3 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR4  -----------------------------
// SVD Line: 12281

unsigned int TIM1_TIM1_CCR4 __AT (0x40012C40);



// -----------------------------  Field Item: TIM1_TIM1_CCR4_CCR4  --------------------------------
// SVD Line: 12290

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR4_CCR4
//    <name> CCR4 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C40) Capture/Compare value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR4 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR4 = (TIM1_TIM1_CCR4 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR4  ---------------------------------
// SVD Line: 12281

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR4
//    <name> TIM1_CCR4 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C40) capture/compare register 4 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR4 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR4 = (TIM1_TIM1_CCR4 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR4_CCR4 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_BDTR  -----------------------------
// SVD Line: 12298

unsigned int TIM1_TIM1_BDTR __AT (0x40012C44);



// -----------------------------  Field Item: TIM1_TIM1_BDTR_DTG  ---------------------------------
// SVD Line: 12307

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_DTG
//    <name> DTG </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40012C44) Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tDTG with tDTG=tDTS. DTG[7:5]=10x => DT=(64+DTG[5:0])xtDTG with tDTG=2xtDTS. DTG[7:5]=110 => DT=(32+DTG[4:0])xtDTG with tDTG=8xtDTS. DTG[7:5]=111 => DT=(32+DTG[4:0])xtDTG with tDTG=16xtDTS. Example if tDTS=125ns (8MHz), dead-time possible values are: 0 to 15875ns by 125ns steps, 16s to 31750ns by 250ns steps, 32s to 63s by 1s steps, 64s to 126s by 2s steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_TIM1_BDTR >> 0) & 0xFF), ((TIM1_TIM1_BDTR = (TIM1_TIM1_BDTR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_LOCK  --------------------------------
// SVD Line: 12325

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_LOCK
//    <name> LOCK </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40012C44) \nLock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.\n0 : B_0x0 = LOCK OFF - No bit is write protected.\n1 : B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits in TIMx_BDTR register can no longer be written.\n2 : B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.\n3 : B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.9..8> LOCK
//        <0=> 0: B_0x0 = LOCK OFF - No bit is write protected.
//        <1=> 1: B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] bits in TIMx_BDTR register can no longer be written.
//        <2=> 2: B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
//        <3=> 3: B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_OSSI  --------------------------------
// SVD Line: 12356

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_OSSI
//    <name> OSSI </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C44) \nOff-state selection for Idle mode This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state).\n1 : B_0x1 = When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.10..10> OSSI
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic and which imposes a Hi-Z state).
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_OSSR  --------------------------------
// SVD Line: 12378

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_OSSR
//    <name> OSSR </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C44) \nOff-state selection for Run mode This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state).\n1 : B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.11..11> OSSR
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the GPIO logic, which forces a Hi-Z state).
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BKE  ---------------------------------
// SVD Line: 12400

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKE
//    <name> BKE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40012C44) \nBreak enable This bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per ). Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break function disabled\n1 : B_0x1 = Break function enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.12..12> BKE
//        <0=> 0: B_0x0 = Break function disabled
//        <1=> 1: B_0x1 = Break function enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BKP  ---------------------------------
// SVD Line: 12422

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKP
//    <name> BKP </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40012C44) \nBreak polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is active low\n1 : B_0x1 = Break input BRK is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.13..13> BKP
//        <0=> 0: B_0x0 = Break input BRK is active low
//        <1=> 1: B_0x1 = Break input BRK is active high
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_AOE  ---------------------------------
// SVD Line: 12443

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_AOE
//    <name> AOE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40012C44) \nAutomatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = MOE can be set only by software\n1 : B_0x1 = MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.14..14> AOE
//        <0=> 0: B_0x0 = MOE can be set only by software
//        <1=> 1: B_0x1 = MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_MOE  ---------------------------------
// SVD Line: 12463

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_MOE
//    <name> MOE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C44) \nMain output enable This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit. See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).\n0 : B_0x0 = In response to a break 2 event. OC and OCN outputs are disabled\n1 : B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.15..15> MOE
//        <0=> 0: B_0x0 = In response to a break 2 event. OC and OCN outputs are disabled
//        <1=> 1: B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BKF  ---------------------------------
// SVD Line: 12485

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKF
//    <name> BKF </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40012C44) \nBreak filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = No filter, BRK acts asynchronously\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.19..16> BKF
//        <0=> 0: B_0x0 = No filter, BRK acts asynchronously
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BK2F  --------------------------------
// SVD Line: 12576

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2F
//    <name> BK2F </name>
//    <rw> 
//    <i> [Bits 23..20] RW (@ 0x40012C44) \nBreak 2 filter This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = No filter, BRK2 acts asynchronously\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.23..20> BK2F
//        <0=> 0: B_0x0 = No filter, BRK2 acts asynchronously
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BK2E  --------------------------------
// SVD Line: 12667

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2E
//    <name> BK2E </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012C44) \nBreak 2 enable Note: The BRK2 must only be used with OSSR = OSSI = 1. Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK2 disabled\n1 : B_0x1 = Break input BRK2 enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.24..24> BK2E
//        <0=> 0: B_0x0 = Break input BRK2 disabled
//        <1=> 1: B_0x1 = Break input BRK2 enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_BDTR_BK2P  --------------------------------
// SVD Line: 12689

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2P
//    <name> BK2P </name>
//    <rw> 
//    <i> [Bit 25] RW (@ 0x40012C44) \nBreak 2 polarity Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK2 is active low\n1 : B_0x1 = Break input BRK2 is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.25..25> BK2P
//        <0=> 0: B_0x0 = Break input BRK2 is active low
//        <1=> 1: B_0x1 = Break input BRK2 is active high
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_BDTR_BKDSRM  -------------------------------
// SVD Line: 12710

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKDSRM
//    <name> BKDSRM </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40012C44) \nBreak Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is armed\n1 : B_0x1 = Break input BRK is disarmed </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.26..26> BKDSRM
//        <0=> 0: B_0x0 = Break input BRK is armed
//        <1=> 1: B_0x1 = Break input BRK is disarmed
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_BDTR_BK2DSRM  -------------------------------
// SVD Line: 12732

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2DSRM
//    <name> BK2DSRM </name>
//    <rw> 
//    <i> [Bit 27] RW (@ 0x40012C44) Break2 Disarm Refer to BKDSRM description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.27..27> BK2DSRM
//    </check>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_BDTR_BKBID  --------------------------------
// SVD Line: 12740

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKBID
//    <name> BKBID </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40012C44) \nBreak Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK in input mode\n1 : B_0x1 = Break input BRK in bidirectional mode </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.28..28> BKBID
//        <0=> 0: B_0x0 = Break input BRK in input mode
//        <1=> 1: B_0x1 = Break input BRK in bidirectional mode
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_BDTR_BK2BID  -------------------------------
// SVD Line: 12762

//  <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2BID
//    <name> BK2BID </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40012C44) Break2 bidirectional Refer to BKBID description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_TIM1_BDTR ) </loc>
//      <o.29..29> BK2BID
//    </check>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_BDTR  ---------------------------------
// SVD Line: 12298

//  <rtree> SFDITEM_REG__TIM1_TIM1_BDTR
//    <name> TIM1_BDTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C44) break and dead-time register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_BDTR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_BDTR = (TIM1_TIM1_BDTR & ~(0x3FFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_DTG </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_LOCK </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_OSSI </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_OSSR </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_AOE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_MOE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKF </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2F </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKDSRM </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2DSRM </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BKBID </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_BDTR_BK2BID </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_DCR  ------------------------------
// SVD Line: 12772

unsigned int TIM1_TIM1_DCR __AT (0x40012C48);



// ------------------------------  Field Item: TIM1_TIM1_DCR_DBA  ---------------------------------
// SVD Line: 12781

//  <item> SFDITEM_FIELD__TIM1_TIM1_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40012C48) \nDMA base address This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ...\n0 : B_0x0 = TIMx_CR1,\n1 : B_0x1 = TIMx_CR2,\n2 : B_0x2 = TIMx_SMCR,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1,
//        <1=> 1: B_0x1 = TIMx_CR2,
//        <2=> 2: B_0x2 = TIMx_SMCR,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM1_TIM1_DCR_DBL  ---------------------------------
// SVD Line: 12808

//  <item> SFDITEM_FIELD__TIM1_TIM1_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40012C48) \nDMA burst length This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ... Example: Let us consider the following transfer: DBL = 7 bytes & DBA = TIMx_CR1. If DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation: (TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA According to the configuration of the DMA Data Size, several cases may occur: If the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers. If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.\n0 : B_0x0 = 1 transfer\n1 : B_0x1 = 2 transfers\n2 : B_0x2 = 3 transfers\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer
//        <1=> 1: B_0x1 = 2 transfers
//        <2=> 2: B_0x2 = 3 transfers
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_DCR  ---------------------------------
// SVD Line: 12772

//  <rtree> SFDITEM_REG__TIM1_TIM1_DCR
//    <name> TIM1_DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C48) DMA control register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_DCR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_DCR = (TIM1_TIM1_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DCR_DBL </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_DMAR  -----------------------------
// SVD Line: 12848

unsigned int TIM1_TIM1_DMAR __AT (0x40012C4C);



// -----------------------------  Field Item: TIM1_TIM1_DMAR_DMAB  --------------------------------
// SVD Line: 12857

//  <item> SFDITEM_FIELD__TIM1_TIM1_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C4C) DMA register for burst accesses  A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4  where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR). </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM1_TIM1_DMAR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_DMAR = (TIM1_TIM1_DMAR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_DMAR  ---------------------------------
// SVD Line: 12848

//  <rtree> SFDITEM_REG__TIM1_TIM1_DMAR
//    <name> TIM1_DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C4C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_DMAR >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_DMAR = (TIM1_TIM1_DMAR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_DMAR_DMAB </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_OR1  ------------------------------
// SVD Line: 12868

unsigned int TIM1_TIM1_OR1 __AT (0x40012C50);



// ---------------------------  Field Item: TIM1_TIM1_OR1_OCREF_CLR  ------------------------------
// SVD Line: 12877

//  <item> SFDITEM_FIELD__TIM1_TIM1_OR1_OCREF_CLR
//    <name> OCREF_CLR </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C50) \nOcref_clr source selection This bit selects the ocref_clr input source.\n0 : B_0x0 = COMP1 output is connected to the OCREF_CLR input\n1 : B_0x1 = COMP2 output is connected to the OCREF_CLR input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_OR1 ) </loc>
//      <o.0..0> OCREF_CLR
//        <0=> 0: B_0x0 = COMP1 output is connected to the OCREF_CLR input
//        <1=> 1: B_0x1 = COMP2 output is connected to the OCREF_CLR input
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_OR1  ---------------------------------
// SVD Line: 12868

//  <rtree> SFDITEM_REG__TIM1_TIM1_OR1
//    <name> TIM1_OR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C50) option register 1 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_OR1 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_OR1 = (TIM1_TIM1_OR1 & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_OR1_OCREF_CLR </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM1_CCMR3_Output  ----------------------------
// SVD Line: 12899

unsigned int TIM1_CCMR3_Output __AT (0x40012C54);



// -------------------------  Field Item: TIM1_CCMR3_Output_OC6M_bit3  ----------------------------
// SVD Line: 12909

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6M_bit3
//    <name> OC6M_bit3 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40012C54) Output Compare 6 mode bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.24..24> OC6M_bit3
//    </check>
//  </item>
//  


// -------------------------  Field Item: TIM1_CCMR3_Output_OC5M_bit3  ----------------------------
// SVD Line: 12916

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5M_bit3
//    <name> OC5M_bit3 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40012C54) Output Compare 5 mode bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.16..16> OC5M_bit3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC6CE  ------------------------------
// SVD Line: 12923

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6CE
//    <name> OC6CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40012C54) Output compare 6 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.15..15> OC6CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC6M  -------------------------------
// SVD Line: 12930

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6M
//    <name> OC6M </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40012C54) Output compare 6 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR3_Output >> 12) & 0x7), ((TIM1_CCMR3_Output = (TIM1_CCMR3_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC6PE  ------------------------------
// SVD Line: 12936

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6PE
//    <name> OC6PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C54) Output compare 6 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.11..11> OC6PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC6FE  ------------------------------
// SVD Line: 12943

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6FE
//    <name> OC6FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C54) Output compare 6 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.10..10> OC6FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC5CE  ------------------------------
// SVD Line: 12950

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5CE
//    <name> OC5CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40012C54) Output compare 5 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.7..7> OC5CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC5M  -------------------------------
// SVD Line: 12957

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5M
//    <name> OC5M </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40012C54) Output compare 5 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM1_CCMR3_Output >> 4) & 0x7), ((TIM1_CCMR3_Output = (TIM1_CCMR3_Output & ~(0x7UL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC5PE  ------------------------------
// SVD Line: 12963

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5PE
//    <name> OC5PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40012C54) Output compare 5 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.3..3> OC5PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM1_CCMR3_Output_OC5FE  ------------------------------
// SVD Line: 12970

//  <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5FE
//    <name> OC5FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C54) Output compare 5 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM1_CCMR3_Output ) </loc>
//      <o.2..2> OC5FE
//    </check>
//  </item>
//  


// ----------------------------  Register RTree: TIM1_CCMR3_Output  -------------------------------
// SVD Line: 12899

//  <rtree> SFDITEM_REG__TIM1_CCMR3_Output
//    <name> CCMR3_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C54) capture/compare mode register 2 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM1_CCMR3_Output >> 0) & 0xFFFFFFFF), ((TIM1_CCMR3_Output = (TIM1_CCMR3_Output & ~(0x101FCFCUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FCFC) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6M_bit3 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5M_bit3 </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6M </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC6FE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5CE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5M </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5PE </item>
//    <item> SFDITEM_FIELD__TIM1_CCMR3_Output_OC5FE </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR5  -----------------------------
// SVD Line: 12979

unsigned int TIM1_TIM1_CCR5 __AT (0x40012C58);



// -----------------------------  Field Item: TIM1_TIM1_CCR5_CCR5  --------------------------------
// SVD Line: 12988

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_CCR5
//    <name> CCR5 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C58) Capture/Compare 5 value CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output. </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR5 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR5 = (TIM1_TIM1_CCR5 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCR5_GC5C1  --------------------------------
// SVD Line: 12998

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C1
//    <name> GC5C1 </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40012C58) \nGroup Channel 5 and Channel 1 Distortion on Channel 1 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.\n0 : B_0x0 = No effect of OC5REF on OC1REFC5\n1 : B_0x1 = OC1REFC is the logical AND of OC1REFC and OC5REF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCR5 ) </loc>
//      <o.29..29> GC5C1
//        <0=> 0: B_0x0 = No effect of OC5REF on OC1REFC5
//        <1=> 1: B_0x1 = OC1REFC is the logical AND of OC1REFC and OC5REF
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCR5_GC5C2  --------------------------------
// SVD Line: 13020

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C2
//    <name> GC5C2 </name>
//    <rw> 
//    <i> [Bit 30] RW (@ 0x40012C58) \nGroup Channel 5 and Channel 2 Distortion on Channel 2 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1). Note: it is also possible to apply this distortion on combined PWM signals.\n0 : B_0x0 = No effect of OC5REF on OC2REFC\n1 : B_0x1 = OC2REFC is the logical AND of OC2REFC and OC5REF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCR5 ) </loc>
//      <o.30..30> GC5C2
//        <0=> 0: B_0x0 = No effect of OC5REF on OC2REFC
//        <1=> 1: B_0x1 = OC2REFC is the logical AND of OC2REFC and OC5REF
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_CCR5_GC5C3  --------------------------------
// SVD Line: 13042

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C3
//    <name> GC5C3 </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40012C58) \nGroup Channel 5 and Channel 3 Distortion on Channel 3 output: This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2). Note: it is also possible to apply this distortion on combined PWM signals.\n0 : B_0x0 = No effect of OC5REF on OC3REFC\n1 : B_0x1 = OC3REFC is the logical AND of OC3REFC and OC5REF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_CCR5 ) </loc>
//      <o.31..31> GC5C3
//        <0=> 0: B_0x0 = No effect of OC5REF on OC3REFC
//        <1=> 1: B_0x1 = OC3REFC is the logical AND of OC3REFC and OC5REF
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR5  ---------------------------------
// SVD Line: 12979

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR5
//    <name> TIM1_CCR5 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C58) capture/compare register 4 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR5 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR5 = (TIM1_TIM1_CCR5 & ~(0xE000FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE000FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_CCR5 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C1 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C2 </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR5_GC5C3 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_CCR6  -----------------------------
// SVD Line: 13066

unsigned int TIM1_TIM1_CCR6 __AT (0x40012C5C);



// -----------------------------  Field Item: TIM1_TIM1_CCR6_CCR6  --------------------------------
// SVD Line: 13075

//  <item> SFDITEM_FIELD__TIM1_TIM1_CCR6_CCR6
//    <name> CCR6 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40012C5C) Capture/Compare value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM1_TIM1_CCR6 >> 0) & 0xFFFF), ((TIM1_TIM1_CCR6 = (TIM1_TIM1_CCR6 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_CCR6  ---------------------------------
// SVD Line: 13066

//  <rtree> SFDITEM_REG__TIM1_TIM1_CCR6
//    <name> TIM1_CCR6 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C5C) capture/compare register 4 </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_CCR6 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_CCR6 = (TIM1_TIM1_CCR6 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_CCR6_CCR6 </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_AF1  ------------------------------
// SVD Line: 13083

unsigned int TIM1_TIM1_AF1 __AT (0x40012C60);



// -----------------------------  Field Item: TIM1_TIM1_AF1_BKINE  --------------------------------
// SVD Line: 13092

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKINE
//    <name> BKINE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C60) \nBRK BKIN input enable This bit enables the BKIN alternate function input for the timers BRK input. BKIN input is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input disabled\n1 : B_0x1 = BKIN input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.0..0> BKINE
//        <0=> 0: B_0x0 = BKIN input disabled
//        <1=> 1: B_0x1 = BKIN input enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF1_BKCMP1E  -------------------------------
// SVD Line: 13113

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP1E
//    <name> BKCMP1E </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C60) \nBRK COMP1 enable This bit enables the COMP1 for the timers BRK input. COMP1 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input disabled\n1 : B_0x1 = COMP1 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.1..1> BKCMP1E
//        <0=> 0: B_0x0 = COMP1 input disabled
//        <1=> 1: B_0x1 = COMP1 input enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF1_BKCMP2E  -------------------------------
// SVD Line: 13134

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP2E
//    <name> BKCMP2E </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C60) \nBRK COMP2 enable This bit enables the COMP2 for the timers BRK input. COMP2 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input disabled\n1 : B_0x1 = COMP2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.2..2> BKCMP2E
//        <0=> 0: B_0x0 = COMP2 input disabled
//        <1=> 1: B_0x1 = COMP2 input enabled
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM1_TIM1_AF1_BKINP  --------------------------------
// SVD Line: 13155

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKINP
//    <name> BKINP </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C60) \nBRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)\n1 : B_0x1 = BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.9..9> BKINP
//        <0=> 0: B_0x0 = BKIN input polarity is not inverted (active low if BKP=0, active high if BKP=1)
//        <1=> 1: B_0x1 = BKIN input polarity is inverted (active high if BKP=0, active low if BKP=1)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF1_BKCMP1P  -------------------------------
// SVD Line: 13176

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP1P
//    <name> BKCMP1P </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C60) \nBRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input polarity is not inverted (active low if BKP=0, active high if BKP=1)\n1 : B_0x1 = COMP1 input polarity is inverted (active high if BKP=0, active low if BKP=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.10..10> BKCMP1P
//        <0=> 0: B_0x0 = COMP1 input polarity is not inverted (active low if BKP=0, active high if BKP=1)
//        <1=> 1: B_0x1 = COMP1 input polarity is inverted (active high if BKP=0, active low if BKP=1)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF1_BKCMP2P  -------------------------------
// SVD Line: 13197

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP2P
//    <name> BKCMP2P </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C60) \nBRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input polarity is not inverted (active low if BKP=0, active high if BKP=1)\n1 : B_0x1 = COMP2 input polarity is inverted (active high if BKP=0, active low if BKP=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.11..11> BKCMP2P
//        <0=> 0: B_0x0 = COMP2 input polarity is not inverted (active low if BKP=0, active high if BKP=1)
//        <1=> 1: B_0x1 = COMP2 input polarity is inverted (active high if BKP=0, active low if BKP=1)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF1_ETRSEL  --------------------------------
// SVD Line: 13218

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF1_ETRSEL
//    <name> ETRSEL </name>
//    <rw> 
//    <i> [Bits 17..14] RW (@ 0x40012C60) \nETR source selection These bits select the ETR input source. Others: Reserved Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = ETR legacy mode\n1 : B_0x1 = COMP1 output\n2 : B_0x2 = COMP2 output\n3 : B_0x3 = ADC1 AWD1\n4 : B_0x4 = ADC1 AWD2\n5 : B_0x5 = ADC1 AWD3\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF1 ) </loc>
//      <o.17..14> ETRSEL
//        <0=> 0: B_0x0 = ETR legacy mode
//        <1=> 1: B_0x1 = COMP1 output
//        <2=> 2: B_0x2 = COMP2 output
//        <3=> 3: B_0x3 = ADC1 AWD1
//        <4=> 4: B_0x4 = ADC1 AWD2
//        <5=> 5: B_0x5 = ADC1 AWD3
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_AF1  ---------------------------------
// SVD Line: 13083

//  <rtree> SFDITEM_REG__TIM1_TIM1_AF1
//    <name> TIM1_AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C60) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_AF1 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_AF1 = (TIM1_TIM1_AF1 & ~(0x3CE07UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3CE07) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKINE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP1E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP2E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKINP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP1P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_BKCMP2P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF1_ETRSEL </item>
//  </rtree>
//  


// --------------------------  Register Item Address: TIM1_TIM1_AF2  ------------------------------
// SVD Line: 13262

unsigned int TIM1_TIM1_AF2 __AT (0x40012C64);



// ----------------------------  Field Item: TIM1_TIM1_AF2_BK2INE  --------------------------------
// SVD Line: 13271

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2INE
//    <name> BK2INE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40012C64) \nBRK2 BKIN input enable This bit enables the BKIN2 alternate function input for the timers BRK2 input. BKIN2 input is 'ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN2 input disabled\n1 : B_0x1 = BKIN2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.0..0> BK2INE
//        <0=> 0: B_0x0 = BKIN2 input disabled
//        <1=> 1: B_0x1 = BKIN2 input enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_AF2_BK2CMP1E  -------------------------------
// SVD Line: 13292

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP1E
//    <name> BK2CMP1E </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40012C64) \nBRK2 COMP1 enable This bit enables the COMP1 for the timers BRK2 input. COMP1 output is 'ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input disabled\n1 : B_0x1 = COMP1 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.1..1> BK2CMP1E
//        <0=> 0: B_0x0 = COMP1 input disabled
//        <1=> 1: B_0x1 = COMP1 input enabled
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_AF2_BK2CMP2E  -------------------------------
// SVD Line: 13313

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP2E
//    <name> BK2CMP2E </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40012C64) \nBRK2 COMP2 enable This bit enables the COMP2 for the timers BRK2 input. COMP2 output is 'ORed with the other BRK2 sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input disabled\n1 : B_0x1 = COMP2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.2..2> BK2CMP2E
//        <0=> 0: B_0x0 = COMP2 input disabled
//        <1=> 1: B_0x1 = COMP2 input enabled
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM1_TIM1_AF2_BK2INP  --------------------------------
// SVD Line: 13334

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2INP
//    <name> BK2INP </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40012C64) \nBRK2 BKIN2 input polarity This bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)\n1 : B_0x1 = BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.9..9> BK2INP
//        <0=> 0: B_0x0 = BKIN2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
//        <1=> 1: B_0x1 = BKIN2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_AF2_BK2CMP1P  -------------------------------
// SVD Line: 13355

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP1P
//    <name> BK2CMP1P </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40012C64) \nBRK2 COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)\n1 : B_0x1 = COMP1 input polarity is inverted (active high if BK2P=0, active low if BK2P=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.10..10> BK2CMP1P
//        <0=> 0: B_0x0 = COMP1 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
//        <1=> 1: B_0x1 = COMP1 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_AF2_BK2CMP2P  -------------------------------
// SVD Line: 13376

//  <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP2P
//    <name> BK2CMP2P </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40012C64) \nBRK2 COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BK2P polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)\n1 : B_0x1 = COMP2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_AF2 ) </loc>
//      <o.11..11> BK2CMP2P
//        <0=> 0: B_0x0 = COMP2 input polarity is not inverted (active low if BK2P=0, active high if BK2P=1)
//        <1=> 1: B_0x1 = COMP2 input polarity is inverted (active high if BK2P=0, active low if BK2P=1)
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: TIM1_TIM1_AF2  ---------------------------------
// SVD Line: 13262

//  <rtree> SFDITEM_REG__TIM1_TIM1_AF2
//    <name> TIM1_AF2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C64) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_AF2 >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_AF2 = (TIM1_TIM1_AF2 & ~(0xE07UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE07) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2INE </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP1E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP2E </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2INP </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP1P </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_AF2_BK2CMP2P </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM1_TIM1_TISEL  -----------------------------
// SVD Line: 13399

unsigned int TIM1_TIM1_TISEL __AT (0x40012C68);



// ---------------------------  Field Item: TIM1_TIM1_TISEL_TI1SEL  -------------------------------
// SVD Line: 13409

//  <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40012C68) \nselects TI1[0] to TI1[15] input Others: Reserved\n0 : B_0x0 = TIM1_CH1 input\n1 : B_0x1 = COMP1 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM1_CH1 input
//        <1=> 1: B_0x1 = COMP1 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_TISEL_TI2SEL  -------------------------------
// SVD Line: 13429

//  <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI2SEL
//    <name> TI2SEL </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40012C68) \nselects TI2[0] to TI2[15] input Others: Reserved\n0 : B_0x0 = TIM1_CH2 input\n1 : B_0x1 = COMP2 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_TISEL ) </loc>
//      <o.11..8> TI2SEL
//        <0=> 0: B_0x0 = TIM1_CH2 input
//        <1=> 1: B_0x1 = COMP2 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_TISEL_TI3SEL  -------------------------------
// SVD Line: 13449

//  <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI3SEL
//    <name> TI3SEL </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40012C68) \nselects TI3[0] to TI3[15] input Others: Reserved\n0 : B_0x0 = TIM1_CH3 input\n1 : Reserved - do not use\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_TISEL ) </loc>
//      <o.19..16> TI3SEL
//        <0=> 0: B_0x0 = TIM1_CH3 input
//        <1=> 1: 
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM1_TIM1_TISEL_TI4SEL  -------------------------------
// SVD Line: 13464

//  <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI4SEL
//    <name> TI4SEL </name>
//    <rw> 
//    <i> [Bits 27..24] RW (@ 0x40012C68) \nselects TI4[0] to TI4[15] input Others: Reserved\n0 : B_0x0 = TIM1_CH4 input\n1 : Reserved - do not use\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM1_TIM1_TISEL ) </loc>
//      <o.27..24> TI4SEL
//        <0=> 0: B_0x0 = TIM1_CH4 input
//        <1=> 1: 
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -----------------------------  Register RTree: TIM1_TIM1_TISEL  --------------------------------
// SVD Line: 13399

//  <rtree> SFDITEM_REG__TIM1_TIM1_TISEL
//    <name> TIM1_TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40012C68) TIM1 timer input selection  register </i>
//    <loc> ( (unsigned int)((TIM1_TIM1_TISEL >> 0) & 0xFFFFFFFF), ((TIM1_TIM1_TISEL = (TIM1_TIM1_TISEL & ~(0xF0F0F0FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0F0F0F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI1SEL </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI2SEL </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI3SEL </item>
//    <item> SFDITEM_FIELD__TIM1_TIM1_TISEL_TI4SEL </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: TIM1  -------------------------------------
// SVD Line: 9416

//  <view> TIM1
//    <name> TIM1 </name>
//    <item> SFDITEM_REG__TIM1_TIM1_CR1 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CR2 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_SMCR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_DIER </item>
//    <item> SFDITEM_REG__TIM1_TIM1_SR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_EGR </item>
//    <item> SFDITEM_REG__TIM1_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM1_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM1_CCMR2_Output </item>
//    <item> SFDITEM_REG__TIM1_CCMR2_Input </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCER </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CNT </item>
//    <item> SFDITEM_REG__TIM1_TIM1_PSC </item>
//    <item> SFDITEM_REG__TIM1_TIM1_ARR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_RCR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR1 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR2 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR3 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR4 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_BDTR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_DCR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_DMAR </item>
//    <item> SFDITEM_REG__TIM1_TIM1_OR1 </item>
//    <item> SFDITEM_REG__TIM1_CCMR3_Output </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR5 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_CCR6 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_AF1 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_AF2 </item>
//    <item> SFDITEM_REG__TIM1_TIM1_TISEL </item>
//  </view>
//  


// -----------------------------  Register Item Address: TIM2_CR1  --------------------------------
// SVD Line: 13499

unsigned int TIM2_CR1 __AT (0x40000000);



// --------------------------------  Field Item: TIM2_CR1_CEN  ------------------------------------
// SVD Line: 13508

//  <item> SFDITEM_FIELD__TIM2_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000000) \nCounter enable Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_UDIS  -----------------------------------
// SVD Line: 13529

//  <item> SFDITEM_FIELD__TIM2_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000000) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_URS  ------------------------------------
// SVD Line: 13553

//  <item> SFDITEM_FIELD__TIM2_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000000) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_OPM  ------------------------------------
// SVD Line: 13576

//  <item> SFDITEM_FIELD__TIM2_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000000) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_DIR  ------------------------------------
// SVD Line: 13595

//  <item> SFDITEM_FIELD__TIM2_CR1_DIR
//    <name> DIR </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000000) \nDirection Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.\n0 : B_0x0 = Counter used as upcounter\n1 : B_0x1 = Counter used as downcounter </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.4..4> DIR
//        <0=> 0: B_0x0 = Counter used as upcounter
//        <1=> 1: B_0x1 = Counter used as downcounter
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_CMS  ------------------------------------
// SVD Line: 13615

//  <item> SFDITEM_FIELD__TIM2_CR1_CMS
//    <name> CMS </name>
//    <rw> 
//    <i> [Bits 6..5] RW (@ 0x40000000) \nCenter-aligned mode selection Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)\n0 : B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).\n1 : B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.\n2 : B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.\n3 : B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.6..5> CMS
//        <0=> 0: B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
//        <1=> 1: B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.
//        <2=> 2: B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.
//        <3=> 3: B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_ARPE  -----------------------------------
// SVD Line: 13645

//  <item> SFDITEM_FIELD__TIM2_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000000) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR1_CKD  ------------------------------------
// SVD Line: 13664

//  <item> SFDITEM_FIELD__TIM2_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000000) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),\n0 : B_0x0 = tDTS = tCK_INT\n1 : B_0x1 = tDTS = 2  tCK_INT\n2 : B_0x2 = tDTS = 4  tCK_INT\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS = tCK_INT
//        <1=> 1: B_0x1 = tDTS = 2  tCK_INT
//        <2=> 2: B_0x2 = tDTS = 4  tCK_INT
//        <3=> 3: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM2_CR1_UIFREMAP  ---------------------------------
// SVD Line: 13689

//  <item> SFDITEM_FIELD__TIM2_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000000) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CR1  ------------------------------------
// SVD Line: 13499

//  <rtree> SFDITEM_REG__TIM2_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000000) control register 1 </i>
//    <loc> ( (unsigned int)((TIM2_CR1 >> 0) & 0xFFFFFFFF), ((TIM2_CR1 = (TIM2_CR1 & ~(0xBFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_DIR </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_CMS </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM2_CR1_UIFREMAP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_CR2  --------------------------------
// SVD Line: 13710

unsigned int TIM2_CR2 __AT (0x40000004);



// --------------------------------  Field Item: TIM2_CR2_CCDS  -----------------------------------
// SVD Line: 13719

//  <item> SFDITEM_FIELD__TIM2_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000004) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR2_MMS  ------------------------------------
// SVD Line: 13738

//  <item> SFDITEM_FIELD__TIM2_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000004) \nMaster mode selection These bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.\n2 : B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)\n4 : B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)\n5 : B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)\n6 : B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)\n7 : B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.
//        <2=> 2: B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
//        <4=> 4: B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)
//        <5=> 5: B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)
//        <6=> 6: B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)
//        <7=> 7: B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_CR2_TI1S  -----------------------------------
// SVD Line: 13790

//  <item> SFDITEM_FIELD__TIM2_CR2_TI1S
//    <name> TI1S </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000004) \nTI1 selection\n0 : B_0x0 = The TIMx_CH1 pin is connected to TI1 input\n1 : B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CR2 ) </loc>
//      <o.7..7> TI1S
//        <0=> 0: B_0x0 = The TIMx_CH1 pin is connected to TI1 input
//        <1=> 1: B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CR2  ------------------------------------
// SVD Line: 13710

//  <rtree> SFDITEM_REG__TIM2_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000004) control register 2 </i>
//    <loc> ( (unsigned int)((TIM2_CR2 >> 0) & 0xFFFFFFFF), ((TIM2_CR2 = (TIM2_CR2 & ~(0xF8UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF8) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM2_CR2_MMS </item>
//    <item> SFDITEM_FIELD__TIM2_CR2_TI1S </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_SMCR  --------------------------------
// SVD Line: 13811

unsigned int TIM2_SMCR __AT (0x40000008);



// -------------------------------  Field Item: TIM2_SMCR_SMS1  -----------------------------------
// SVD Line: 13820

//  <item> SFDITEM_FIELD__TIM2_SMCR_SMS1
//    <name> SMS1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40000008) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. reinitializes the counter, generates an update of the registers and starts the counter. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.\n2 : B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.\n3 : B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.\n4 : B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.\n5 : B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.\n6 : B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.\n7 : B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.2..0> SMS1
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//        <2=> 2: B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
//        <3=> 3: B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
//        <4=> 4: B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
//        <5=> 5: B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
//        <6=> 6: B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
//        <7=> 7: B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_SMCR_OCCS  -----------------------------------
// SVD Line: 13878

//  <item> SFDITEM_FIELD__TIM2_SMCR_OCCS
//    <name> OCCS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000008) \nOCREF clear selection This bit is used to select the OCREF clear source\n0 : B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.OCREF_CLR\n1 : B_0x1 = OCREF_CLR_INT is connected to ETRF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.3..3> OCCS
//        <0=> 0: B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.OCREF_CLR
//        <1=> 1: B_0x1 = OCREF_CLR_INT is connected to ETRF
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_TS1  -----------------------------------
// SVD Line: 13898

//  <item> SFDITEM_FIELD__TIM2_SMCR_TS1
//    <name> TS1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000008) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3)\n4 : B_0x4 = TI1 Edge Detector (TI1F_ED)\n5 : B_0x5 = Filtered Timer Input 1 (TI1FP1)\n6 : B_0x6 = Filtered Timer Input 2 (TI2FP2)\n7 : B_0x7 = External Trigger input (ETRF) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.6..4> TS1
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//        <4=> 4: B_0x4 = TI1 Edge Detector (TI1F_ED)
//        <5=> 5: B_0x5 = Filtered Timer Input 1 (TI1FP1)
//        <6=> 6: B_0x6 = Filtered Timer Input 2 (TI2FP2)
//        <7=> 7: B_0x7 = External Trigger input (ETRF)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_MSM  -----------------------------------
// SVD Line: 13976

//  <item> SFDITEM_FIELD__TIM2_SMCR_MSM
//    <name> MSM </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000008) \nMaster/Slave mode\n0 : B_0x0 = No action\n1 : B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.7..7> MSM
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_ETF  -----------------------------------
// SVD Line: 13995

//  <item> SFDITEM_FIELD__TIM2_SMCR_ETF
//    <name> ETF </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40000008) \nExternal trigger filter This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.11..8> ETF
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_SMCR_ETPS  -----------------------------------
// SVD Line: 14085

//  <item> SFDITEM_FIELD__TIM2_SMCR_ETPS
//    <name> ETPS </name>
//    <rw> 
//    <i> [Bits 13..12] RW (@ 0x40000008) \nExternal trigger prescaler External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.\n0 : B_0x0 = Prescaler OFF\n1 : B_0x1 = ETRP frequency divided by 2\n2 : B_0x2 = ETRP frequency divided by 4\n3 : B_0x3 = ETRP frequency divided by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.13..12> ETPS
//        <0=> 0: B_0x0 = Prescaler OFF
//        <1=> 1: B_0x1 = ETRP frequency divided by 2
//        <2=> 2: B_0x2 = ETRP frequency divided by 4
//        <3=> 3: B_0x3 = ETRP frequency divided by 8
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_ECE  -----------------------------------
// SVD Line: 14115

//  <item> SFDITEM_FIELD__TIM2_SMCR_ECE
//    <name> ECE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40000008) \nExternal clock enable This bit enables External clock mode 2. Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111). If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.\n0 : B_0x0 = External clock mode 2 disabled\n1 : B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.14..14> ECE
//        <0=> 0: B_0x0 = External clock mode 2 disabled
//        <1=> 1: B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_ETP  -----------------------------------
// SVD Line: 14138

//  <item> SFDITEM_FIELD__TIM2_SMCR_ETP
//    <name> ETP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000008) \nExternal trigger polarity This bit selects whether ETR or ETR is used for trigger operations\n0 : B_0x0 = ETR is non-inverted, active at high level or rising edge\n1 : B_0x1 = ETR is inverted, active at low level or falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.15..15> ETP
//        <0=> 0: B_0x0 = ETR is non-inverted, active at high level or rising edge
//        <1=> 1: B_0x1 = ETR is inverted, active at low level or falling edge
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_SMCR_SMS2  -----------------------------------
// SVD Line: 14158

//  <item> SFDITEM_FIELD__TIM2_SMCR_SMS2
//    <name> SMS2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40000008) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. reinitializes the counter, generates an update of the registers and starts the counter. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.16..16> SMS2
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SMCR_TS2  -----------------------------------
// SVD Line: 14216

//  <item> SFDITEM_FIELD__TIM2_SMCR_TS2
//    <name> TS2 </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40000008) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SMCR ) </loc>
//      <o.21..20> TS2
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_SMCR  -----------------------------------
// SVD Line: 13811

//  <rtree> SFDITEM_REG__TIM2_SMCR
//    <name> SMCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000008) slave mode control register </i>
//    <loc> ( (unsigned int)((TIM2_SMCR >> 0) & 0xFFFFFFFF), ((TIM2_SMCR = (TIM2_SMCR & ~(0x31FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x31FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_SMCR_SMS1 </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_OCCS </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_TS1 </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_MSM </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_ETF </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_ETPS </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_ECE </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_ETP </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_SMS2 </item>
//    <item> SFDITEM_FIELD__TIM2_SMCR_TS2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_DIER  --------------------------------
// SVD Line: 14296

unsigned int TIM2_DIER __AT (0x4000000C);



// --------------------------------  Field Item: TIM2_DIER_UIE  -----------------------------------
// SVD Line: 14305

//  <item> SFDITEM_FIELD__TIM2_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000000C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled.\n1 : B_0x1 = Update interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled.
//        <1=> 1: B_0x1 = Update interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC1IE  ----------------------------------
// SVD Line: 14324

//  <item> SFDITEM_FIELD__TIM2_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4000000C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled.\n1 : B_0x1 = CC1 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled.
//        <1=> 1: B_0x1 = CC1 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC2IE  ----------------------------------
// SVD Line: 14343

//  <item> SFDITEM_FIELD__TIM2_DIER_CC2IE
//    <name> CC2IE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4000000C) \nCapture/Compare 2 interrupt enable\n0 : B_0x0 = CC2 interrupt disabled.\n1 : B_0x1 = CC2 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.2..2> CC2IE
//        <0=> 0: B_0x0 = CC2 interrupt disabled.
//        <1=> 1: B_0x1 = CC2 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC3IE  ----------------------------------
// SVD Line: 14362

//  <item> SFDITEM_FIELD__TIM2_DIER_CC3IE
//    <name> CC3IE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x4000000C) \nCapture/Compare 3 interrupt enable\n0 : B_0x0 = CC3 interrupt disabled.\n1 : B_0x1 = CC3 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.3..3> CC3IE
//        <0=> 0: B_0x0 = CC3 interrupt disabled.
//        <1=> 1: B_0x1 = CC3 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC4IE  ----------------------------------
// SVD Line: 14381

//  <item> SFDITEM_FIELD__TIM2_DIER_CC4IE
//    <name> CC4IE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x4000000C) \nCapture/Compare 4 interrupt enable\n0 : B_0x0 = CC4 interrupt disabled.\n1 : B_0x1 = CC4 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.4..4> CC4IE
//        <0=> 0: B_0x0 = CC4 interrupt disabled.
//        <1=> 1: B_0x1 = CC4 interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_DIER_TIE  -----------------------------------
// SVD Line: 14400

//  <item> SFDITEM_FIELD__TIM2_DIER_TIE
//    <name> TIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x4000000C) \nTrigger interrupt enable\n0 : B_0x0 = Trigger interrupt disabled.\n1 : B_0x1 = Trigger interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.6..6> TIE
//        <0=> 0: B_0x0 = Trigger interrupt disabled.
//        <1=> 1: B_0x1 = Trigger interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_DIER_UDE  -----------------------------------
// SVD Line: 14419

//  <item> SFDITEM_FIELD__TIM2_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4000000C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled.\n1 : B_0x1 = Update DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled.
//        <1=> 1: B_0x1 = Update DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC1DE  ----------------------------------
// SVD Line: 14438

//  <item> SFDITEM_FIELD__TIM2_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4000000C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled.\n1 : B_0x1 = CC1 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled.
//        <1=> 1: B_0x1 = CC1 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC2DE  ----------------------------------
// SVD Line: 14457

//  <item> SFDITEM_FIELD__TIM2_DIER_CC2DE
//    <name> CC2DE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x4000000C) \nCapture/Compare 2 DMA request enable\n0 : B_0x0 = CC2 DMA request disabled.\n1 : B_0x1 = CC2 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.10..10> CC2DE
//        <0=> 0: B_0x0 = CC2 DMA request disabled.
//        <1=> 1: B_0x1 = CC2 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC3DE  ----------------------------------
// SVD Line: 14476

//  <item> SFDITEM_FIELD__TIM2_DIER_CC3DE
//    <name> CC3DE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x4000000C) \nCapture/Compare 3 DMA request enable\n0 : B_0x0 = CC3 DMA request disabled.\n1 : B_0x1 = CC3 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.11..11> CC3DE
//        <0=> 0: B_0x0 = CC3 DMA request disabled.
//        <1=> 1: B_0x1 = CC3 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_DIER_CC4DE  ----------------------------------
// SVD Line: 14495

//  <item> SFDITEM_FIELD__TIM2_DIER_CC4DE
//    <name> CC4DE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x4000000C) \nCapture/Compare 4 DMA request enable\n0 : B_0x0 = CC4 DMA request disabled.\n1 : B_0x1 = CC4 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.12..12> CC4DE
//        <0=> 0: B_0x0 = CC4 DMA request disabled.
//        <1=> 1: B_0x1 = CC4 DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_DIER_TDE  -----------------------------------
// SVD Line: 14514

//  <item> SFDITEM_FIELD__TIM2_DIER_TDE
//    <name> TDE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x4000000C) \nTrigger DMA request enable\n0 : B_0x0 = Trigger DMA request disabled.\n1 : B_0x1 = Trigger DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DIER ) </loc>
//      <o.14..14> TDE
//        <0=> 0: B_0x0 = Trigger DMA request disabled.
//        <1=> 1: B_0x1 = Trigger DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_DIER  -----------------------------------
// SVD Line: 14296

//  <rtree> SFDITEM_REG__TIM2_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000000C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM2_DIER >> 0) & 0xFFFFFFFF), ((TIM2_DIER = (TIM2_DIER & ~(0x5F5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x5F5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC2IE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC3IE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC4IE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_TIE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC1DE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC2DE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC3DE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_CC4DE </item>
//    <item> SFDITEM_FIELD__TIM2_DIER_TDE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_SR  ---------------------------------
// SVD Line: 14535

unsigned int TIM2_SR __AT (0x40000010);



// ---------------------------------  Field Item: TIM2_SR_UIF  ------------------------------------
// SVD Line: 14544

//  <item> SFDITEM_FIELD__TIM2_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000010) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow and if UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC1IF  -----------------------------------
// SVD Line: 14567

//  <item> SFDITEM_FIELD__TIM2_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000010) \nCapture/compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC2IF  -----------------------------------
// SVD Line: 14589

//  <item> SFDITEM_FIELD__TIM2_SR_CC2IF
//    <name> CC2IF </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000010) Capture/Compare 2 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.2..2> CC2IF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC3IF  -----------------------------------
// SVD Line: 14597

//  <item> SFDITEM_FIELD__TIM2_SR_CC3IF
//    <name> CC3IF </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000010) Capture/Compare 3 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.3..3> CC3IF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC4IF  -----------------------------------
// SVD Line: 14605

//  <item> SFDITEM_FIELD__TIM2_SR_CC4IF
//    <name> CC4IF </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000010) Capture/Compare 4 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.4..4> CC4IF
//    </check>
//  </item>
//  


// ---------------------------------  Field Item: TIM2_SR_TIF  ------------------------------------
// SVD Line: 14613

//  <item> SFDITEM_FIELD__TIM2_SR_TIF
//    <name> TIF </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40000010) \nTrigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.\n0 : B_0x0 = No trigger event occurred.\n1 : B_0x1 = Trigger interrupt pending. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.6..6> TIF
//        <0=> 0: B_0x0 = No trigger event occurred.
//        <1=> 1: B_0x1 = Trigger interrupt pending.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC1OF  -----------------------------------
// SVD Line: 14633

//  <item> SFDITEM_FIELD__TIM2_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40000010) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected.\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected.
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC2OF  -----------------------------------
// SVD Line: 14653

//  <item> SFDITEM_FIELD__TIM2_SR_CC2OF
//    <name> CC2OF </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40000010) Capture/compare 2 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.10..10> CC2OF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC3OF  -----------------------------------
// SVD Line: 14661

//  <item> SFDITEM_FIELD__TIM2_SR_CC3OF
//    <name> CC3OF </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000010) Capture/Compare 3 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.11..11> CC3OF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_SR_CC4OF  -----------------------------------
// SVD Line: 14669

//  <item> SFDITEM_FIELD__TIM2_SR_CC4OF
//    <name> CC4OF </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40000010) Capture/Compare 4 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_SR ) </loc>
//      <o.12..12> CC4OF
//    </check>
//  </item>
//  


// ---------------------------------  Register RTree: TIM2_SR  ------------------------------------
// SVD Line: 14535

//  <rtree> SFDITEM_REG__TIM2_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000010) status register </i>
//    <loc> ( (unsigned int)((TIM2_SR >> 0) & 0xFFFFFFFF), ((TIM2_SR = (TIM2_SR & ~(0x1E5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1E5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC2IF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC3IF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC4IF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_TIF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC1OF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC2OF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC3OF </item>
//    <item> SFDITEM_FIELD__TIM2_SR_CC4OF </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_EGR  --------------------------------
// SVD Line: 14679

unsigned int TIM2_EGR __AT (0x40000014);



// ---------------------------------  Field Item: TIM2_EGR_UG  ------------------------------------
// SVD Line: 14688

//  <item> SFDITEM_FIELD__TIM2_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40000014) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_EGR_CC1G  -----------------------------------
// SVD Line: 14708

//  <item> SFDITEM_FIELD__TIM2_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40000014) \nCapture/compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_EGR_CC2G  -----------------------------------
// SVD Line: 14732

//  <item> SFDITEM_FIELD__TIM2_EGR_CC2G
//    <name> CC2G </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40000014) Capture/compare 2 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.2..2> CC2G
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_EGR_CC3G  -----------------------------------
// SVD Line: 14740

//  <item> SFDITEM_FIELD__TIM2_EGR_CC3G
//    <name> CC3G </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40000014) Capture/compare 3 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.3..3> CC3G
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM2_EGR_CC4G  -----------------------------------
// SVD Line: 14748

//  <item> SFDITEM_FIELD__TIM2_EGR_CC4G
//    <name> CC4G </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40000014) Capture/compare 4 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.4..4> CC4G
//    </check>
//  </item>
//  


// ---------------------------------  Field Item: TIM2_EGR_TG  ------------------------------------
// SVD Line: 14756

//  <item> SFDITEM_FIELD__TIM2_EGR_TG
//    <name> TG </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40000014) \nTrigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_EGR ) </loc>
//      <o.6..6> TG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_EGR  ------------------------------------
// SVD Line: 14679

//  <rtree> SFDITEM_REG__TIM2_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40000014) event generation register </i>
//    <loc> ( (unsigned int)((TIM2_EGR >> 0) & 0xFFFFFFFF), ((TIM2_EGR = (TIM2_EGR & ~(0x5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM2_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM2_EGR_CC2G </item>
//    <item> SFDITEM_FIELD__TIM2_EGR_CC3G </item>
//    <item> SFDITEM_FIELD__TIM2_EGR_CC4G </item>
//    <item> SFDITEM_FIELD__TIM2_EGR_TG </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM2_CCMR1_Output  ----------------------------
// SVD Line: 14778

unsigned int TIM2_CCMR1_Output __AT (0x40000018);



// --------------------------  Field Item: TIM2_CCMR1_Output_OC2M_3  ------------------------------
// SVD Line: 14788

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2M_3
//    <name> OC2M_3 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40000018) Output Compare 2 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.24..24> OC2M_3
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM2_CCMR1_Output_OC1M_3  ------------------------------
// SVD Line: 14795

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1M_3
//    <name> OC1M_3 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40000018) Output Compare 1 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.16..16> OC1M_3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC2CE  ------------------------------
// SVD Line: 14802

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2CE
//    <name> OC2CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000018) Output compare 2 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.15..15> OC2CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC2M  -------------------------------
// SVD Line: 14809

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2M
//    <name> OC2M </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40000018) Output compare 2 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Output >> 12) & 0x7), ((TIM2_CCMR1_Output = (TIM2_CCMR1_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC2PE  ------------------------------
// SVD Line: 14815

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2PE
//    <name> OC2PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000018) Output compare 2 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.11..11> OC2PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC2FE  ------------------------------
// SVD Line: 14822

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2FE
//    <name> OC2FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40000018) Output compare 2 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.10..10> OC2FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_CC2S  -------------------------------
// SVD Line: 14829

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000018) \nCapture/compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output.\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output.
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC1CE  ------------------------------
// SVD Line: 14860

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1CE
//    <name> OC1CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000018) \nOutput compare 1 clear enable\n0 : B_0x0 = OC1Ref is not affected by the ETRF input\n1 : B_0x1 = OC1Ref is cleared as soon as a High level is detected on ETRF input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.7..7> OC1CE
//        <0=> 0: B_0x0 = OC1Ref is not affected by the ETRF input
//        <1=> 1: B_0x1 = OC1Ref is cleared as soon as a High level is detected on ETRF input
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 14879

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000018) \nOutput compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).\n7 : B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).
//        <7=> 7: B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 14961

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000018) \nOutput compare 1 preload enable Note: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 14981

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000018) Output compare 1 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Output_CC1S  -------------------------------
// SVD Line: 14988

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40000018) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM2_CCMR1_Output  -------------------------------
// SVD Line: 14778

//  <rtree> SFDITEM_REG__TIM2_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000018) capture/compare mode register 1 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM2_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM2_CCMR1_Output = (TIM2_CCMR1_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2M_3 </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1M_3 </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2CE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2M </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2PE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC2FE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_CC2S </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1CE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Output_CC1S </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM2_CCMR1_Input  ----------------------------
// SVD Line: 15021

unsigned int TIM2_CCMR1_Input __AT (0x40000018);



// ----------------------------  Field Item: TIM2_CCMR1_Input_IC2F  -------------------------------
// SVD Line: 15032

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC2F
//    <name> IC2F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40000018) Input capture 2 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 12) & 0xF), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Input_IC2PSC  ------------------------------
// SVD Line: 15038

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC2PSC
//    <name> IC2PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x40000018) Input capture 2 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 10) & 0x3), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR1_Input_CC2S  -------------------------------
// SVD Line: 15044

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000018) Capture/compare 2  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 8) & 0x3), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0x3UL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 15051

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40000018) Input capture 1 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 4) & 0xF), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 15057

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40000018) Input capture 1 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 2) & 0x3), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0x3UL << 2 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 2 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 15063

//  <item> SFDITEM_FIELD__TIM2_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40000018) Capture/Compare 1  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR1_Input >> 0) & 0x3), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM2_CCMR1_Input  --------------------------------
// SVD Line: 15021

//  <rtree> SFDITEM_REG__TIM2_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000018) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM2_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM2_CCMR1_Input = (TIM2_CCMR1_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC2F </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC2PSC </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_CC2S </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC1F </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR1_Input_CC1S </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM2_CCMR2_Output  ----------------------------
// SVD Line: 15072

unsigned int TIM2_CCMR2_Output __AT (0x4000001C);



// --------------------------  Field Item: TIM2_CCMR2_Output_OC4M_3  ------------------------------
// SVD Line: 15082

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4M_3
//    <name> OC4M_3 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x4000001C) Output Compare 4 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.24..24> OC4M_3
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM2_CCMR2_Output_OC3M_3  ------------------------------
// SVD Line: 15089

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3M_3
//    <name> OC3M_3 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x4000001C) Output Compare 3 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.16..16> OC3M_3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC4CE  ------------------------------
// SVD Line: 15096

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4CE
//    <name> OC4CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x4000001C) Output compare 4 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.15..15> OC4CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC4M  -------------------------------
// SVD Line: 15103

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4M
//    <name> OC4M </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x4000001C) Output compare 4 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Output >> 12) & 0x7), ((TIM2_CCMR2_Output = (TIM2_CCMR2_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC4PE  ------------------------------
// SVD Line: 15109

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4PE
//    <name> OC4PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x4000001C) Output compare 4 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.11..11> OC4PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC4FE  ------------------------------
// SVD Line: 15116

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4FE
//    <name> OC4FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x4000001C) Output compare 4 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.10..10> OC4FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_CC4S  -------------------------------
// SVD Line: 15123

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x4000001C) Capture/Compare 4  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Output >> 8) & 0x3), ((TIM2_CCMR2_Output = (TIM2_CCMR2_Output & ~(0x3UL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC3CE  ------------------------------
// SVD Line: 15130

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3CE
//    <name> OC3CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x4000001C) Output compare 3 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.7..7> OC3CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC3M  -------------------------------
// SVD Line: 15137

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3M
//    <name> OC3M </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x4000001C) Output compare 3 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Output >> 4) & 0x7), ((TIM2_CCMR2_Output = (TIM2_CCMR2_Output & ~(0x7UL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC3PE  ------------------------------
// SVD Line: 15143

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3PE
//    <name> OC3PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x4000001C) Output compare 3 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.3..3> OC3PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_OC3FE  ------------------------------
// SVD Line: 15150

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3FE
//    <name> OC3FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4000001C) Output compare 3 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Output ) </loc>
//      <o.2..2> OC3FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Output_CC3S  -------------------------------
// SVD Line: 15157

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Output_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x4000001C) Capture/Compare 3  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Output >> 0) & 0x3), ((TIM2_CCMR2_Output = (TIM2_CCMR2_Output & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM2_CCMR2_Output  -------------------------------
// SVD Line: 15072

//  <rtree> SFDITEM_REG__TIM2_CCMR2_Output
//    <name> CCMR2_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000001C) capture/compare mode register 2 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM2_CCMR2_Output >> 0) & 0xFFFFFFFF), ((TIM2_CCMR2_Output = (TIM2_CCMR2_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4M_3 </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3M_3 </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4CE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4M </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4PE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC4FE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_CC4S </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3CE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3M </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3PE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_OC3FE </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Output_CC3S </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM2_CCMR2_Input  ----------------------------
// SVD Line: 15166

unsigned int TIM2_CCMR2_Input __AT (0x4000001C);



// ----------------------------  Field Item: TIM2_CCMR2_Input_IC4F  -------------------------------
// SVD Line: 15177

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC4F
//    <name> IC4F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x4000001C) Input capture 4 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Input >> 12) & 0xF), ((TIM2_CCMR2_Input = (TIM2_CCMR2_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Input_IC4PSC  ------------------------------
// SVD Line: 15183

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC4PSC
//    <name> IC4PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x4000001C) Input capture 4 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Input >> 10) & 0x3), ((TIM2_CCMR2_Input = (TIM2_CCMR2_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR2_Input_CC4S  -------------------------------
// SVD Line: 15189

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x4000001C) \nCapture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).\n0 : B_0x0 = CC4 channel is configured as output\n1 : B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4\n2 : B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3\n3 : B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Input ) </loc>
//      <o.9..8> CC4S
//        <0=> 0: B_0x0 = CC4 channel is configured as output
//        <1=> 1: B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4
//        <2=> 2: B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3
//        <3=> 3: B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR2_Input_IC3F  -------------------------------
// SVD Line: 15220

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC3F
//    <name> IC3F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x4000001C) Input capture 3 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Input >> 4) & 0xF), ((TIM2_CCMR2_Input = (TIM2_CCMR2_Input & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM2_CCMR2_Input_IC3PSC  ------------------------------
// SVD Line: 15226

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC3PSC
//    <name> IC3PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x4000001C) Input capture 3 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM2_CCMR2_Input >> 2) & 0x3), ((TIM2_CCMR2_Input = (TIM2_CCMR2_Input & ~(0x3UL << 2 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 2 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM2_CCMR2_Input_CC3S  -------------------------------
// SVD Line: 15232

//  <item> SFDITEM_FIELD__TIM2_CCMR2_Input_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x4000001C) \nCapture/Compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).\n0 : B_0x0 = CC3 channel is configured as output\n1 : B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3\n2 : B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4\n3 : B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCMR2_Input ) </loc>
//      <o.1..0> CC3S
//        <0=> 0: B_0x0 = CC3 channel is configured as output
//        <1=> 1: B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3
//        <2=> 2: B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4
//        <3=> 3: B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM2_CCMR2_Input  --------------------------------
// SVD Line: 15166

//  <rtree> SFDITEM_REG__TIM2_CCMR2_Input
//    <name> CCMR2_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000001C) capture/compare mode register 2 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM2_CCMR2_Input >> 0) & 0xFFFFFFFF), ((TIM2_CCMR2_Input = (TIM2_CCMR2_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC4F </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC4PSC </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_CC4S </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC3F </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_IC3PSC </item>
//    <item> SFDITEM_FIELD__TIM2_CCMR2_Input_CC3S </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_CCER  --------------------------------
// SVD Line: 15265

unsigned int TIM2_CCER __AT (0x40000020);



// -------------------------------  Field Item: TIM2_CCER_CC1E  -----------------------------------
// SVD Line: 15275

//  <item> SFDITEM_FIELD__TIM2_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000020) \nCapture/Compare 1 output enable.\n0 : B_0x0 = Capture mode disabled / OC1 is not active\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC1P  -----------------------------------
// SVD Line: 15294

//  <item> SFDITEM_FIELD__TIM2_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000020) \nCapture/Compare 1 output Polarity. When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: This configuration is reserved, it must not be used.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC1NP  ----------------------------------
// SVD Line: 15318

//  <item> SFDITEM_FIELD__TIM2_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000020) Capture/Compare 1 output Polarity. CC1 channel configured as output: CC1NP must be kept cleared in this case. CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.3..3> CC1NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC2E  -----------------------------------
// SVD Line: 15327

//  <item> SFDITEM_FIELD__TIM2_CCER_CC2E
//    <name> CC2E </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000020) Capture/Compare 2 output enable. Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.4..4> CC2E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC2P  -----------------------------------
// SVD Line: 15335

//  <item> SFDITEM_FIELD__TIM2_CCER_CC2P
//    <name> CC2P </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40000020) Capture/Compare 2 output Polarity. refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.5..5> CC2P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC2NP  ----------------------------------
// SVD Line: 15343

//  <item> SFDITEM_FIELD__TIM2_CCER_CC2NP
//    <name> CC2NP </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000020) Capture/Compare 2 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.7..7> CC2NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC3E  -----------------------------------
// SVD Line: 15351

//  <item> SFDITEM_FIELD__TIM2_CCER_CC3E
//    <name> CC3E </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40000020) Capture/Compare 3 output enable. Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.8..8> CC3E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC3P  -----------------------------------
// SVD Line: 15359

//  <item> SFDITEM_FIELD__TIM2_CCER_CC3P
//    <name> CC3P </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40000020) Capture/Compare 3 output Polarity. Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.9..9> CC3P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC3NP  ----------------------------------
// SVD Line: 15367

//  <item> SFDITEM_FIELD__TIM2_CCER_CC3NP
//    <name> CC3NP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000020) Capture/Compare 3 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.11..11> CC3NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC4E  -----------------------------------
// SVD Line: 15375

//  <item> SFDITEM_FIELD__TIM2_CCER_CC4E
//    <name> CC4E </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40000020) Capture/Compare 4 output enable. refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.12..12> CC4E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC4P  -----------------------------------
// SVD Line: 15383

//  <item> SFDITEM_FIELD__TIM2_CCER_CC4P
//    <name> CC4P </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40000020) Capture/Compare 4 output Polarity. Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.13..13> CC4P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CCER_CC4NP  ----------------------------------
// SVD Line: 15391

//  <item> SFDITEM_FIELD__TIM2_CCER_CC4NP
//    <name> CC4NP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000020) Capture/Compare 4 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CCER ) </loc>
//      <o.15..15> CC4NP
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CCER  -----------------------------------
// SVD Line: 15265

//  <rtree> SFDITEM_REG__TIM2_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000020) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM2_CCER >> 0) & 0xFFFFFFFF), ((TIM2_CCER = (TIM2_CCER & ~(0xBBBBUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBBBB) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC1NP </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC2E </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC2P </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC2NP </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC3E </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC3P </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC3NP </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC4E </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC4P </item>
//    <item> SFDITEM_FIELD__TIM2_CCER_CC4NP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_CNT  --------------------------------
// SVD Line: 15401

unsigned int TIM2_CNT __AT (0x40000024);



// -------------------------------  Field Item: TIM2_CNT_CNT_H  -----------------------------------
// SVD Line: 15410

//  <item> SFDITEM_FIELD__TIM2_CNT_CNT_H
//    <name> CNT_H </name>
//    <rw> 
//    <i> [Bits 31..16] RW (@ 0x40000024) High counter value (TIM2  only) </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM2_CNT >> 16) & 0xFFFF), ((TIM2_CNT = (TIM2_CNT & ~(0xFFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM2_CNT_CNT_L  -----------------------------------
// SVD Line: 15417

//  <item> SFDITEM_FIELD__TIM2_CNT_CNT_L
//    <name> CNT_L </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40000024) Low counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM2_CNT >> 0) & 0xFFFF), ((TIM2_CNT = (TIM2_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CNT  ------------------------------------
// SVD Line: 15401

//  <rtree> SFDITEM_REG__TIM2_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000024) counter </i>
//    <loc> ( (unsigned int)((TIM2_CNT >> 0) & 0xFFFFFFFF), ((TIM2_CNT = (TIM2_CNT & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CNT_CNT_H </item>
//    <item> SFDITEM_FIELD__TIM2_CNT_CNT_L </item>
//  </rtree>
//  


// -----------------------  Register Item Address: TIM2_CNT_ALTERNATE5  ---------------------------
// SVD Line: 15425

unsigned int TIM2_CNT_ALTERNATE5 __AT (0x40000024);



// ---------------------------  Field Item: TIM2_CNT_ALTERNATE5_CNT  ------------------------------
// SVD Line: 15435

//  <item> SFDITEM_FIELD__TIM2_CNT_ALTERNATE5_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 30..0] RW (@ 0x40000024) Most significant part counter value (TIM2) nullLeast significant part of counter value </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_CNT_ALTERNATE5 >> 0) & 0x7FFFFFFF), ((TIM2_CNT_ALTERNATE5 = (TIM2_CNT_ALTERNATE5 & ~(0x7FFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: TIM2_CNT_ALTERNATE5_UIFCPY  -----------------------------
// SVD Line: 15443

//  <item> SFDITEM_FIELD__TIM2_CNT_ALTERNATE5_UIFCPY
//    <name> UIFCPY </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40000024) UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) TIM2_CNT_ALTERNATE5 ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// ---------------------------  Register RTree: TIM2_CNT_ALTERNATE5  ------------------------------
// SVD Line: 15425

//  <rtree> SFDITEM_REG__TIM2_CNT_ALTERNATE5
//    <name> CNT_ALTERNATE5 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000024) counter </i>
//    <loc> ( (unsigned int)((TIM2_CNT_ALTERNATE5 >> 0) & 0xFFFFFFFF), ((TIM2_CNT_ALTERNATE5 = (TIM2_CNT_ALTERNATE5 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CNT_ALTERNATE5_CNT </item>
//    <item> SFDITEM_FIELD__TIM2_CNT_ALTERNATE5_UIFCPY </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_PSC  --------------------------------
// SVD Line: 15453

unsigned int TIM2_PSC __AT (0x40000028);



// --------------------------------  Field Item: TIM2_PSC_PSC  ------------------------------------
// SVD Line: 15462

//  <item> SFDITEM_FIELD__TIM2_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40000028) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM2_PSC >> 0) & 0xFFFF), ((TIM2_PSC = (TIM2_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_PSC  ------------------------------------
// SVD Line: 15453

//  <rtree> SFDITEM_REG__TIM2_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000028) prescaler </i>
//    <loc> ( (unsigned int)((TIM2_PSC >> 0) & 0xFFFFFFFF), ((TIM2_PSC = (TIM2_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_PSC_PSC </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_ARR  --------------------------------
// SVD Line: 15470

unsigned int TIM2_ARR __AT (0x4000002C);



// --------------------------------  Field Item: TIM2_ARR_ARR  ------------------------------------
// SVD Line: 15479

//  <item> SFDITEM_FIELD__TIM2_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000002C) High auto-reload value (TIM2) nullLow Auto-reload value ARR is the value to be loaded in the actual auto-reload register. Refer to the for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_ARR >> 0) & 0xFFFFFFFF), ((TIM2_ARR = (TIM2_ARR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_ARR  ------------------------------------
// SVD Line: 15470

//  <rtree> SFDITEM_REG__TIM2_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000002C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM2_ARR >> 0) & 0xFFFFFFFF), ((TIM2_ARR = (TIM2_ARR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_CCR1  --------------------------------
// SVD Line: 15492

unsigned int TIM2_CCR1 __AT (0x40000034);



// -------------------------------  Field Item: TIM2_CCR1_CCR1  -----------------------------------
// SVD Line: 15501

//  <item> SFDITEM_FIELD__TIM2_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000034) High Capture/Compare 1 value (TIM2) nullLow Capture/Compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output. If channel CC1is configured as input: CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_CCR1 >> 0) & 0xFFFFFFFF), ((TIM2_CCR1 = (TIM2_CCR1 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CCR1  -----------------------------------
// SVD Line: 15492

//  <rtree> SFDITEM_REG__TIM2_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000034) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM2_CCR1 >> 0) & 0xFFFFFFFF), ((TIM2_CCR1 = (TIM2_CCR1 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCR1_CCR1 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_CCR2  --------------------------------
// SVD Line: 15517

unsigned int TIM2_CCR2 __AT (0x40000038);



// -------------------------------  Field Item: TIM2_CCR2_CCR2  -----------------------------------
// SVD Line: 15526

//  <item> SFDITEM_FIELD__TIM2_CCR2_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000038) High Capture/Compare 2 value (TIM2) nullLow Capture/Compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output. If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_CCR2 >> 0) & 0xFFFFFFFF), ((TIM2_CCR2 = (TIM2_CCR2 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CCR2  -----------------------------------
// SVD Line: 15517

//  <rtree> SFDITEM_REG__TIM2_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000038) capture/compare register 2 </i>
//    <loc> ( (unsigned int)((TIM2_CCR2 >> 0) & 0xFFFFFFFF), ((TIM2_CCR2 = (TIM2_CCR2 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCR2_CCR2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_CCR3  --------------------------------
// SVD Line: 15542

unsigned int TIM2_CCR3 __AT (0x4000003C);



// -------------------------------  Field Item: TIM2_CCR3_CCR3  -----------------------------------
// SVD Line: 15551

//  <item> SFDITEM_FIELD__TIM2_CCR3_CCR3
//    <name> CCR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000003C) High Capture/Compare 3 value (TIM2) nullLow Capture/Compare value If channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output. If channel CC3is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_CCR3 >> 0) & 0xFFFFFFFF), ((TIM2_CCR3 = (TIM2_CCR3 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CCR3  -----------------------------------
// SVD Line: 15542

//  <rtree> SFDITEM_REG__TIM2_CCR3
//    <name> CCR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000003C) capture/compare register 3 </i>
//    <loc> ( (unsigned int)((TIM2_CCR3 >> 0) & 0xFFFFFFFF), ((TIM2_CCR3 = (TIM2_CCR3 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCR3_CCR3 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_CCR4  --------------------------------
// SVD Line: 15567

unsigned int TIM2_CCR4 __AT (0x40000040);



// -------------------------------  Field Item: TIM2_CCR4_CCR4  -----------------------------------
// SVD Line: 15576

//  <item> SFDITEM_FIELD__TIM2_CCR4_CCR4
//    <name> CCR4 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000040) High Capture/Compare 4 value (TIM2) nullLow Capture/Compare value if CC4 channel is configured as output (CC4S bits): CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output. if CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register): CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM2_CCR4 >> 0) & 0xFFFFFFFF), ((TIM2_CCR4 = (TIM2_CCR4 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_CCR4  -----------------------------------
// SVD Line: 15567

//  <rtree> SFDITEM_REG__TIM2_CCR4
//    <name> CCR4 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000040) capture/compare register 4 </i>
//    <loc> ( (unsigned int)((TIM2_CCR4 >> 0) & 0xFFFFFFFF), ((TIM2_CCR4 = (TIM2_CCR4 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_CCR4_CCR4 </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_DCR  --------------------------------
// SVD Line: 15592

unsigned int TIM2_DCR __AT (0x40000048);



// --------------------------------  Field Item: TIM2_DCR_DBA  ------------------------------------
// SVD Line: 15601

//  <item> SFDITEM_FIELD__TIM2_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40000048) \nDMA base address This 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ... Example: Let us consider the following transfer: DBL = 7 transfers & DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.\n0 : B_0x0 = TIMx_CR1\n1 : B_0x1 = TIMx_CR2\n2 : B_0x2 = TIMx_SMCR\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1
//        <1=> 1: B_0x1 = TIMx_CR2
//        <2=> 2: B_0x2 = TIMx_SMCR
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM2_DCR_DBL  ------------------------------------
// SVD Line: 15629

//  <item> SFDITEM_FIELD__TIM2_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40000048) \nDMA burst length This 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address). ...\n0 : B_0x0 = 1 transfer,\n1 : B_0x1 = 2 transfers,\n2 : B_0x2 = 3 transfers,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers.\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer,
//        <1=> 1: B_0x1 = 2 transfers,
//        <2=> 2: B_0x2 = 3 transfers,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers.
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_DCR  ------------------------------------
// SVD Line: 15592

//  <rtree> SFDITEM_REG__TIM2_DCR
//    <name> DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000048) DMA control register </i>
//    <loc> ( (unsigned int)((TIM2_DCR >> 0) & 0xFFFFFFFF), ((TIM2_DCR = (TIM2_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM2_DCR_DBL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_DMAR  --------------------------------
// SVD Line: 15662

unsigned int TIM2_DMAR __AT (0x4000004C);



// -------------------------------  Field Item: TIM2_DMAR_DMAB  -----------------------------------
// SVD Line: 15671

//  <item> SFDITEM_FIELD__TIM2_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000004C) DMA register for burst  accesses </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM2_DMAR >> 0) & 0xFFFF), ((TIM2_DMAR = (TIM2_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_DMAR  -----------------------------------
// SVD Line: 15662

//  <rtree> SFDITEM_REG__TIM2_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000004C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM2_DMAR >> 0) & 0xFFFFFFFF), ((TIM2_DMAR = (TIM2_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_DMAR_DMAB </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_OR1  --------------------------------
// SVD Line: 15680

unsigned int TIM2_OR1 __AT (0x40000050);



// -----------------------------  Field Item: TIM2_OR1_OCREF_CLR  ---------------------------------
// SVD Line: 15689

//  <item> SFDITEM_FIELD__TIM2_OR1_OCREF_CLR
//    <name> OCREF_CLR </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000050) \nOcref_clr source selection This bit selects the ocref_clr input source.\n0 : B_0x0 = COMP1 output is connected to the OCREF_CLR input\n1 : B_0x1 = COMP2 output is connected to the OCREF_CLR input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_OR1 ) </loc>
//      <o.0..0> OCREF_CLR
//        <0=> 0: B_0x0 = COMP1 output is connected to the OCREF_CLR input
//        <1=> 1: B_0x1 = COMP2 output is connected to the OCREF_CLR input
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_OR1  ------------------------------------
// SVD Line: 15680

//  <rtree> SFDITEM_REG__TIM2_OR1
//    <name> OR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000050) TIM option register </i>
//    <loc> ( (unsigned int)((TIM2_OR1 >> 0) & 0xFFFFFFFF), ((TIM2_OR1 = (TIM2_OR1 & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_OR1_OCREF_CLR </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM2_AF1  --------------------------------
// SVD Line: 15711

unsigned int TIM2_AF1 __AT (0x40000060);



// -------------------------------  Field Item: TIM2_AF1_ETRSEL  ----------------------------------
// SVD Line: 15721

//  <item> SFDITEM_FIELD__TIM2_AF1_ETRSEL
//    <name> ETRSEL </name>
//    <rw> 
//    <i> [Bits 17..14] RW (@ 0x40000060) \nETR source selection These bits select the ETR input source. Others: Reserved\n0 : B_0x0 = ETR legacy mode\n1 : B_0x1 = COMP1\n2 : B_0x2 = COMP2\n3 : B_0x3 = LSE\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_AF1 ) </loc>
//      <o.17..14> ETRSEL
//        <0=> 0: B_0x0 = ETR legacy mode
//        <1=> 1: B_0x1 = COMP1
//        <2=> 2: B_0x2 = COMP2
//        <3=> 3: B_0x3 = LSE
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM2_AF1  ------------------------------------
// SVD Line: 15711

//  <rtree> SFDITEM_REG__TIM2_AF1
//    <name> AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000060) TIM alternate function option register  1 </i>
//    <loc> ( (unsigned int)((TIM2_AF1 >> 0) & 0xFFFFFFFF), ((TIM2_AF1 = (TIM2_AF1 & ~(0x3C000UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3C000) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_AF1_ETRSEL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM2_TISEL  -------------------------------
// SVD Line: 15754

unsigned int TIM2_TISEL __AT (0x40000068);



// ------------------------------  Field Item: TIM2_TISEL_TI1SEL  ---------------------------------
// SVD Line: 15764

//  <item> SFDITEM_FIELD__TIM2_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40000068) \nTI1[0] to TI1[15] input selection These bits select the TI1[0] to TI1[15] input source. Others: Reserved\n0 : B_0x0 = TIM2_CH1 input\n1 : B_0x1 = COMP1 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM2_CH1 input
//        <1=> 1: B_0x1 = COMP1 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM2_TISEL_TI2SEL  ---------------------------------
// SVD Line: 15785

//  <item> SFDITEM_FIELD__TIM2_TISEL_TI2SEL
//    <name> TI2SEL </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40000068) \nTI2[0] to TI2[15] input selection These bits select the TI2[0] to TI2[15] input source. Others: Reserved\n0 : B_0x0 = TIM2_CH2 input\n1 : B_0x1 = COMP2 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM2_TISEL ) </loc>
//      <o.11..8> TI2SEL
//        <0=> 0: B_0x0 = TIM2_CH2 input
//        <1=> 1: B_0x1 = COMP2 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM2_TISEL  -----------------------------------
// SVD Line: 15754

//  <rtree> SFDITEM_REG__TIM2_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000068) TIM alternate function option register  1 </i>
//    <loc> ( (unsigned int)((TIM2_TISEL >> 0) & 0xFFFFFFFF), ((TIM2_TISEL = (TIM2_TISEL & ~(0xF0FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM2_TISEL_TI1SEL </item>
//    <item> SFDITEM_FIELD__TIM2_TISEL_TI2SEL </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: TIM2  -------------------------------------
// SVD Line: 13483

//  <view> TIM2
//    <name> TIM2 </name>
//    <item> SFDITEM_REG__TIM2_CR1 </item>
//    <item> SFDITEM_REG__TIM2_CR2 </item>
//    <item> SFDITEM_REG__TIM2_SMCR </item>
//    <item> SFDITEM_REG__TIM2_DIER </item>
//    <item> SFDITEM_REG__TIM2_SR </item>
//    <item> SFDITEM_REG__TIM2_EGR </item>
//    <item> SFDITEM_REG__TIM2_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM2_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM2_CCMR2_Output </item>
//    <item> SFDITEM_REG__TIM2_CCMR2_Input </item>
//    <item> SFDITEM_REG__TIM2_CCER </item>
//    <item> SFDITEM_REG__TIM2_CNT </item>
//    <item> SFDITEM_REG__TIM2_CNT_ALTERNATE5 </item>
//    <item> SFDITEM_REG__TIM2_PSC </item>
//    <item> SFDITEM_REG__TIM2_ARR </item>
//    <item> SFDITEM_REG__TIM2_CCR1 </item>
//    <item> SFDITEM_REG__TIM2_CCR2 </item>
//    <item> SFDITEM_REG__TIM2_CCR3 </item>
//    <item> SFDITEM_REG__TIM2_CCR4 </item>
//    <item> SFDITEM_REG__TIM2_DCR </item>
//    <item> SFDITEM_REG__TIM2_DMAR </item>
//    <item> SFDITEM_REG__TIM2_OR1 </item>
//    <item> SFDITEM_REG__TIM2_AF1 </item>
//    <item> SFDITEM_REG__TIM2_TISEL </item>
//  </view>
//  


// -----------------------------  Register Item Address: TIM3_CR1  --------------------------------
// SVD Line: 13499

unsigned int TIM3_CR1 __AT (0x40000400);



// --------------------------------  Field Item: TIM3_CR1_CEN  ------------------------------------
// SVD Line: 13508

//  <item> SFDITEM_FIELD__TIM3_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000400) \nCounter enable Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_UDIS  -----------------------------------
// SVD Line: 13529

//  <item> SFDITEM_FIELD__TIM3_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000400) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_URS  ------------------------------------
// SVD Line: 13553

//  <item> SFDITEM_FIELD__TIM3_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000400) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_OPM  ------------------------------------
// SVD Line: 13576

//  <item> SFDITEM_FIELD__TIM3_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000400) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_DIR  ------------------------------------
// SVD Line: 13595

//  <item> SFDITEM_FIELD__TIM3_CR1_DIR
//    <name> DIR </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000400) \nDirection Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.\n0 : B_0x0 = Counter used as upcounter\n1 : B_0x1 = Counter used as downcounter </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.4..4> DIR
//        <0=> 0: B_0x0 = Counter used as upcounter
//        <1=> 1: B_0x1 = Counter used as downcounter
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_CMS  ------------------------------------
// SVD Line: 13615

//  <item> SFDITEM_FIELD__TIM3_CR1_CMS
//    <name> CMS </name>
//    <rw> 
//    <i> [Bits 6..5] RW (@ 0x40000400) \nCenter-aligned mode selection Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)\n0 : B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).\n1 : B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.\n2 : B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.\n3 : B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.6..5> CMS
//        <0=> 0: B_0x0 = Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
//        <1=> 1: B_0x1 = Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.
//        <2=> 2: B_0x2 = Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.
//        <3=> 3: B_0x3 = Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_ARPE  -----------------------------------
// SVD Line: 13645

//  <item> SFDITEM_FIELD__TIM3_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000400) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR1_CKD  ------------------------------------
// SVD Line: 13664

//  <item> SFDITEM_FIELD__TIM3_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000400) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),\n0 : B_0x0 = tDTS = tCK_INT\n1 : B_0x1 = tDTS = 2  tCK_INT\n2 : B_0x2 = tDTS = 4  tCK_INT\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS = tCK_INT
//        <1=> 1: B_0x1 = tDTS = 2  tCK_INT
//        <2=> 2: B_0x2 = tDTS = 4  tCK_INT
//        <3=> 3: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM3_CR1_UIFREMAP  ---------------------------------
// SVD Line: 13689

//  <item> SFDITEM_FIELD__TIM3_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000400) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CR1  ------------------------------------
// SVD Line: 13499

//  <rtree> SFDITEM_REG__TIM3_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000400) control register 1 </i>
//    <loc> ( (unsigned int)((TIM3_CR1 >> 0) & 0xFFFFFFFF), ((TIM3_CR1 = (TIM3_CR1 & ~(0xBFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_DIR </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_CMS </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM3_CR1_UIFREMAP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_CR2  --------------------------------
// SVD Line: 13710

unsigned int TIM3_CR2 __AT (0x40000404);



// --------------------------------  Field Item: TIM3_CR2_CCDS  -----------------------------------
// SVD Line: 13719

//  <item> SFDITEM_FIELD__TIM3_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000404) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR2_MMS  ------------------------------------
// SVD Line: 13738

//  <item> SFDITEM_FIELD__TIM3_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000404) \nMaster mode selection These bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.\n2 : B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)\n4 : B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)\n5 : B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)\n6 : B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)\n7 : B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode.
//        <2=> 2: B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
//        <4=> 4: B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO)
//        <5=> 5: B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO)
//        <6=> 6: B_0x6 = Compare - OC3REFC signal is used as trigger output (TRGO)
//        <7=> 7: B_0x7 = Compare - OC4REFC signal is used as trigger output (TRGO)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_CR2_TI1S  -----------------------------------
// SVD Line: 13790

//  <item> SFDITEM_FIELD__TIM3_CR2_TI1S
//    <name> TI1S </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000404) \nTI1 selection\n0 : B_0x0 = The TIMx_CH1 pin is connected to TI1 input\n1 : B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CR2 ) </loc>
//      <o.7..7> TI1S
//        <0=> 0: B_0x0 = The TIMx_CH1 pin is connected to TI1 input
//        <1=> 1: B_0x1 = The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) See also
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CR2  ------------------------------------
// SVD Line: 13710

//  <rtree> SFDITEM_REG__TIM3_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000404) control register 2 </i>
//    <loc> ( (unsigned int)((TIM3_CR2 >> 0) & 0xFFFFFFFF), ((TIM3_CR2 = (TIM3_CR2 & ~(0xF8UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF8) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM3_CR2_MMS </item>
//    <item> SFDITEM_FIELD__TIM3_CR2_TI1S </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_SMCR  --------------------------------
// SVD Line: 13811

unsigned int TIM3_SMCR __AT (0x40000408);



// -------------------------------  Field Item: TIM3_SMCR_SMS1  -----------------------------------
// SVD Line: 13820

//  <item> SFDITEM_FIELD__TIM3_SMCR_SMS1
//    <name> SMS1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40000408) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. reinitializes the counter, generates an update of the registers and starts the counter. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.\n2 : B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.\n3 : B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.\n4 : B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.\n5 : B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.\n6 : B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.\n7 : B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.2..0> SMS1
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//        <2=> 2: B_0x2 = Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
//        <3=> 3: B_0x3 = Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
//        <4=> 4: B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
//        <5=> 5: B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
//        <6=> 6: B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
//        <7=> 7: B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_SMCR_OCCS  -----------------------------------
// SVD Line: 13878

//  <item> SFDITEM_FIELD__TIM3_SMCR_OCCS
//    <name> OCCS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000408) \nOCREF clear selection This bit is used to select the OCREF clear source\n0 : B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.OCREF_CLR\n1 : B_0x1 = OCREF_CLR_INT is connected to ETRF </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.3..3> OCCS
//        <0=> 0: B_0x0 = OCREF_CLR_INT is connected to COMP1 or COMP2 output depending on TIMx_OR1.OCREF_CLR
//        <1=> 1: B_0x1 = OCREF_CLR_INT is connected to ETRF
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_TS1  -----------------------------------
// SVD Line: 13898

//  <item> SFDITEM_FIELD__TIM3_SMCR_TS1
//    <name> TS1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000408) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3)\n4 : B_0x4 = TI1 Edge Detector (TI1F_ED)\n5 : B_0x5 = Filtered Timer Input 1 (TI1FP1)\n6 : B_0x6 = Filtered Timer Input 2 (TI2FP2)\n7 : B_0x7 = External Trigger input (ETRF) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.6..4> TS1
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//        <4=> 4: B_0x4 = TI1 Edge Detector (TI1F_ED)
//        <5=> 5: B_0x5 = Filtered Timer Input 1 (TI1FP1)
//        <6=> 6: B_0x6 = Filtered Timer Input 2 (TI2FP2)
//        <7=> 7: B_0x7 = External Trigger input (ETRF)
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_MSM  -----------------------------------
// SVD Line: 13976

//  <item> SFDITEM_FIELD__TIM3_SMCR_MSM
//    <name> MSM </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000408) \nMaster/Slave mode\n0 : B_0x0 = No action\n1 : B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.7..7> MSM
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_ETF  -----------------------------------
// SVD Line: 13995

//  <item> SFDITEM_FIELD__TIM3_SMCR_ETF
//    <name> ETF </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40000408) \nExternal trigger filter This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.11..8> ETF
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_SMCR_ETPS  -----------------------------------
// SVD Line: 14085

//  <item> SFDITEM_FIELD__TIM3_SMCR_ETPS
//    <name> ETPS </name>
//    <rw> 
//    <i> [Bits 13..12] RW (@ 0x40000408) \nExternal trigger prescaler External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.\n0 : B_0x0 = Prescaler OFF\n1 : B_0x1 = ETRP frequency divided by 2\n2 : B_0x2 = ETRP frequency divided by 4\n3 : B_0x3 = ETRP frequency divided by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.13..12> ETPS
//        <0=> 0: B_0x0 = Prescaler OFF
//        <1=> 1: B_0x1 = ETRP frequency divided by 2
//        <2=> 2: B_0x2 = ETRP frequency divided by 4
//        <3=> 3: B_0x3 = ETRP frequency divided by 8
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_ECE  -----------------------------------
// SVD Line: 14115

//  <item> SFDITEM_FIELD__TIM3_SMCR_ECE
//    <name> ECE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40000408) \nExternal clock enable This bit enables External clock mode 2. Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111). It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111). If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.\n0 : B_0x0 = External clock mode 2 disabled\n1 : B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.14..14> ECE
//        <0=> 0: B_0x0 = External clock mode 2 disabled
//        <1=> 1: B_0x1 = External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_ETP  -----------------------------------
// SVD Line: 14138

//  <item> SFDITEM_FIELD__TIM3_SMCR_ETP
//    <name> ETP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000408) \nExternal trigger polarity This bit selects whether ETR or ETR is used for trigger operations\n0 : B_0x0 = ETR is non-inverted, active at high level or rising edge\n1 : B_0x1 = ETR is inverted, active at low level or falling edge </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.15..15> ETP
//        <0=> 0: B_0x0 = ETR is non-inverted, active at high level or rising edge
//        <1=> 1: B_0x1 = ETR is inverted, active at low level or falling edge
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_SMCR_SMS2  -----------------------------------
// SVD Line: 14158

//  <item> SFDITEM_FIELD__TIM3_SMCR_SMS2
//    <name> SMS2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40000408) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. reinitializes the counter, generates an update of the registers and starts the counter. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.16..16> SMS2
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: B_0x1 = Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SMCR_TS2  -----------------------------------
// SVD Line: 14216

//  <item> SFDITEM_FIELD__TIM3_SMCR_TS2
//    <name> TS2 </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40000408) \nTrigger selection This bit-field selects the trigger input to be used to synchronize the counter. Others: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SMCR ) </loc>
//      <o.21..20> TS2
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_SMCR  -----------------------------------
// SVD Line: 13811

//  <rtree> SFDITEM_REG__TIM3_SMCR
//    <name> SMCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000408) slave mode control register </i>
//    <loc> ( (unsigned int)((TIM3_SMCR >> 0) & 0xFFFFFFFF), ((TIM3_SMCR = (TIM3_SMCR & ~(0x31FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x31FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_SMCR_SMS1 </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_OCCS </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_TS1 </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_MSM </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_ETF </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_ETPS </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_ECE </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_ETP </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_SMS2 </item>
//    <item> SFDITEM_FIELD__TIM3_SMCR_TS2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_DIER  --------------------------------
// SVD Line: 14296

unsigned int TIM3_DIER __AT (0x4000040C);



// --------------------------------  Field Item: TIM3_DIER_UIE  -----------------------------------
// SVD Line: 14305

//  <item> SFDITEM_FIELD__TIM3_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000040C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled.\n1 : B_0x1 = Update interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled.
//        <1=> 1: B_0x1 = Update interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC1IE  ----------------------------------
// SVD Line: 14324

//  <item> SFDITEM_FIELD__TIM3_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4000040C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled.\n1 : B_0x1 = CC1 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled.
//        <1=> 1: B_0x1 = CC1 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC2IE  ----------------------------------
// SVD Line: 14343

//  <item> SFDITEM_FIELD__TIM3_DIER_CC2IE
//    <name> CC2IE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4000040C) \nCapture/Compare 2 interrupt enable\n0 : B_0x0 = CC2 interrupt disabled.\n1 : B_0x1 = CC2 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.2..2> CC2IE
//        <0=> 0: B_0x0 = CC2 interrupt disabled.
//        <1=> 1: B_0x1 = CC2 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC3IE  ----------------------------------
// SVD Line: 14362

//  <item> SFDITEM_FIELD__TIM3_DIER_CC3IE
//    <name> CC3IE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x4000040C) \nCapture/Compare 3 interrupt enable\n0 : B_0x0 = CC3 interrupt disabled.\n1 : B_0x1 = CC3 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.3..3> CC3IE
//        <0=> 0: B_0x0 = CC3 interrupt disabled.
//        <1=> 1: B_0x1 = CC3 interrupt enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC4IE  ----------------------------------
// SVD Line: 14381

//  <item> SFDITEM_FIELD__TIM3_DIER_CC4IE
//    <name> CC4IE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x4000040C) \nCapture/Compare 4 interrupt enable\n0 : B_0x0 = CC4 interrupt disabled.\n1 : B_0x1 = CC4 interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.4..4> CC4IE
//        <0=> 0: B_0x0 = CC4 interrupt disabled.
//        <1=> 1: B_0x1 = CC4 interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_DIER_TIE  -----------------------------------
// SVD Line: 14400

//  <item> SFDITEM_FIELD__TIM3_DIER_TIE
//    <name> TIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x4000040C) \nTrigger interrupt enable\n0 : B_0x0 = Trigger interrupt disabled.\n1 : B_0x1 = Trigger interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.6..6> TIE
//        <0=> 0: B_0x0 = Trigger interrupt disabled.
//        <1=> 1: B_0x1 = Trigger interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_DIER_UDE  -----------------------------------
// SVD Line: 14419

//  <item> SFDITEM_FIELD__TIM3_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4000040C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled.\n1 : B_0x1 = Update DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled.
//        <1=> 1: B_0x1 = Update DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC1DE  ----------------------------------
// SVD Line: 14438

//  <item> SFDITEM_FIELD__TIM3_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4000040C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled.\n1 : B_0x1 = CC1 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled.
//        <1=> 1: B_0x1 = CC1 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC2DE  ----------------------------------
// SVD Line: 14457

//  <item> SFDITEM_FIELD__TIM3_DIER_CC2DE
//    <name> CC2DE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x4000040C) \nCapture/Compare 2 DMA request enable\n0 : B_0x0 = CC2 DMA request disabled.\n1 : B_0x1 = CC2 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.10..10> CC2DE
//        <0=> 0: B_0x0 = CC2 DMA request disabled.
//        <1=> 1: B_0x1 = CC2 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC3DE  ----------------------------------
// SVD Line: 14476

//  <item> SFDITEM_FIELD__TIM3_DIER_CC3DE
//    <name> CC3DE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x4000040C) \nCapture/Compare 3 DMA request enable\n0 : B_0x0 = CC3 DMA request disabled.\n1 : B_0x1 = CC3 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.11..11> CC3DE
//        <0=> 0: B_0x0 = CC3 DMA request disabled.
//        <1=> 1: B_0x1 = CC3 DMA request enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_DIER_CC4DE  ----------------------------------
// SVD Line: 14495

//  <item> SFDITEM_FIELD__TIM3_DIER_CC4DE
//    <name> CC4DE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x4000040C) \nCapture/Compare 4 DMA request enable\n0 : B_0x0 = CC4 DMA request disabled.\n1 : B_0x1 = CC4 DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.12..12> CC4DE
//        <0=> 0: B_0x0 = CC4 DMA request disabled.
//        <1=> 1: B_0x1 = CC4 DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_DIER_TDE  -----------------------------------
// SVD Line: 14514

//  <item> SFDITEM_FIELD__TIM3_DIER_TDE
//    <name> TDE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x4000040C) \nTrigger DMA request enable\n0 : B_0x0 = Trigger DMA request disabled.\n1 : B_0x1 = Trigger DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DIER ) </loc>
//      <o.14..14> TDE
//        <0=> 0: B_0x0 = Trigger DMA request disabled.
//        <1=> 1: B_0x1 = Trigger DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_DIER  -----------------------------------
// SVD Line: 14296

//  <rtree> SFDITEM_REG__TIM3_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000040C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM3_DIER >> 0) & 0xFFFFFFFF), ((TIM3_DIER = (TIM3_DIER & ~(0x5F5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x5F5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC2IE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC3IE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC4IE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_TIE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC1DE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC2DE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC3DE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_CC4DE </item>
//    <item> SFDITEM_FIELD__TIM3_DIER_TDE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_SR  ---------------------------------
// SVD Line: 14535

unsigned int TIM3_SR __AT (0x40000410);



// ---------------------------------  Field Item: TIM3_SR_UIF  ------------------------------------
// SVD Line: 14544

//  <item> SFDITEM_FIELD__TIM3_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000410) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow and if UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC1IF  -----------------------------------
// SVD Line: 14567

//  <item> SFDITEM_FIELD__TIM3_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000410) \nCapture/compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC2IF  -----------------------------------
// SVD Line: 14589

//  <item> SFDITEM_FIELD__TIM3_SR_CC2IF
//    <name> CC2IF </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000410) Capture/Compare 2 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.2..2> CC2IF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC3IF  -----------------------------------
// SVD Line: 14597

//  <item> SFDITEM_FIELD__TIM3_SR_CC3IF
//    <name> CC3IF </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000410) Capture/Compare 3 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.3..3> CC3IF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC4IF  -----------------------------------
// SVD Line: 14605

//  <item> SFDITEM_FIELD__TIM3_SR_CC4IF
//    <name> CC4IF </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000410) Capture/Compare 4 interrupt flag Refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.4..4> CC4IF
//    </check>
//  </item>
//  


// ---------------------------------  Field Item: TIM3_SR_TIF  ------------------------------------
// SVD Line: 14613

//  <item> SFDITEM_FIELD__TIM3_SR_TIF
//    <name> TIF </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40000410) \nTrigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.\n0 : B_0x0 = No trigger event occurred.\n1 : B_0x1 = Trigger interrupt pending. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.6..6> TIF
//        <0=> 0: B_0x0 = No trigger event occurred.
//        <1=> 1: B_0x1 = Trigger interrupt pending.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC1OF  -----------------------------------
// SVD Line: 14633

//  <item> SFDITEM_FIELD__TIM3_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40000410) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected.\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected.
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC2OF  -----------------------------------
// SVD Line: 14653

//  <item> SFDITEM_FIELD__TIM3_SR_CC2OF
//    <name> CC2OF </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40000410) Capture/compare 2 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.10..10> CC2OF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC3OF  -----------------------------------
// SVD Line: 14661

//  <item> SFDITEM_FIELD__TIM3_SR_CC3OF
//    <name> CC3OF </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000410) Capture/Compare 3 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.11..11> CC3OF
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_SR_CC4OF  -----------------------------------
// SVD Line: 14669

//  <item> SFDITEM_FIELD__TIM3_SR_CC4OF
//    <name> CC4OF </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40000410) Capture/Compare 4 overcapture flag refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_SR ) </loc>
//      <o.12..12> CC4OF
//    </check>
//  </item>
//  


// ---------------------------------  Register RTree: TIM3_SR  ------------------------------------
// SVD Line: 14535

//  <rtree> SFDITEM_REG__TIM3_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000410) status register </i>
//    <loc> ( (unsigned int)((TIM3_SR >> 0) & 0xFFFFFFFF), ((TIM3_SR = (TIM3_SR & ~(0x1E5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1E5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC2IF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC3IF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC4IF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_TIF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC1OF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC2OF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC3OF </item>
//    <item> SFDITEM_FIELD__TIM3_SR_CC4OF </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_EGR  --------------------------------
// SVD Line: 14679

unsigned int TIM3_EGR __AT (0x40000414);



// ---------------------------------  Field Item: TIM3_EGR_UG  ------------------------------------
// SVD Line: 14688

//  <item> SFDITEM_FIELD__TIM3_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40000414) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_EGR_CC1G  -----------------------------------
// SVD Line: 14708

//  <item> SFDITEM_FIELD__TIM3_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40000414) \nCapture/compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_EGR_CC2G  -----------------------------------
// SVD Line: 14732

//  <item> SFDITEM_FIELD__TIM3_EGR_CC2G
//    <name> CC2G </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40000414) Capture/compare 2 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.2..2> CC2G
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_EGR_CC3G  -----------------------------------
// SVD Line: 14740

//  <item> SFDITEM_FIELD__TIM3_EGR_CC3G
//    <name> CC3G </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40000414) Capture/compare 3 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.3..3> CC3G
//    </check>
//  </item>
//  


// --------------------------------  Field Item: TIM3_EGR_CC4G  -----------------------------------
// SVD Line: 14748

//  <item> SFDITEM_FIELD__TIM3_EGR_CC4G
//    <name> CC4G </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40000414) Capture/compare 4 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.4..4> CC4G
//    </check>
//  </item>
//  


// ---------------------------------  Field Item: TIM3_EGR_TG  ------------------------------------
// SVD Line: 14756

//  <item> SFDITEM_FIELD__TIM3_EGR_TG
//    <name> TG </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40000414) \nTrigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_EGR ) </loc>
//      <o.6..6> TG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_EGR  ------------------------------------
// SVD Line: 14679

//  <rtree> SFDITEM_REG__TIM3_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40000414) event generation register </i>
//    <loc> ( (unsigned int)((TIM3_EGR >> 0) & 0xFFFFFFFF), ((TIM3_EGR = (TIM3_EGR & ~(0x5FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x5F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM3_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM3_EGR_CC2G </item>
//    <item> SFDITEM_FIELD__TIM3_EGR_CC3G </item>
//    <item> SFDITEM_FIELD__TIM3_EGR_CC4G </item>
//    <item> SFDITEM_FIELD__TIM3_EGR_TG </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM3_CCMR1_Output  ----------------------------
// SVD Line: 14778

unsigned int TIM3_CCMR1_Output __AT (0x40000418);



// --------------------------  Field Item: TIM3_CCMR1_Output_OC2M_3  ------------------------------
// SVD Line: 14788

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2M_3
//    <name> OC2M_3 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40000418) Output Compare 2 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.24..24> OC2M_3
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM3_CCMR1_Output_OC1M_3  ------------------------------
// SVD Line: 14795

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1M_3
//    <name> OC1M_3 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40000418) Output Compare 1 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.16..16> OC1M_3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC2CE  ------------------------------
// SVD Line: 14802

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2CE
//    <name> OC2CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000418) Output compare 2 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.15..15> OC2CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC2M  -------------------------------
// SVD Line: 14809

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2M
//    <name> OC2M </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40000418) Output compare 2 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Output >> 12) & 0x7), ((TIM3_CCMR1_Output = (TIM3_CCMR1_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC2PE  ------------------------------
// SVD Line: 14815

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2PE
//    <name> OC2PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000418) Output compare 2 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.11..11> OC2PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC2FE  ------------------------------
// SVD Line: 14822

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2FE
//    <name> OC2FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40000418) Output compare 2 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.10..10> OC2FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_CC2S  -------------------------------
// SVD Line: 14829

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000418) \nCapture/compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output.\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output.
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC1CE  ------------------------------
// SVD Line: 14860

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1CE
//    <name> OC1CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000418) \nOutput compare 1 clear enable\n0 : B_0x0 = OC1Ref is not affected by the ETRF input\n1 : B_0x1 = OC1Ref is cleared as soon as a High level is detected on ETRF input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.7..7> OC1CE
//        <0=> 0: B_0x0 = OC1Ref is not affected by the ETRF input
//        <1=> 1: B_0x1 = OC1Ref is cleared as soon as a High level is detected on ETRF input
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 14879

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40000418) \nOutput compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).\n7 : B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).
//        <7=> 7: B_0x7 = PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 14961

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000418) \nOutput compare 1 preload enable Note: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 14981

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40000418) Output compare 1 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Output_CC1S  -------------------------------
// SVD Line: 14988

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40000418) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM3_CCMR1_Output  -------------------------------
// SVD Line: 14778

//  <rtree> SFDITEM_REG__TIM3_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000418) capture/compare mode register 1 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM3_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM3_CCMR1_Output = (TIM3_CCMR1_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2M_3 </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1M_3 </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2CE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2M </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2PE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC2FE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_CC2S </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1CE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Output_CC1S </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM3_CCMR1_Input  ----------------------------
// SVD Line: 15021

unsigned int TIM3_CCMR1_Input __AT (0x40000418);



// ----------------------------  Field Item: TIM3_CCMR1_Input_IC2F  -------------------------------
// SVD Line: 15032

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC2F
//    <name> IC2F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40000418) Input capture 2 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 12) & 0xF), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Input_IC2PSC  ------------------------------
// SVD Line: 15038

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC2PSC
//    <name> IC2PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x40000418) Input capture 2 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 10) & 0x3), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR1_Input_CC2S  -------------------------------
// SVD Line: 15044

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40000418) Capture/compare 2  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 8) & 0x3), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0x3UL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 15051

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40000418) Input capture 1 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 4) & 0xF), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 15057

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40000418) Input capture 1 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 2) & 0x3), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0x3UL << 2 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 2 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 15063

//  <item> SFDITEM_FIELD__TIM3_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40000418) Capture/Compare 1  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR1_Input >> 0) & 0x3), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM3_CCMR1_Input  --------------------------------
// SVD Line: 15021

//  <rtree> SFDITEM_REG__TIM3_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000418) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM3_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM3_CCMR1_Input = (TIM3_CCMR1_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC2F </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC2PSC </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_CC2S </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC1F </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR1_Input_CC1S </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM3_CCMR2_Output  ----------------------------
// SVD Line: 15072

unsigned int TIM3_CCMR2_Output __AT (0x4000041C);



// --------------------------  Field Item: TIM3_CCMR2_Output_OC4M_3  ------------------------------
// SVD Line: 15082

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4M_3
//    <name> OC4M_3 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x4000041C) Output Compare 4 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.24..24> OC4M_3
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM3_CCMR2_Output_OC3M_3  ------------------------------
// SVD Line: 15089

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3M_3
//    <name> OC3M_3 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x4000041C) Output Compare 3 mode - bit  3 </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.16..16> OC3M_3
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC4CE  ------------------------------
// SVD Line: 15096

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4CE
//    <name> OC4CE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x4000041C) Output compare 4 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.15..15> OC4CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC4M  -------------------------------
// SVD Line: 15103

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4M
//    <name> OC4M </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x4000041C) Output compare 4 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Output >> 12) & 0x7), ((TIM3_CCMR2_Output = (TIM3_CCMR2_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC4PE  ------------------------------
// SVD Line: 15109

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4PE
//    <name> OC4PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x4000041C) Output compare 4 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.11..11> OC4PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC4FE  ------------------------------
// SVD Line: 15116

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4FE
//    <name> OC4FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x4000041C) Output compare 4 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.10..10> OC4FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_CC4S  -------------------------------
// SVD Line: 15123

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x4000041C) Capture/Compare 4  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Output >> 8) & 0x3), ((TIM3_CCMR2_Output = (TIM3_CCMR2_Output & ~(0x3UL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC3CE  ------------------------------
// SVD Line: 15130

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3CE
//    <name> OC3CE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x4000041C) Output compare 3 clear  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.7..7> OC3CE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC3M  -------------------------------
// SVD Line: 15137

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3M
//    <name> OC3M </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x4000041C) Output compare 3 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Output >> 4) & 0x7), ((TIM3_CCMR2_Output = (TIM3_CCMR2_Output & ~(0x7UL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC3PE  ------------------------------
// SVD Line: 15143

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3PE
//    <name> OC3PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x4000041C) Output compare 3 preload  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.3..3> OC3PE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_OC3FE  ------------------------------
// SVD Line: 15150

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3FE
//    <name> OC3FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4000041C) Output compare 3 fast  enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Output ) </loc>
//      <o.2..2> OC3FE
//    </check>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Output_CC3S  -------------------------------
// SVD Line: 15157

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Output_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x4000041C) Capture/Compare 3  selection </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Output >> 0) & 0x3), ((TIM3_CCMR2_Output = (TIM3_CCMR2_Output & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM3_CCMR2_Output  -------------------------------
// SVD Line: 15072

//  <rtree> SFDITEM_REG__TIM3_CCMR2_Output
//    <name> CCMR2_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000041C) capture/compare mode register 2 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM3_CCMR2_Output >> 0) & 0xFFFFFFFF), ((TIM3_CCMR2_Output = (TIM3_CCMR2_Output & ~(0x101FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4M_3 </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3M_3 </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4CE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4M </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4PE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC4FE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_CC4S </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3CE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3M </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3PE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_OC3FE </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Output_CC3S </item>
//  </rtree>
//  


// -------------------------  Register Item Address: TIM3_CCMR2_Input  ----------------------------
// SVD Line: 15166

unsigned int TIM3_CCMR2_Input __AT (0x4000041C);



// ----------------------------  Field Item: TIM3_CCMR2_Input_IC4F  -------------------------------
// SVD Line: 15177

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC4F
//    <name> IC4F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x4000041C) Input capture 4 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Input >> 12) & 0xF), ((TIM3_CCMR2_Input = (TIM3_CCMR2_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Input_IC4PSC  ------------------------------
// SVD Line: 15183

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC4PSC
//    <name> IC4PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x4000041C) Input capture 4 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Input >> 10) & 0x3), ((TIM3_CCMR2_Input = (TIM3_CCMR2_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR2_Input_CC4S  -------------------------------
// SVD Line: 15189

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_CC4S
//    <name> CC4S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x4000041C) \nCapture/Compare 4 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).\n0 : B_0x0 = CC4 channel is configured as output\n1 : B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4\n2 : B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3\n3 : B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Input ) </loc>
//      <o.9..8> CC4S
//        <0=> 0: B_0x0 = CC4 channel is configured as output
//        <1=> 1: B_0x1 = CC4 channel is configured as input, IC4 is mapped on TI4
//        <2=> 2: B_0x2 = CC4 channel is configured as input, IC4 is mapped on TI3
//        <3=> 3: B_0x3 = CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR2_Input_IC3F  -------------------------------
// SVD Line: 15220

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC3F
//    <name> IC3F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x4000041C) Input capture 3 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Input >> 4) & 0xF), ((TIM3_CCMR2_Input = (TIM3_CCMR2_Input & ~(0xFUL << 4 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 4 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM3_CCMR2_Input_IC3PSC  ------------------------------
// SVD Line: 15226

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC3PSC
//    <name> IC3PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x4000041C) Input capture 3 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM3_CCMR2_Input >> 2) & 0x3), ((TIM3_CCMR2_Input = (TIM3_CCMR2_Input & ~(0x3UL << 2 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 2 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Field Item: TIM3_CCMR2_Input_CC3S  -------------------------------
// SVD Line: 15232

//  <item> SFDITEM_FIELD__TIM3_CCMR2_Input_CC3S
//    <name> CC3S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x4000041C) \nCapture/Compare 3 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).\n0 : B_0x0 = CC3 channel is configured as output\n1 : B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3\n2 : B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4\n3 : B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCMR2_Input ) </loc>
//      <o.1..0> CC3S
//        <0=> 0: B_0x0 = CC3 channel is configured as output
//        <1=> 1: B_0x1 = CC3 channel is configured as input, IC3 is mapped on TI3
//        <2=> 2: B_0x2 = CC3 channel is configured as input, IC3 is mapped on TI4
//        <3=> 3: B_0x3 = CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM3_CCMR2_Input  --------------------------------
// SVD Line: 15166

//  <rtree> SFDITEM_REG__TIM3_CCMR2_Input
//    <name> CCMR2_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000041C) capture/compare mode register 2 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM3_CCMR2_Input >> 0) & 0xFFFFFFFF), ((TIM3_CCMR2_Input = (TIM3_CCMR2_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC4F </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC4PSC </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_CC4S </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC3F </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_IC3PSC </item>
//    <item> SFDITEM_FIELD__TIM3_CCMR2_Input_CC3S </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_CCER  --------------------------------
// SVD Line: 15265

unsigned int TIM3_CCER __AT (0x40000420);



// -------------------------------  Field Item: TIM3_CCER_CC1E  -----------------------------------
// SVD Line: 15275

//  <item> SFDITEM_FIELD__TIM3_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000420) \nCapture/Compare 1 output enable.\n0 : B_0x0 = Capture mode disabled / OC1 is not active\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC1P  -----------------------------------
// SVD Line: 15294

//  <item> SFDITEM_FIELD__TIM3_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40000420) \nCapture/Compare 1 output Polarity. When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: This configuration is reserved, it must not be used.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC1NP  ----------------------------------
// SVD Line: 15318

//  <item> SFDITEM_FIELD__TIM3_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40000420) Capture/Compare 1 output Polarity. CC1 channel configured as output: CC1NP must be kept cleared in this case. CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.3..3> CC1NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC2E  -----------------------------------
// SVD Line: 15327

//  <item> SFDITEM_FIELD__TIM3_CCER_CC2E
//    <name> CC2E </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40000420) Capture/Compare 2 output enable. Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.4..4> CC2E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC2P  -----------------------------------
// SVD Line: 15335

//  <item> SFDITEM_FIELD__TIM3_CCER_CC2P
//    <name> CC2P </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40000420) Capture/Compare 2 output Polarity. refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.5..5> CC2P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC2NP  ----------------------------------
// SVD Line: 15343

//  <item> SFDITEM_FIELD__TIM3_CCER_CC2NP
//    <name> CC2NP </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40000420) Capture/Compare 2 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.7..7> CC2NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC3E  -----------------------------------
// SVD Line: 15351

//  <item> SFDITEM_FIELD__TIM3_CCER_CC3E
//    <name> CC3E </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40000420) Capture/Compare 3 output enable. Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.8..8> CC3E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC3P  -----------------------------------
// SVD Line: 15359

//  <item> SFDITEM_FIELD__TIM3_CCER_CC3P
//    <name> CC3P </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40000420) Capture/Compare 3 output Polarity. Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.9..9> CC3P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC3NP  ----------------------------------
// SVD Line: 15367

//  <item> SFDITEM_FIELD__TIM3_CCER_CC3NP
//    <name> CC3NP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40000420) Capture/Compare 3 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.11..11> CC3NP
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC4E  -----------------------------------
// SVD Line: 15375

//  <item> SFDITEM_FIELD__TIM3_CCER_CC4E
//    <name> CC4E </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40000420) Capture/Compare 4 output enable. refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.12..12> CC4E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC4P  -----------------------------------
// SVD Line: 15383

//  <item> SFDITEM_FIELD__TIM3_CCER_CC4P
//    <name> CC4P </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40000420) Capture/Compare 4 output Polarity. Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.13..13> CC4P
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CCER_CC4NP  ----------------------------------
// SVD Line: 15391

//  <item> SFDITEM_FIELD__TIM3_CCER_CC4NP
//    <name> CC4NP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40000420) Capture/Compare 4 output Polarity. Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CCER ) </loc>
//      <o.15..15> CC4NP
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CCER  -----------------------------------
// SVD Line: 15265

//  <rtree> SFDITEM_REG__TIM3_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000420) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM3_CCER >> 0) & 0xFFFFFFFF), ((TIM3_CCER = (TIM3_CCER & ~(0xBBBBUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBBBB) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC1NP </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC2E </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC2P </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC2NP </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC3E </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC3P </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC3NP </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC4E </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC4P </item>
//    <item> SFDITEM_FIELD__TIM3_CCER_CC4NP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_CNT  --------------------------------
// SVD Line: 15401

unsigned int TIM3_CNT __AT (0x40000424);



// -------------------------------  Field Item: TIM3_CNT_CNT_H  -----------------------------------
// SVD Line: 15410

//  <item> SFDITEM_FIELD__TIM3_CNT_CNT_H
//    <name> CNT_H </name>
//    <rw> 
//    <i> [Bits 31..16] RW (@ 0x40000424) High counter value (TIM2  only) </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM3_CNT >> 16) & 0xFFFF), ((TIM3_CNT = (TIM3_CNT & ~(0xFFFFUL << 16 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM3_CNT_CNT_L  -----------------------------------
// SVD Line: 15417

//  <item> SFDITEM_FIELD__TIM3_CNT_CNT_L
//    <name> CNT_L </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40000424) Low counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM3_CNT >> 0) & 0xFFFF), ((TIM3_CNT = (TIM3_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CNT  ------------------------------------
// SVD Line: 15401

//  <rtree> SFDITEM_REG__TIM3_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000424) counter </i>
//    <loc> ( (unsigned int)((TIM3_CNT >> 0) & 0xFFFFFFFF), ((TIM3_CNT = (TIM3_CNT & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CNT_CNT_H </item>
//    <item> SFDITEM_FIELD__TIM3_CNT_CNT_L </item>
//  </rtree>
//  


// -----------------------  Register Item Address: TIM3_CNT_ALTERNATE5  ---------------------------
// SVD Line: 15425

unsigned int TIM3_CNT_ALTERNATE5 __AT (0x40000424);



// ---------------------------  Field Item: TIM3_CNT_ALTERNATE5_CNT  ------------------------------
// SVD Line: 15435

//  <item> SFDITEM_FIELD__TIM3_CNT_ALTERNATE5_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 30..0] RW (@ 0x40000424) Most significant part counter value (TIM2) nullLeast significant part of counter value </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_CNT_ALTERNATE5 >> 0) & 0x7FFFFFFF), ((TIM3_CNT_ALTERNATE5 = (TIM3_CNT_ALTERNATE5 & ~(0x7FFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------  Field Item: TIM3_CNT_ALTERNATE5_UIFCPY  -----------------------------
// SVD Line: 15443

//  <item> SFDITEM_FIELD__TIM3_CNT_ALTERNATE5_UIFCPY
//    <name> UIFCPY </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40000424) UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register </i>
//    <check> 
//      <loc> ( (unsigned int) TIM3_CNT_ALTERNATE5 ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// ---------------------------  Register RTree: TIM3_CNT_ALTERNATE5  ------------------------------
// SVD Line: 15425

//  <rtree> SFDITEM_REG__TIM3_CNT_ALTERNATE5
//    <name> CNT_ALTERNATE5 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000424) counter </i>
//    <loc> ( (unsigned int)((TIM3_CNT_ALTERNATE5 >> 0) & 0xFFFFFFFF), ((TIM3_CNT_ALTERNATE5 = (TIM3_CNT_ALTERNATE5 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CNT_ALTERNATE5_CNT </item>
//    <item> SFDITEM_FIELD__TIM3_CNT_ALTERNATE5_UIFCPY </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_PSC  --------------------------------
// SVD Line: 15453

unsigned int TIM3_PSC __AT (0x40000428);



// --------------------------------  Field Item: TIM3_PSC_PSC  ------------------------------------
// SVD Line: 15462

//  <item> SFDITEM_FIELD__TIM3_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40000428) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM3_PSC >> 0) & 0xFFFF), ((TIM3_PSC = (TIM3_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_PSC  ------------------------------------
// SVD Line: 15453

//  <rtree> SFDITEM_REG__TIM3_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000428) prescaler </i>
//    <loc> ( (unsigned int)((TIM3_PSC >> 0) & 0xFFFFFFFF), ((TIM3_PSC = (TIM3_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_PSC_PSC </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_ARR  --------------------------------
// SVD Line: 15470

unsigned int TIM3_ARR __AT (0x4000042C);



// --------------------------------  Field Item: TIM3_ARR_ARR  ------------------------------------
// SVD Line: 15479

//  <item> SFDITEM_FIELD__TIM3_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000042C) High auto-reload value (TIM2) nullLow Auto-reload value ARR is the value to be loaded in the actual auto-reload register. Refer to the for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_ARR >> 0) & 0xFFFFFFFF), ((TIM3_ARR = (TIM3_ARR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_ARR  ------------------------------------
// SVD Line: 15470

//  <rtree> SFDITEM_REG__TIM3_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000042C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM3_ARR >> 0) & 0xFFFFFFFF), ((TIM3_ARR = (TIM3_ARR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_CCR1  --------------------------------
// SVD Line: 15492

unsigned int TIM3_CCR1 __AT (0x40000434);



// -------------------------------  Field Item: TIM3_CCR1_CCR1  -----------------------------------
// SVD Line: 15501

//  <item> SFDITEM_FIELD__TIM3_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000434) High Capture/Compare 1 value (TIM2) nullLow Capture/Compare 1 value If channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output. If channel CC1is configured as input: CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_CCR1 >> 0) & 0xFFFFFFFF), ((TIM3_CCR1 = (TIM3_CCR1 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CCR1  -----------------------------------
// SVD Line: 15492

//  <rtree> SFDITEM_REG__TIM3_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000434) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM3_CCR1 >> 0) & 0xFFFFFFFF), ((TIM3_CCR1 = (TIM3_CCR1 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCR1_CCR1 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_CCR2  --------------------------------
// SVD Line: 15517

unsigned int TIM3_CCR2 __AT (0x40000438);



// -------------------------------  Field Item: TIM3_CCR2_CCR2  -----------------------------------
// SVD Line: 15526

//  <item> SFDITEM_FIELD__TIM3_CCR2_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000438) High Capture/Compare 2 value (TIM2) nullLow Capture/Compare 2 value If channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output. If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_CCR2 >> 0) & 0xFFFFFFFF), ((TIM3_CCR2 = (TIM3_CCR2 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CCR2  -----------------------------------
// SVD Line: 15517

//  <rtree> SFDITEM_REG__TIM3_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000438) capture/compare register 2 </i>
//    <loc> ( (unsigned int)((TIM3_CCR2 >> 0) & 0xFFFFFFFF), ((TIM3_CCR2 = (TIM3_CCR2 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCR2_CCR2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_CCR3  --------------------------------
// SVD Line: 15542

unsigned int TIM3_CCR3 __AT (0x4000043C);



// -------------------------------  Field Item: TIM3_CCR3_CCR3  -----------------------------------
// SVD Line: 15551

//  <item> SFDITEM_FIELD__TIM3_CCR3_CCR3
//    <name> CCR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000043C) High Capture/Compare 3 value (TIM2) nullLow Capture/Compare value If channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output. If channel CC3is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_CCR3 >> 0) & 0xFFFFFFFF), ((TIM3_CCR3 = (TIM3_CCR3 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CCR3  -----------------------------------
// SVD Line: 15542

//  <rtree> SFDITEM_REG__TIM3_CCR3
//    <name> CCR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000043C) capture/compare register 3 </i>
//    <loc> ( (unsigned int)((TIM3_CCR3 >> 0) & 0xFFFFFFFF), ((TIM3_CCR3 = (TIM3_CCR3 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCR3_CCR3 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_CCR4  --------------------------------
// SVD Line: 15567

unsigned int TIM3_CCR4 __AT (0x40000440);



// -------------------------------  Field Item: TIM3_CCR4_CCR4  -----------------------------------
// SVD Line: 15576

//  <item> SFDITEM_FIELD__TIM3_CCR4_CCR4
//    <name> CCR4 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000440) High Capture/Compare 4 value (TIM2) nullLow Capture/Compare value if CC4 channel is configured as output (CC4S bits): CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs. The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output. if CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register): CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed. </i>
//    <edit> 
//      <loc> ( (unsigned int)((TIM3_CCR4 >> 0) & 0xFFFFFFFF), ((TIM3_CCR4 = (TIM3_CCR4 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_CCR4  -----------------------------------
// SVD Line: 15567

//  <rtree> SFDITEM_REG__TIM3_CCR4
//    <name> CCR4 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000440) capture/compare register 4 </i>
//    <loc> ( (unsigned int)((TIM3_CCR4 >> 0) & 0xFFFFFFFF), ((TIM3_CCR4 = (TIM3_CCR4 & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_CCR4_CCR4 </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_DCR  --------------------------------
// SVD Line: 15592

unsigned int TIM3_DCR __AT (0x40000448);



// --------------------------------  Field Item: TIM3_DCR_DBA  ------------------------------------
// SVD Line: 15601

//  <item> SFDITEM_FIELD__TIM3_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40000448) \nDMA base address This 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ... Example: Let us consider the following transfer: DBL = 7 transfers & DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.\n0 : B_0x0 = TIMx_CR1\n1 : B_0x1 = TIMx_CR2\n2 : B_0x2 = TIMx_SMCR\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1
//        <1=> 1: B_0x1 = TIMx_CR2
//        <2=> 2: B_0x2 = TIMx_SMCR
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM3_DCR_DBL  ------------------------------------
// SVD Line: 15629

//  <item> SFDITEM_FIELD__TIM3_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40000448) \nDMA burst length This 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address). ...\n0 : B_0x0 = 1 transfer,\n1 : B_0x1 = 2 transfers,\n2 : B_0x2 = 3 transfers,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers.\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer,
//        <1=> 1: B_0x1 = 2 transfers,
//        <2=> 2: B_0x2 = 3 transfers,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers.
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_DCR  ------------------------------------
// SVD Line: 15592

//  <rtree> SFDITEM_REG__TIM3_DCR
//    <name> DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000448) DMA control register </i>
//    <loc> ( (unsigned int)((TIM3_DCR >> 0) & 0xFFFFFFFF), ((TIM3_DCR = (TIM3_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM3_DCR_DBL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_DMAR  --------------------------------
// SVD Line: 15662

unsigned int TIM3_DMAR __AT (0x4000044C);



// -------------------------------  Field Item: TIM3_DMAR_DMAB  -----------------------------------
// SVD Line: 15671

//  <item> SFDITEM_FIELD__TIM3_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000044C) DMA register for burst  accesses </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM3_DMAR >> 0) & 0xFFFF), ((TIM3_DMAR = (TIM3_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_DMAR  -----------------------------------
// SVD Line: 15662

//  <rtree> SFDITEM_REG__TIM3_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000044C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM3_DMAR >> 0) & 0xFFFFFFFF), ((TIM3_DMAR = (TIM3_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_DMAR_DMAB </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_OR1  --------------------------------
// SVD Line: 15680

unsigned int TIM3_OR1 __AT (0x40000450);



// -----------------------------  Field Item: TIM3_OR1_OCREF_CLR  ---------------------------------
// SVD Line: 15689

//  <item> SFDITEM_FIELD__TIM3_OR1_OCREF_CLR
//    <name> OCREF_CLR </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40000450) \nOcref_clr source selection This bit selects the ocref_clr input source.\n0 : B_0x0 = COMP1 output is connected to the OCREF_CLR input\n1 : B_0x1 = COMP2 output is connected to the OCREF_CLR input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_OR1 ) </loc>
//      <o.0..0> OCREF_CLR
//        <0=> 0: B_0x0 = COMP1 output is connected to the OCREF_CLR input
//        <1=> 1: B_0x1 = COMP2 output is connected to the OCREF_CLR input
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_OR1  ------------------------------------
// SVD Line: 15680

//  <rtree> SFDITEM_REG__TIM3_OR1
//    <name> OR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000450) TIM option register </i>
//    <loc> ( (unsigned int)((TIM3_OR1 >> 0) & 0xFFFFFFFF), ((TIM3_OR1 = (TIM3_OR1 & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_OR1_OCREF_CLR </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM3_AF1  --------------------------------
// SVD Line: 15711

unsigned int TIM3_AF1 __AT (0x40000460);



// -------------------------------  Field Item: TIM3_AF1_ETRSEL  ----------------------------------
// SVD Line: 15721

//  <item> SFDITEM_FIELD__TIM3_AF1_ETRSEL
//    <name> ETRSEL </name>
//    <rw> 
//    <i> [Bits 17..14] RW (@ 0x40000460) \nETR source selection These bits select the ETR input source. Others: Reserved\n0 : B_0x0 = ETR legacy mode\n1 : B_0x1 = COMP1\n2 : B_0x2 = COMP2\n3 : B_0x3 = LSE\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_AF1 ) </loc>
//      <o.17..14> ETRSEL
//        <0=> 0: B_0x0 = ETR legacy mode
//        <1=> 1: B_0x1 = COMP1
//        <2=> 2: B_0x2 = COMP2
//        <3=> 3: B_0x3 = LSE
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM3_AF1  ------------------------------------
// SVD Line: 15711

//  <rtree> SFDITEM_REG__TIM3_AF1
//    <name> AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000460) TIM alternate function option register  1 </i>
//    <loc> ( (unsigned int)((TIM3_AF1 >> 0) & 0xFFFFFFFF), ((TIM3_AF1 = (TIM3_AF1 & ~(0x3C000UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3C000) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_AF1_ETRSEL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM3_TISEL  -------------------------------
// SVD Line: 15754

unsigned int TIM3_TISEL __AT (0x40000468);



// ------------------------------  Field Item: TIM3_TISEL_TI1SEL  ---------------------------------
// SVD Line: 15764

//  <item> SFDITEM_FIELD__TIM3_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40000468) \nTI1[0] to TI1[15] input selection These bits select the TI1[0] to TI1[15] input source. Others: Reserved\n0 : B_0x0 = TIM2_CH1 input\n1 : B_0x1 = COMP1 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM2_CH1 input
//        <1=> 1: B_0x1 = COMP1 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM3_TISEL_TI2SEL  ---------------------------------
// SVD Line: 15785

//  <item> SFDITEM_FIELD__TIM3_TISEL_TI2SEL
//    <name> TI2SEL </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40000468) \nTI2[0] to TI2[15] input selection These bits select the TI2[0] to TI2[15] input source. Others: Reserved\n0 : B_0x0 = TIM2_CH2 input\n1 : B_0x1 = COMP2 output\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM3_TISEL ) </loc>
//      <o.11..8> TI2SEL
//        <0=> 0: B_0x0 = TIM2_CH2 input
//        <1=> 1: B_0x1 = COMP2 output
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM3_TISEL  -----------------------------------
// SVD Line: 15754

//  <rtree> SFDITEM_REG__TIM3_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40000468) TIM alternate function option register  1 </i>
//    <loc> ( (unsigned int)((TIM3_TISEL >> 0) & 0xFFFFFFFF), ((TIM3_TISEL = (TIM3_TISEL & ~(0xF0FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM3_TISEL_TI1SEL </item>
//    <item> SFDITEM_FIELD__TIM3_TISEL_TI2SEL </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: TIM3  -------------------------------------
// SVD Line: 15810

//  <view> TIM3
//    <name> TIM3 </name>
//    <item> SFDITEM_REG__TIM3_CR1 </item>
//    <item> SFDITEM_REG__TIM3_CR2 </item>
//    <item> SFDITEM_REG__TIM3_SMCR </item>
//    <item> SFDITEM_REG__TIM3_DIER </item>
//    <item> SFDITEM_REG__TIM3_SR </item>
//    <item> SFDITEM_REG__TIM3_EGR </item>
//    <item> SFDITEM_REG__TIM3_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM3_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM3_CCMR2_Output </item>
//    <item> SFDITEM_REG__TIM3_CCMR2_Input </item>
//    <item> SFDITEM_REG__TIM3_CCER </item>
//    <item> SFDITEM_REG__TIM3_CNT </item>
//    <item> SFDITEM_REG__TIM3_CNT_ALTERNATE5 </item>
//    <item> SFDITEM_REG__TIM3_PSC </item>
//    <item> SFDITEM_REG__TIM3_ARR </item>
//    <item> SFDITEM_REG__TIM3_CCR1 </item>
//    <item> SFDITEM_REG__TIM3_CCR2 </item>
//    <item> SFDITEM_REG__TIM3_CCR3 </item>
//    <item> SFDITEM_REG__TIM3_CCR4 </item>
//    <item> SFDITEM_REG__TIM3_DCR </item>
//    <item> SFDITEM_REG__TIM3_DMAR </item>
//    <item> SFDITEM_REG__TIM3_OR1 </item>
//    <item> SFDITEM_REG__TIM3_AF1 </item>
//    <item> SFDITEM_REG__TIM3_TISEL </item>
//  </view>
//  


// -----------------------------  Register Item Address: TIM6_CR1  --------------------------------
// SVD Line: 15836

unsigned int TIM6_CR1 __AT (0x40001000);



// --------------------------------  Field Item: TIM6_CR1_CEN  ------------------------------------
// SVD Line: 15845

//  <item> SFDITEM_FIELD__TIM6_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40001000) \nCounter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM6_CR1_UDIS  -----------------------------------
// SVD Line: 15866

//  <item> SFDITEM_FIELD__TIM6_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40001000) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM6_CR1_URS  ------------------------------------
// SVD Line: 15890

//  <item> SFDITEM_FIELD__TIM6_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40001000) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generates an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generates an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM6_CR1_OPM  ------------------------------------
// SVD Line: 15913

//  <item> SFDITEM_FIELD__TIM6_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40001000) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the CEN bit). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the CEN bit).
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM6_CR1_ARPE  -----------------------------------
// SVD Line: 15932

//  <item> SFDITEM_FIELD__TIM6_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40001000) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered.\n1 : B_0x1 = TIMx_ARR register is buffered. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered.
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM6_CR1_UIFREMAP  ---------------------------------
// SVD Line: 15951

//  <item> SFDITEM_FIELD__TIM6_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40001000) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_CR1  ------------------------------------
// SVD Line: 15836

//  <rtree> SFDITEM_REG__TIM6_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001000) control register 1 </i>
//    <loc> ( (unsigned int)((TIM6_CR1 >> 0) & 0xFFFFFFFF), ((TIM6_CR1 = (TIM6_CR1 & ~(0x88FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x88F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM6_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM6_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM6_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM6_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM6_CR1_UIFREMAP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_CR2  --------------------------------
// SVD Line: 15972

unsigned int TIM6_CR2 __AT (0x40001004);



// --------------------------------  Field Item: TIM6_CR2_MMS  ------------------------------------
// SVD Line: 15981

//  <item> SFDITEM_FIELD__TIM6_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40001004) \nMaster mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.\n2 : B_0x2 = Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.
//        <2=> 2: B_0x2 = Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_CR2  ------------------------------------
// SVD Line: 15972

//  <rtree> SFDITEM_REG__TIM6_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001004) control register 2 </i>
//    <loc> ( (unsigned int)((TIM6_CR2 >> 0) & 0xFFFFFFFF), ((TIM6_CR2 = (TIM6_CR2 & ~(0x70UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x70) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_CR2_MMS </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM6_DIER  --------------------------------
// SVD Line: 16010

unsigned int TIM6_DIER __AT (0x4000100C);



// --------------------------------  Field Item: TIM6_DIER_UIE  -----------------------------------
// SVD Line: 16019

//  <item> SFDITEM_FIELD__TIM6_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000100C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled.\n1 : B_0x1 = Update interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled.
//        <1=> 1: B_0x1 = Update interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM6_DIER_UDE  -----------------------------------
// SVD Line: 16038

//  <item> SFDITEM_FIELD__TIM6_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4000100C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled.\n1 : B_0x1 = Update DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled.
//        <1=> 1: B_0x1 = Update DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_DIER  -----------------------------------
// SVD Line: 16010

//  <rtree> SFDITEM_REG__TIM6_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000100C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM6_DIER >> 0) & 0xFFFFFFFF), ((TIM6_DIER = (TIM6_DIER & ~(0x101UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM6_DIER_UDE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_SR  ---------------------------------
// SVD Line: 16059

unsigned int TIM6_SR __AT (0x40001010);



// ---------------------------------  Field Item: TIM6_SR_UIF  ------------------------------------
// SVD Line: 16068

//  <item> SFDITEM_FIELD__TIM6_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40001010) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// ---------------------------------  Register RTree: TIM6_SR  ------------------------------------
// SVD Line: 16059

//  <rtree> SFDITEM_REG__TIM6_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001010) status register </i>
//    <loc> ( (unsigned int)((TIM6_SR >> 0) & 0xFFFFFFFF), ((TIM6_SR = (TIM6_SR & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_SR_UIF </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_EGR  --------------------------------
// SVD Line: 16092

unsigned int TIM6_EGR __AT (0x40001014);



// ---------------------------------  Field Item: TIM6_EGR_UG  ------------------------------------
// SVD Line: 16101

//  <item> SFDITEM_FIELD__TIM6_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40001014) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM6_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_EGR  ------------------------------------
// SVD Line: 16092

//  <rtree> SFDITEM_REG__TIM6_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40001014) event generation register </i>
//    <loc> ( (unsigned int)((TIM6_EGR >> 0) & 0xFFFFFFFF), ((TIM6_EGR = (TIM6_EGR & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_EGR_UG </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_CNT  --------------------------------
// SVD Line: 16123

unsigned int TIM6_CNT __AT (0x40001024);



// --------------------------------  Field Item: TIM6_CNT_CNT  ------------------------------------
// SVD Line: 16132

//  <item> SFDITEM_FIELD__TIM6_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40001024) Counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM6_CNT >> 0) & 0xFFFF), ((TIM6_CNT = (TIM6_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM6_CNT_UIFCPY  ----------------------------------
// SVD Line: 16139

//  <item> SFDITEM_FIELD__TIM6_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40001024) UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM6_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_CNT  ------------------------------------
// SVD Line: 16123

//  <rtree> SFDITEM_REG__TIM6_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001024) counter </i>
//    <loc> ( (unsigned int)((TIM6_CNT >> 0) & 0xFFFFFFFF), ((TIM6_CNT = (TIM6_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM6_CNT_UIFCPY </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_PSC  --------------------------------
// SVD Line: 16149

unsigned int TIM6_PSC __AT (0x40001028);



// --------------------------------  Field Item: TIM6_PSC_PSC  ------------------------------------
// SVD Line: 16158

//  <item> SFDITEM_FIELD__TIM6_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40001028) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM6_PSC >> 0) & 0xFFFF), ((TIM6_PSC = (TIM6_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_PSC  ------------------------------------
// SVD Line: 16149

//  <rtree> SFDITEM_REG__TIM6_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001028) prescaler </i>
//    <loc> ( (unsigned int)((TIM6_PSC >> 0) & 0xFFFFFFFF), ((TIM6_PSC = (TIM6_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_PSC_PSC </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM6_ARR  --------------------------------
// SVD Line: 16166

unsigned int TIM6_ARR __AT (0x4000102C);



// --------------------------------  Field Item: TIM6_ARR_ARR  ------------------------------------
// SVD Line: 16175

//  <item> SFDITEM_FIELD__TIM6_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000102C) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM6_ARR >> 0) & 0xFFFF), ((TIM6_ARR = (TIM6_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM6_ARR  ------------------------------------
// SVD Line: 16166

//  <rtree> SFDITEM_REG__TIM6_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000102C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM6_ARR >> 0) & 0xFFFFFFFF), ((TIM6_ARR = (TIM6_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM6_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: TIM6  -------------------------------------
// SVD Line: 15819

//  <view> TIM6
//    <name> TIM6 </name>
//    <item> SFDITEM_REG__TIM6_CR1 </item>
//    <item> SFDITEM_REG__TIM6_CR2 </item>
//    <item> SFDITEM_REG__TIM6_DIER </item>
//    <item> SFDITEM_REG__TIM6_SR </item>
//    <item> SFDITEM_REG__TIM6_EGR </item>
//    <item> SFDITEM_REG__TIM6_CNT </item>
//    <item> SFDITEM_REG__TIM6_PSC </item>
//    <item> SFDITEM_REG__TIM6_ARR </item>
//  </view>
//  


// -----------------------------  Register Item Address: TIM7_CR1  --------------------------------
// SVD Line: 15836

unsigned int TIM7_CR1 __AT (0x40001400);



// --------------------------------  Field Item: TIM7_CR1_CEN  ------------------------------------
// SVD Line: 15845

//  <item> SFDITEM_FIELD__TIM7_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40001400) \nCounter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM7_CR1_UDIS  -----------------------------------
// SVD Line: 15866

//  <item> SFDITEM_FIELD__TIM7_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40001400) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM7_CR1_URS  ------------------------------------
// SVD Line: 15890

//  <item> SFDITEM_FIELD__TIM7_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40001400) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generates an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generates an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM7_CR1_OPM  ------------------------------------
// SVD Line: 15913

//  <item> SFDITEM_FIELD__TIM7_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40001400) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the CEN bit). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the CEN bit).
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM7_CR1_ARPE  -----------------------------------
// SVD Line: 15932

//  <item> SFDITEM_FIELD__TIM7_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40001400) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered.\n1 : B_0x1 = TIMx_ARR register is buffered. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered.
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM7_CR1_UIFREMAP  ---------------------------------
// SVD Line: 15951

//  <item> SFDITEM_FIELD__TIM7_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40001400) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_CR1  ------------------------------------
// SVD Line: 15836

//  <rtree> SFDITEM_REG__TIM7_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001400) control register 1 </i>
//    <loc> ( (unsigned int)((TIM7_CR1 >> 0) & 0xFFFFFFFF), ((TIM7_CR1 = (TIM7_CR1 & ~(0x88FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x88F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM7_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM7_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM7_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM7_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM7_CR1_UIFREMAP </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_CR2  --------------------------------
// SVD Line: 15972

unsigned int TIM7_CR2 __AT (0x40001404);



// --------------------------------  Field Item: TIM7_CR2_MMS  ------------------------------------
// SVD Line: 15981

//  <item> SFDITEM_FIELD__TIM7_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40001404) \nMaster mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.\n2 : B_0x2 = Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode.
//        <2=> 2: B_0x2 = Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_CR2  ------------------------------------
// SVD Line: 15972

//  <rtree> SFDITEM_REG__TIM7_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001404) control register 2 </i>
//    <loc> ( (unsigned int)((TIM7_CR2 >> 0) & 0xFFFFFFFF), ((TIM7_CR2 = (TIM7_CR2 & ~(0x70UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x70) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_CR2_MMS </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM7_DIER  --------------------------------
// SVD Line: 16010

unsigned int TIM7_DIER __AT (0x4000140C);



// --------------------------------  Field Item: TIM7_DIER_UIE  -----------------------------------
// SVD Line: 16019

//  <item> SFDITEM_FIELD__TIM7_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000140C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled.\n1 : B_0x1 = Update interrupt enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled.
//        <1=> 1: B_0x1 = Update interrupt enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM7_DIER_UDE  -----------------------------------
// SVD Line: 16038

//  <item> SFDITEM_FIELD__TIM7_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4000140C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled.\n1 : B_0x1 = Update DMA request enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled.
//        <1=> 1: B_0x1 = Update DMA request enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_DIER  -----------------------------------
// SVD Line: 16010

//  <rtree> SFDITEM_REG__TIM7_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000140C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM7_DIER >> 0) & 0xFFFFFFFF), ((TIM7_DIER = (TIM7_DIER & ~(0x101UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x101) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM7_DIER_UDE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_SR  ---------------------------------
// SVD Line: 16059

unsigned int TIM7_SR __AT (0x40001410);



// ---------------------------------  Field Item: TIM7_SR_UIF  ------------------------------------
// SVD Line: 16068

//  <item> SFDITEM_FIELD__TIM7_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40001410) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// ---------------------------------  Register RTree: TIM7_SR  ------------------------------------
// SVD Line: 16059

//  <rtree> SFDITEM_REG__TIM7_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001410) status register </i>
//    <loc> ( (unsigned int)((TIM7_SR >> 0) & 0xFFFFFFFF), ((TIM7_SR = (TIM7_SR & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_SR_UIF </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_EGR  --------------------------------
// SVD Line: 16092

unsigned int TIM7_EGR __AT (0x40001414);



// ---------------------------------  Field Item: TIM7_EGR_UG  ------------------------------------
// SVD Line: 16101

//  <item> SFDITEM_FIELD__TIM7_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40001414) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM7_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_EGR  ------------------------------------
// SVD Line: 16092

//  <rtree> SFDITEM_REG__TIM7_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40001414) event generation register </i>
//    <loc> ( (unsigned int)((TIM7_EGR >> 0) & 0xFFFFFFFF), ((TIM7_EGR = (TIM7_EGR & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_EGR_UG </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_CNT  --------------------------------
// SVD Line: 16123

unsigned int TIM7_CNT __AT (0x40001424);



// --------------------------------  Field Item: TIM7_CNT_CNT  ------------------------------------
// SVD Line: 16132

//  <item> SFDITEM_FIELD__TIM7_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40001424) Counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM7_CNT >> 0) & 0xFFFF), ((TIM7_CNT = (TIM7_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM7_CNT_UIFCPY  ----------------------------------
// SVD Line: 16139

//  <item> SFDITEM_FIELD__TIM7_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40001424) UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0. </i>
//    <check> 
//      <loc> ( (unsigned int) TIM7_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_CNT  ------------------------------------
// SVD Line: 16123

//  <rtree> SFDITEM_REG__TIM7_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001424) counter </i>
//    <loc> ( (unsigned int)((TIM7_CNT >> 0) & 0xFFFFFFFF), ((TIM7_CNT = (TIM7_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM7_CNT_UIFCPY </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_PSC  --------------------------------
// SVD Line: 16149

unsigned int TIM7_PSC __AT (0x40001428);



// --------------------------------  Field Item: TIM7_PSC_PSC  ------------------------------------
// SVD Line: 16158

//  <item> SFDITEM_FIELD__TIM7_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40001428) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM7_PSC >> 0) & 0xFFFF), ((TIM7_PSC = (TIM7_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_PSC  ------------------------------------
// SVD Line: 16149

//  <rtree> SFDITEM_REG__TIM7_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40001428) prescaler </i>
//    <loc> ( (unsigned int)((TIM7_PSC >> 0) & 0xFFFFFFFF), ((TIM7_PSC = (TIM7_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_PSC_PSC </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM7_ARR  --------------------------------
// SVD Line: 16166

unsigned int TIM7_ARR __AT (0x4000142C);



// --------------------------------  Field Item: TIM7_ARR_ARR  ------------------------------------
// SVD Line: 16175

//  <item> SFDITEM_FIELD__TIM7_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000142C) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM7_ARR >> 0) & 0xFFFF), ((TIM7_ARR = (TIM7_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM7_ARR  ------------------------------------
// SVD Line: 16166

//  <rtree> SFDITEM_REG__TIM7_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000142C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM7_ARR >> 0) & 0xFFFFFFFF), ((TIM7_ARR = (TIM7_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM7_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: TIM7  -------------------------------------
// SVD Line: 16185

//  <view> TIM7
//    <name> TIM7 </name>
//    <item> SFDITEM_REG__TIM7_CR1 </item>
//    <item> SFDITEM_REG__TIM7_CR2 </item>
//    <item> SFDITEM_REG__TIM7_DIER </item>
//    <item> SFDITEM_REG__TIM7_SR </item>
//    <item> SFDITEM_REG__TIM7_EGR </item>
//    <item> SFDITEM_REG__TIM7_CNT </item>
//    <item> SFDITEM_REG__TIM7_PSC </item>
//    <item> SFDITEM_REG__TIM7_ARR </item>
//  </view>
//  


// ----------------------------  Register Item Address: TIM14_CR1  --------------------------------
// SVD Line: 16210

unsigned int TIM14_CR1 __AT (0x40002000);



// --------------------------------  Field Item: TIM14_CR1_CEN  -----------------------------------
// SVD Line: 16219

//  <item> SFDITEM_FIELD__TIM14_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40002000) \nCounter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_CR1_UDIS  -----------------------------------
// SVD Line: 16240

//  <item> SFDITEM_FIELD__TIM14_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40002000) \nUpdate disable This bit is set and cleared by software to enable/disable update interrupt (UEV) event generation. Counter overflow Setting the UG bit. Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. An UEV is generated by one of the following events:\n1 : B_0x1 = UEV disabled. No UEV is generated, shadow registers keep their value (ARR, PSC, CCRx). The counter and the prescaler are reinitialized if the UG bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. An UEV is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. No UEV is generated, shadow registers keep their value (ARR, PSC, CCRx). The counter and the prescaler are reinitialized if the UG bit is set.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM14_CR1_URS  -----------------------------------
// SVD Line: 16263

//  <item> SFDITEM_FIELD__TIM14_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40002000) \nUpdate request source This bit is set and cleared by software to select the update interrupt (UEV) sources. Counter overflow Setting the UG bit\n0 : B_0x0 = Any of the following events generate an UEV if enabled:\n1 : B_0x1 = Only counter overflow generates an UEV if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an UEV if enabled:
//        <1=> 1: B_0x1 = Only counter overflow generates an UEV if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM14_CR1_OPM  -----------------------------------
// SVD Line: 16285

//  <item> SFDITEM_FIELD__TIM14_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40002000) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped on the update event\n1 : B_0x1 = Counter stops counting on the next update event (clearing the CEN bit). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped on the update event
//        <1=> 1: B_0x1 = Counter stops counting on the next update event (clearing the CEN bit).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_CR1_ARPE  -----------------------------------
// SVD Line: 16304

//  <item> SFDITEM_FIELD__TIM14_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40002000) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM14_CR1_CKD  -----------------------------------
// SVD Line: 16323

//  <item> SFDITEM_FIELD__TIM14_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40002000) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),\n0 : B_0x0 = tDTS = tCK_INT\n1 : B_0x1 = tDTS = 2  tCK_INT\n2 : B_0x2 = tDTS = 4  tCK_INT\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS = tCK_INT
//        <1=> 1: B_0x1 = tDTS = 2  tCK_INT
//        <2=> 2: B_0x2 = tDTS = 4  tCK_INT
//        <3=> 3: 
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM14_CR1_UIFREMAP  ---------------------------------
// SVD Line: 16348

//  <item> SFDITEM_FIELD__TIM14_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40002000) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_CR1  -----------------------------------
// SVD Line: 16210

//  <rtree> SFDITEM_REG__TIM14_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002000) control register 1 </i>
//    <loc> ( (unsigned int)((TIM14_CR1 >> 0) & 0xFFFFFFFF), ((TIM14_CR1 = (TIM14_CR1 & ~(0xB8FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xB8F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM14_CR1_UIFREMAP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_DIER  -------------------------------
// SVD Line: 16369

unsigned int TIM14_DIER __AT (0x4000200C);



// -------------------------------  Field Item: TIM14_DIER_UIE  -----------------------------------
// SVD Line: 16378

//  <item> SFDITEM_FIELD__TIM14_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4000200C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled\n1 : B_0x1 = Update interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled
//        <1=> 1: B_0x1 = Update interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM14_DIER_CC1IE  ----------------------------------
// SVD Line: 16397

//  <item> SFDITEM_FIELD__TIM14_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4000200C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled\n1 : B_0x1 = CC1 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled
//        <1=> 1: B_0x1 = CC1 interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM14_DIER  -----------------------------------
// SVD Line: 16369

//  <rtree> SFDITEM_REG__TIM14_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000200C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM14_DIER >> 0) & 0xFFFFFFFF), ((TIM14_DIER = (TIM14_DIER & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM14_DIER_CC1IE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM14_SR  --------------------------------
// SVD Line: 16418

unsigned int TIM14_SR __AT (0x40002010);



// --------------------------------  Field Item: TIM14_SR_UIF  ------------------------------------
// SVD Line: 16427

//  <item> SFDITEM_FIELD__TIM14_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40002010) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow and if UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_SR_CC1IF  -----------------------------------
// SVD Line: 16449

//  <item> SFDITEM_FIELD__TIM14_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40002010) \nCapture/compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_SR_CC1OF  -----------------------------------
// SVD Line: 16471

//  <item> SFDITEM_FIELD__TIM14_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40002010) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected.\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected.
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_SR  ------------------------------------
// SVD Line: 16418

//  <rtree> SFDITEM_REG__TIM14_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002010) status register </i>
//    <loc> ( (unsigned int)((TIM14_SR >> 0) & 0xFFFFFFFF), ((TIM14_SR = (TIM14_SR & ~(0x203UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x203) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM14_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM14_SR_CC1OF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_EGR  --------------------------------
// SVD Line: 16493

unsigned int TIM14_EGR __AT (0x40002014);



// --------------------------------  Field Item: TIM14_EGR_UG  ------------------------------------
// SVD Line: 16502

//  <item> SFDITEM_FIELD__TIM14_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40002014) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_EGR_CC1G  -----------------------------------
// SVD Line: 16522

//  <item> SFDITEM_FIELD__TIM14_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40002014) \nCapture/compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_EGR  -----------------------------------
// SVD Line: 16493

//  <rtree> SFDITEM_REG__TIM14_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40002014) event generation register </i>
//    <loc> ( (unsigned int)((TIM14_EGR >> 0) & 0xFFFFFFFF), ((TIM14_EGR = (TIM14_EGR & ~(0x3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM14_EGR_CC1G </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM14_CCMR1_Output  ---------------------------
// SVD Line: 16548

unsigned int TIM14_CCMR1_Output __AT (0x40002018);



// ---------------------------  Field Item: TIM14_CCMR1_Output_CC1S  ------------------------------
// SVD Line: 16558

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40002018) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output.\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1.\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output.
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1.
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM14_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 16579

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40002018) \nOutput compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.\n0 : B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.\n1 : B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. OC is then set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//        <0=> 0: B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.
//        <1=> 1: B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. OC is then set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM14_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 16599

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40002018) \nOutput compare 1 preload enable Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM14_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 16619

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40002018) \nOutput compare 1 mode (refer to bit 16 for OC1M[3]) These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit. Others: Reserved Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT = TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT < TIMx_CCR1 else inactive.\n7 : B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT < TIMx_CCR1 else active </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT = TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT < TIMx_CCR1 else inactive.
//        <7=> 7: B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT < TIMx_CCR1 else active
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM14_CCMR1_Output_OC1M2  ------------------------------
// SVD Line: 16672

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1M2
//    <name> OC1M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40002018) \nOutput compare 1 mode (refer to bit 16 for OC1M[3]) These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit. Others: Reserved Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode. Note: The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Output ) </loc>
//      <o.16..16> OC1M2
//        <0=> 0: B_0x0 = Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: TIM14_CCMR1_Output  -------------------------------
// SVD Line: 16548

//  <rtree> SFDITEM_REG__TIM14_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002018) capture/compare mode register 1 (output  mode) </i>
//    <loc> ( (unsigned int)((TIM14_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM14_CCMR1_Output = (TIM14_CCMR1_Output & ~(0x1007FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1007F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Output_CC1S </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Output_OC1M2 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM14_CCMR1_Input  ----------------------------
// SVD Line: 16727

unsigned int TIM14_CCMR1_Input __AT (0x40002018);



// ---------------------------  Field Item: TIM14_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 16738

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40002018) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Input ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM14_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 16759

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40002018) \nInput capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).\n0 : B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input\n1 : B_0x1 = capture is done once every 2 events\n2 : B_0x2 = capture is done once every 4 events\n3 : B_0x3 = capture is done once every 8 events </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Input ) </loc>
//      <o.3..2> IC1PSC
//        <0=> 0: B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input
//        <1=> 1: B_0x1 = capture is done once every 2 events
//        <2=> 2: B_0x2 = capture is done once every 4 events
//        <3=> 3: B_0x3 = capture is done once every 8 events
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM14_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 16790

//  <item> SFDITEM_FIELD__TIM14_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40002018) \nInput capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCMR1_Input ) </loc>
//      <o.7..4> IC1F
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM14_CCMR1_Input  -------------------------------
// SVD Line: 16727

//  <rtree> SFDITEM_REG__TIM14_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002018) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM14_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM14_CCMR1_Input = (TIM14_CCMR1_Input & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Input_CC1S </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM14_CCMR1_Input_IC1F </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_CCER  -------------------------------
// SVD Line: 16882

unsigned int TIM14_CCER __AT (0x40002020);



// -------------------------------  Field Item: TIM14_CCER_CC1E  ----------------------------------
// SVD Line: 16892

//  <item> SFDITEM_FIELD__TIM14_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40002020) \nCapture/Compare 1 output enable.\n0 : B_0x0 = Capture mode disabled / OC1 is not active\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM14_CCER_CC1P  ----------------------------------
// SVD Line: 16911

//  <item> SFDITEM_FIELD__TIM14_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40002020) \nCapture/Compare 1 output Polarity. When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: This configuration is reserved, it must not be used.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM14_CCER_CC1NP  ----------------------------------
// SVD Line: 16935

//  <item> SFDITEM_FIELD__TIM14_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40002020) Capture/Compare 1 complementary output Polarity. CC1 channel configured as output: CC1NP must be kept cleared. CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description). </i>
//    <check> 
//      <loc> ( (unsigned int) TIM14_CCER ) </loc>
//      <o.3..3> CC1NP
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: TIM14_CCER  -----------------------------------
// SVD Line: 16882

//  <rtree> SFDITEM_REG__TIM14_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002020) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM14_CCER >> 0) & 0xFFFFFFFF), ((TIM14_CCER = (TIM14_CCER & ~(0xBUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xB) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM14_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM14_CCER_CC1NP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_CNT  --------------------------------
// SVD Line: 16946

unsigned int TIM14_CNT __AT (0x40002024);



// --------------------------------  Field Item: TIM14_CNT_CNT  -----------------------------------
// SVD Line: 16955

//  <item> SFDITEM_FIELD__TIM14_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40002024) low counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM14_CNT >> 0) & 0xFFFF), ((TIM14_CNT = (TIM14_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: TIM14_CNT_UIFCPY  ----------------------------------
// SVD Line: 16961

//  <item> SFDITEM_FIELD__TIM14_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40002024) UIF Copy </i>
//    <check> 
//      <loc> ( (unsigned int) TIM14_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_CNT  -----------------------------------
// SVD Line: 16946

//  <rtree> SFDITEM_REG__TIM14_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002024) counter </i>
//    <loc> ( (unsigned int)((TIM14_CNT >> 0) & 0xFFFFFFFF), ((TIM14_CNT = (TIM14_CNT & ~(0x8000FFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x8000FFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM14_CNT_UIFCPY </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_PSC  --------------------------------
// SVD Line: 16969

unsigned int TIM14_PSC __AT (0x40002028);



// --------------------------------  Field Item: TIM14_PSC_PSC  -----------------------------------
// SVD Line: 16978

//  <item> SFDITEM_FIELD__TIM14_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40002028) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM14_PSC >> 0) & 0xFFFF), ((TIM14_PSC = (TIM14_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_PSC  -----------------------------------
// SVD Line: 16969

//  <rtree> SFDITEM_REG__TIM14_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002028) prescaler </i>
//    <loc> ( (unsigned int)((TIM14_PSC >> 0) & 0xFFFFFFFF), ((TIM14_PSC = (TIM14_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_PSC_PSC </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_ARR  --------------------------------
// SVD Line: 16986

unsigned int TIM14_ARR __AT (0x4000202C);



// --------------------------------  Field Item: TIM14_ARR_ARR  -----------------------------------
// SVD Line: 16995

//  <item> SFDITEM_FIELD__TIM14_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000202C) Low Auto-reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM14_ARR >> 0) & 0xFFFF), ((TIM14_ARR = (TIM14_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM14_ARR  -----------------------------------
// SVD Line: 16986

//  <rtree> SFDITEM_REG__TIM14_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000202C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM14_ARR >> 0) & 0xFFFFFFFF), ((TIM14_ARR = (TIM14_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM14_CCR1  -------------------------------
// SVD Line: 17003

unsigned int TIM14_CCR1 __AT (0x40002034);



// -------------------------------  Field Item: TIM14_CCR1_CCR1  ----------------------------------
// SVD Line: 17012

//  <item> SFDITEM_FIELD__TIM14_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40002034) Low Capture/Compare 1  value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM14_CCR1 >> 0) & 0xFFFF), ((TIM14_CCR1 = (TIM14_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM14_CCR1  -----------------------------------
// SVD Line: 17003

//  <rtree> SFDITEM_REG__TIM14_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002034) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM14_CCR1 >> 0) & 0xFFFFFFFF), ((TIM14_CCR1 = (TIM14_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_CCR1_CCR1 </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: TIM14_TISEL  -------------------------------
// SVD Line: 17021

unsigned int TIM14_TISEL __AT (0x40002068);



// -----------------------------  Field Item: TIM14_TISEL_TI1SEL  ---------------------------------
// SVD Line: 17031

//  <item> SFDITEM_FIELD__TIM14_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40002068) \nselects TI1[0] to TI1[15] input Others: Reserved\n0 : B_0x0 = TIM14_CH1 input\n1 : B_0x1 = RTC CLK\n2 : B_0x2 = HSE/32\n3 : B_0x3 = MCO\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM14_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM14_CH1 input
//        <1=> 1: B_0x1 = RTC CLK
//        <2=> 2: B_0x2 = HSE/32
//        <3=> 3: B_0x3 = MCO
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM14_TISEL  ----------------------------------
// SVD Line: 17021

//  <rtree> SFDITEM_REG__TIM14_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002068) TIM timer input selection  register </i>
//    <loc> ( (unsigned int)((TIM14_TISEL >> 0) & 0xFFFFFFFF), ((TIM14_TISEL = (TIM14_TISEL & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM14_TISEL_TI1SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: TIM14  -------------------------------------
// SVD Line: 16194

//  <view> TIM14
//    <name> TIM14 </name>
//    <item> SFDITEM_REG__TIM14_CR1 </item>
//    <item> SFDITEM_REG__TIM14_DIER </item>
//    <item> SFDITEM_REG__TIM14_SR </item>
//    <item> SFDITEM_REG__TIM14_EGR </item>
//    <item> SFDITEM_REG__TIM14_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM14_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM14_CCER </item>
//    <item> SFDITEM_REG__TIM14_CNT </item>
//    <item> SFDITEM_REG__TIM14_PSC </item>
//    <item> SFDITEM_REG__TIM14_ARR </item>
//    <item> SFDITEM_REG__TIM14_CCR1 </item>
//    <item> SFDITEM_REG__TIM14_TISEL </item>
//  </view>
//  


// ----------------------------  Register Item Address: TIM15_CR1  --------------------------------
// SVD Line: 17081

unsigned int TIM15_CR1 __AT (0x40014000);



// --------------------------------  Field Item: TIM15_CR1_CEN  -----------------------------------
// SVD Line: 17090

//  <item> SFDITEM_FIELD__TIM15_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014000) \nCounter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR1_UDIS  -----------------------------------
// SVD Line: 17110

//  <item> SFDITEM_FIELD__TIM15_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014000) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_CR1_URS  -----------------------------------
// SVD Line: 17134

//  <item> SFDITEM_FIELD__TIM15_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014000) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt if enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt if enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_CR1_OPM  -----------------------------------
// SVD Line: 17157

//  <item> SFDITEM_FIELD__TIM15_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014000) \nOne-pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR1_ARPE  -----------------------------------
// SVD Line: 17176

//  <item> SFDITEM_FIELD__TIM15_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014000) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_CR1_CKD  -----------------------------------
// SVD Line: 17195

//  <item> SFDITEM_FIELD__TIM15_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014000) \nClock division This bitfield indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS) used by the dead-time generators and the digital filters (TIx)\n0 : B_0x0 = tDTS = tCK_INT\n1 : B_0x1 = tDTS = 2*tCK_INT\n2 : B_0x2 = tDTS = 4*tCK_INT\n3 : B_0x3 = Reserved, do not program this value </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS = tCK_INT
//        <1=> 1: B_0x1 = tDTS = 2*tCK_INT
//        <2=> 2: B_0x2 = tDTS = 4*tCK_INT
//        <3=> 3: B_0x3 = Reserved, do not program this value
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM15_CR1_UIFREMAP  ---------------------------------
// SVD Line: 17225

//  <item> SFDITEM_FIELD__TIM15_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014000) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_CR1  -----------------------------------
// SVD Line: 17081

//  <rtree> SFDITEM_REG__TIM15_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014000) control register 1 </i>
//    <loc> ( (unsigned int)((TIM15_CR1 >> 0) & 0xFFFFFFFF), ((TIM15_CR1 = (TIM15_CR1 & ~(0xB8FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xB8F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM15_CR1_UIFREMAP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_CR2  --------------------------------
// SVD Line: 17246

unsigned int TIM15_CR2 __AT (0x40014004);



// -------------------------------  Field Item: TIM15_CR2_CCPC  -----------------------------------
// SVD Line: 17255

//  <item> SFDITEM_FIELD__TIM15_CR2_CCPC
//    <name> CCPC </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014004) \nCapture/compare preloaded control Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded\n1 : B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.0..0> CCPC
//        <0=> 0: B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded
//        <1=> 1: B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_CCUS  -----------------------------------
// SVD Line: 17275

//  <item> SFDITEM_FIELD__TIM15_CR2_CCUS
//    <name> CCUS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014004) \nCapture/compare control update selection Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.\n1 : B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.2..2> CCUS
//        <0=> 0: B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.
//        <1=> 1: B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_CCDS  -----------------------------------
// SVD Line: 17295

//  <item> SFDITEM_FIELD__TIM15_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014004) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_CR2_MMS  -----------------------------------
// SVD Line: 17314

//  <item> SFDITEM_FIELD__TIM15_CR2_MMS
//    <name> MMS </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40014004) \nMaster mode selection These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\n0 : B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.\n1 : B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\n2 : B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.\n3 : B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).\n4 : B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO).\n5 : B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO).\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.6..4> MMS
//        <0=> 0: B_0x0 = Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
//        <1=> 1: B_0x1 = Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic AND between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
//        <2=> 2: B_0x2 = Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
//        <3=> 3: B_0x3 = Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).
//        <4=> 4: B_0x4 = Compare - OC1REFC signal is used as trigger output (TRGO).
//        <5=> 5: B_0x5 = Compare - OC2REFC signal is used as trigger output (TRGO).
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_TI1S  -----------------------------------
// SVD Line: 17354

//  <item> SFDITEM_FIELD__TIM15_CR2_TI1S
//    <name> TI1S </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014004) \nTI1 selection\n0 : B_0x0 = The TIMx_CH1 pin is connected to TI1 input\n1 : B_0x1 = The TIMx_CH1, CH2 pins are connected to the TI1 input (XOR combination) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.7..7> TI1S
//        <0=> 0: B_0x0 = The TIMx_CH1 pin is connected to TI1 input
//        <1=> 1: B_0x1 = The TIMx_CH1, CH2 pins are connected to the TI1 input (XOR combination)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_OIS1  -----------------------------------
// SVD Line: 17373

//  <item> SFDITEM_FIELD__TIM15_CR2_OIS1
//    <name> OIS1 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40014004) \nOutput Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register).\n0 : B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0\n1 : B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.8..8> OIS1
//        <0=> 0: B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
//        <1=> 1: B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_OIS1N  ----------------------------------
// SVD Line: 17393

//  <item> SFDITEM_FIELD__TIM15_CR2_OIS1N
//    <name> OIS1N </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014004) \nOutput Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register).\n0 : B_0x0 = OC1N=0 after a dead-time when MOE=0\n1 : B_0x1 = OC1N=1 after a dead-time when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.9..9> OIS1N
//        <0=> 0: B_0x0 = OC1N=0 after a dead-time when MOE=0
//        <1=> 1: B_0x1 = OC1N=1 after a dead-time when MOE=0
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CR2_OIS2  -----------------------------------
// SVD Line: 17413

//  <item> SFDITEM_FIELD__TIM15_CR2_OIS2
//    <name> OIS2 </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014004) \nOutput idle state 2 (OC2 output) Note: This bit cannot be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in the TIM15_BDTR register).\n0 : B_0x0 = OC2=0 when MOE=0\n1 : B_0x1 = OC2=1 when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CR2 ) </loc>
//      <o.10..10> OIS2
//        <0=> 0: B_0x0 = OC2=0 when MOE=0
//        <1=> 1: B_0x1 = OC2=1 when MOE=0
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_CR2  -----------------------------------
// SVD Line: 17246

//  <rtree> SFDITEM_REG__TIM15_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014004) control register 2 </i>
//    <loc> ( (unsigned int)((TIM15_CR2 >> 0) & 0xFFFFFFFF), ((TIM15_CR2 = (TIM15_CR2 & ~(0x7FDUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7FD) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CR2_CCPC </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_CCUS </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_MMS </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_TI1S </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_OIS1 </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_OIS1N </item>
//    <item> SFDITEM_FIELD__TIM15_CR2_OIS2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_SMCR  -------------------------------
// SVD Line: 17435

unsigned int TIM15_SMCR __AT (0x40014008);



// -------------------------------  Field Item: TIM15_SMCR_SMS1  ----------------------------------
// SVD Line: 17444

//  <item> SFDITEM_FIELD__TIM15_SMCR_SMS1
//    <name> SMS1 </name>
//    <rw> 
//    <i> [Bits 2..0] RW (@ 0x40014008) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Other codes: reserved. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : Reserved - do not use\n2 : Reserved - do not use\n3 : Reserved - do not use\n4 : B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.\n5 : B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.\n6 : B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.\n7 : B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SMCR ) </loc>
//      <o.2..0> SMS1
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: 
//        <2=> 2: 
//        <3=> 3: 
//        <4=> 4: B_0x4 = Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
//        <5=> 5: B_0x5 = Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
//        <6=> 6: B_0x6 = Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
//        <7=> 7: B_0x7 = External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SMCR_TS1  -----------------------------------
// SVD Line: 17487

//  <item> SFDITEM_FIELD__TIM15_SMCR_TS1
//    <name> TS1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40014008) \nTrigger selection This bit field selects the trigger input to be used to synchronize the counter. Other: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3)\n4 : B_0x4 = TI1 Edge Detector (TI1F_ED)\n5 : B_0x5 = Filtered Timer Input 1 (TI1FP1)\n6 : B_0x6 = Filtered Timer Input 2 (TI2FP2)\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SMCR ) </loc>
//      <o.6..4> TS1
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//        <4=> 4: B_0x4 = TI1 Edge Detector (TI1F_ED)
//        <5=> 5: B_0x5 = Filtered Timer Input 1 (TI1FP1)
//        <6=> 6: B_0x6 = Filtered Timer Input 2 (TI2FP2)
//        <7=> 7: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SMCR_MSM  -----------------------------------
// SVD Line: 17535

//  <item> SFDITEM_FIELD__TIM15_SMCR_MSM
//    <name> MSM </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014008) \nMaster/slave mode\n0 : B_0x0 = No action\n1 : B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SMCR ) </loc>
//      <o.7..7> MSM
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SMCR_SMS2  ----------------------------------
// SVD Line: 17554

//  <item> SFDITEM_FIELD__TIM15_SMCR_SMS2
//    <name> SMS2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40014008) \nSlave mode selection When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description. Other codes: reserved. Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal. Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.\n0 : B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.\n1 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SMCR ) </loc>
//      <o.16..16> SMS2
//        <0=> 0: B_0x0 = Slave mode disabled - if CEN = '1 then the prescaler is clocked directly by the internal clock.
//        <1=> 1: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SMCR_TS2  -----------------------------------
// SVD Line: 17597

//  <item> SFDITEM_FIELD__TIM15_SMCR_TS2
//    <name> TS2 </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40014008) \nTrigger selection This bit field selects the trigger input to be used to synchronize the counter. Other: Reserved See for more details on ITRx meaning for each Timer. Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.\n0 : B_0x0 = Internal Trigger 0 (ITR0)\n1 : B_0x1 = Internal Trigger 1 (ITR1)\n2 : B_0x2 = Internal Trigger 2 (ITR2)\n3 : B_0x3 = Internal Trigger 3 (ITR3) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SMCR ) </loc>
//      <o.21..20> TS2
//        <0=> 0: B_0x0 = Internal Trigger 0 (ITR0)
//        <1=> 1: B_0x1 = Internal Trigger 1 (ITR1)
//        <2=> 2: B_0x2 = Internal Trigger 2 (ITR2)
//        <3=> 3: B_0x3 = Internal Trigger 3 (ITR3)
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_SMCR  -----------------------------------
// SVD Line: 17435

//  <rtree> SFDITEM_REG__TIM15_SMCR
//    <name> SMCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014008) slave mode control register </i>
//    <loc> ( (unsigned int)((TIM15_SMCR >> 0) & 0xFFFFFFFF), ((TIM15_SMCR = (TIM15_SMCR & ~(0x3100F7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3100F7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_SMCR_SMS1 </item>
//    <item> SFDITEM_FIELD__TIM15_SMCR_TS1 </item>
//    <item> SFDITEM_FIELD__TIM15_SMCR_MSM </item>
//    <item> SFDITEM_FIELD__TIM15_SMCR_SMS2 </item>
//    <item> SFDITEM_FIELD__TIM15_SMCR_TS2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_DIER  -------------------------------
// SVD Line: 17647

unsigned int TIM15_DIER __AT (0x4001400C);



// -------------------------------  Field Item: TIM15_DIER_UIE  -----------------------------------
// SVD Line: 17656

//  <item> SFDITEM_FIELD__TIM15_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4001400C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled\n1 : B_0x1 = Update interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled
//        <1=> 1: B_0x1 = Update interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_CC1IE  ----------------------------------
// SVD Line: 17675

//  <item> SFDITEM_FIELD__TIM15_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4001400C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled\n1 : B_0x1 = CC1 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled
//        <1=> 1: B_0x1 = CC1 interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_CC2IE  ----------------------------------
// SVD Line: 17694

//  <item> SFDITEM_FIELD__TIM15_DIER_CC2IE
//    <name> CC2IE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x4001400C) \nCapture/Compare 2 interrupt enable\n0 : B_0x0 = CC2 interrupt disabled\n1 : B_0x1 = CC2 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.2..2> CC2IE
//        <0=> 0: B_0x0 = CC2 interrupt disabled
//        <1=> 1: B_0x1 = CC2 interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_COMIE  ----------------------------------
// SVD Line: 17713

//  <item> SFDITEM_FIELD__TIM15_DIER_COMIE
//    <name> COMIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x4001400C) \nCOM interrupt enable\n0 : B_0x0 = COM interrupt disabled\n1 : B_0x1 = COM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.5..5> COMIE
//        <0=> 0: B_0x0 = COM interrupt disabled
//        <1=> 1: B_0x1 = COM interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_DIER_TIE  -----------------------------------
// SVD Line: 17732

//  <item> SFDITEM_FIELD__TIM15_DIER_TIE
//    <name> TIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x4001400C) \nTrigger interrupt enable\n0 : B_0x0 = Trigger interrupt disabled\n1 : B_0x1 = Trigger interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.6..6> TIE
//        <0=> 0: B_0x0 = Trigger interrupt disabled
//        <1=> 1: B_0x1 = Trigger interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_DIER_BIE  -----------------------------------
// SVD Line: 17751

//  <item> SFDITEM_FIELD__TIM15_DIER_BIE
//    <name> BIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x4001400C) \nBreak interrupt enable\n0 : B_0x0 = Break interrupt disabled\n1 : B_0x1 = Break interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.7..7> BIE
//        <0=> 0: B_0x0 = Break interrupt disabled
//        <1=> 1: B_0x1 = Break interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_DIER_UDE  -----------------------------------
// SVD Line: 17770

//  <item> SFDITEM_FIELD__TIM15_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4001400C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled\n1 : B_0x1 = Update DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled
//        <1=> 1: B_0x1 = Update DMA request enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_CC1DE  ----------------------------------
// SVD Line: 17789

//  <item> SFDITEM_FIELD__TIM15_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4001400C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled\n1 : B_0x1 = CC1 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled
//        <1=> 1: B_0x1 = CC1 DMA request enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_CC2DE  ----------------------------------
// SVD Line: 17808

//  <item> SFDITEM_FIELD__TIM15_DIER_CC2DE
//    <name> CC2DE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x4001400C) \nCapture/Compare 2 DMA request enable\n0 : B_0x0 = CC2 DMA request disabled\n1 : B_0x1 = CC2 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.10..10> CC2DE
//        <0=> 0: B_0x0 = CC2 DMA request disabled
//        <1=> 1: B_0x1 = CC2 DMA request enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_DIER_COMDE  ----------------------------------
// SVD Line: 17827

//  <item> SFDITEM_FIELD__TIM15_DIER_COMDE
//    <name> COMDE </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x4001400C) \nCOM DMA request enable\n0 : B_0x0 = COM DMA request disabled\n1 : B_0x1 = COM DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.13..13> COMDE
//        <0=> 0: B_0x0 = COM DMA request disabled
//        <1=> 1: B_0x1 = COM DMA request enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_DIER_TDE  -----------------------------------
// SVD Line: 17846

//  <item> SFDITEM_FIELD__TIM15_DIER_TDE
//    <name> TDE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x4001400C) \nTrigger DMA request enable\n0 : B_0x0 = Trigger DMA request disabled\n1 : B_0x1 = Trigger DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DIER ) </loc>
//      <o.14..14> TDE
//        <0=> 0: B_0x0 = Trigger DMA request disabled
//        <1=> 1: B_0x1 = Trigger DMA request enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_DIER  -----------------------------------
// SVD Line: 17647

//  <rtree> SFDITEM_REG__TIM15_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001400C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM15_DIER >> 0) & 0xFFFFFFFF), ((TIM15_DIER = (TIM15_DIER & ~(0x67E7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x67E7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_CC2IE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_COMIE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_TIE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_BIE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_CC1DE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_CC2DE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_COMDE </item>
//    <item> SFDITEM_FIELD__TIM15_DIER_TDE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM15_SR  --------------------------------
// SVD Line: 17867

unsigned int TIM15_SR __AT (0x40014010);



// --------------------------------  Field Item: TIM15_SR_UIF  ------------------------------------
// SVD Line: 17876

//  <item> SFDITEM_FIELD__TIM15_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014010) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by a trigger event (refer to control register (TIM15_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SR_CC1IF  -----------------------------------
// SVD Line: 17899

//  <item> SFDITEM_FIELD__TIM15_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014010) \nCapture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SR_CC2IF  -----------------------------------
// SVD Line: 17921

//  <item> SFDITEM_FIELD__TIM15_SR_CC2IF
//    <name> CC2IF </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014010) Capture/Compare 2 interrupt flag refer to CC1IF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.2..2> CC2IF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SR_COMIF  -----------------------------------
// SVD Line: 17929

//  <item> SFDITEM_FIELD__TIM15_SR_COMIF
//    <name> COMIF </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40014010) \nCOM interrupt flag This flag is set by hardware on a COM event (once the capture/compare control bits CCxE, CCxNE, OCxM have been updated). It is cleared by software.\n0 : B_0x0 = No COM event occurred\n1 : B_0x1 = COM interrupt pending </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.5..5> COMIF
//        <0=> 0: B_0x0 = No COM event occurred
//        <1=> 1: B_0x1 = COM interrupt pending
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_SR_TIF  ------------------------------------
// SVD Line: 17949

//  <item> SFDITEM_FIELD__TIM15_SR_TIF
//    <name> TIF </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40014010) \nTrigger interrupt flag This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode, both edges in case gated mode is selected). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.\n0 : B_0x0 = No trigger event occurred\n1 : B_0x1 = Trigger interrupt pending </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.6..6> TIF
//        <0=> 0: B_0x0 = No trigger event occurred
//        <1=> 1: B_0x1 = Trigger interrupt pending
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_SR_BIF  ------------------------------------
// SVD Line: 17969

//  <item> SFDITEM_FIELD__TIM15_SR_BIF
//    <name> BIF </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014010) \nBreak interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.\n0 : B_0x0 = No break event occurred\n1 : B_0x1 = An active level has been detected on the break input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.7..7> BIF
//        <0=> 0: B_0x0 = No break event occurred
//        <1=> 1: B_0x1 = An active level has been detected on the break input
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SR_CC1OF  -----------------------------------
// SVD Line: 17989

//  <item> SFDITEM_FIELD__TIM15_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014010) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_SR_CC2OF  -----------------------------------
// SVD Line: 18009

//  <item> SFDITEM_FIELD__TIM15_SR_CC2OF
//    <name> CC2OF </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014010) Capture/Compare 2 overcapture flag Refer to CC1OF description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_SR ) </loc>
//      <o.10..10> CC2OF
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_SR  ------------------------------------
// SVD Line: 17867

//  <rtree> SFDITEM_REG__TIM15_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014010) status register </i>
//    <loc> ( (unsigned int)((TIM15_SR >> 0) & 0xFFFFFFFF), ((TIM15_SR = (TIM15_SR & ~(0x6E7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x6E7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_CC2IF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_COMIF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_TIF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_BIF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_CC1OF </item>
//    <item> SFDITEM_FIELD__TIM15_SR_CC2OF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_EGR  --------------------------------
// SVD Line: 18019

unsigned int TIM15_EGR __AT (0x40014014);



// --------------------------------  Field Item: TIM15_EGR_UG  ------------------------------------
// SVD Line: 18028

//  <item> SFDITEM_FIELD__TIM15_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40014014) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_EGR_CC1G  -----------------------------------
// SVD Line: 18048

//  <item> SFDITEM_FIELD__TIM15_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40014014) \nCapture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_EGR_CC2G  -----------------------------------
// SVD Line: 18072

//  <item> SFDITEM_FIELD__TIM15_EGR_CC2G
//    <name> CC2G </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40014014) Capture/Compare 2 generation Refer to CC1G description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.2..2> CC2G
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM15_EGR_COMG  -----------------------------------
// SVD Line: 18080

//  <item> SFDITEM_FIELD__TIM15_EGR_COMG
//    <name> COMG </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40014014) \nCapture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware. Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = No action\n1 : B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.5..5> COMG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_EGR_TG  ------------------------------------
// SVD Line: 18101

//  <item> SFDITEM_FIELD__TIM15_EGR_TG
//    <name> TG </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40014014) \nTrigger generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.6..6> TG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_EGR_BG  ------------------------------------
// SVD Line: 18121

//  <item> SFDITEM_FIELD__TIM15_EGR_BG
//    <name> BG </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40014014) \nBreak generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action\n1 : B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_EGR ) </loc>
//      <o.7..7> BG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_EGR  -----------------------------------
// SVD Line: 18019

//  <rtree> SFDITEM_REG__TIM15_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40014014) event generation register </i>
//    <loc> ( (unsigned int)((TIM15_EGR >> 0) & 0xFFFFFFFF), ((TIM15_EGR = (TIM15_EGR & ~(0xE7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM15_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM15_EGR_CC2G </item>
//    <item> SFDITEM_FIELD__TIM15_EGR_COMG </item>
//    <item> SFDITEM_FIELD__TIM15_EGR_TG </item>
//    <item> SFDITEM_FIELD__TIM15_EGR_BG </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM15_CCMR1_Output  ---------------------------
// SVD Line: 18143

unsigned int TIM15_CCMR1_Output __AT (0x40014018);



// ---------------------------  Field Item: TIM15_CCMR1_Output_CC1S  ------------------------------
// SVD Line: 18153

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014018) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output.\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1.\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2.\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output.
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1.
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2.
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 18184

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014018) \nOutput Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.\n0 : B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.\n1 : B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//        <0=> 0: B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.
//        <1=> 1: B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 18204

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014018) \nOutput Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 18225

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40014018) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. On channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.\n7 : B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.
//        <7=> 7: B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM15_CCMR1_Output_CC2S  ------------------------------
// SVD Line: 18299

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014018) \nCapture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output.\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output.
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2.
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1.
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC2FE  ------------------------------
// SVD Line: 18330

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2FE
//    <name> OC2FE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014018) Output Compare 2 fast enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.10..10> OC2FE
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC2PE  ------------------------------
// SVD Line: 18337

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2PE
//    <name> OC2PE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014018) Output Compare 2 preload enable </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.11..11> OC2PE
//    </check>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC2M1  ------------------------------
// SVD Line: 18344

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2M1
//    <name> OC2M1 </name>
//    <rw> 
//    <i> [Bits 14..12] RW (@ 0x40014018) Output Compare 2 mode </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM15_CCMR1_Output >> 12) & 0x7), ((TIM15_CCMR1_Output = (TIM15_CCMR1_Output & ~(0x7UL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC1M2  ------------------------------
// SVD Line: 18351

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1M2
//    <name> OC1M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40014018) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. On channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.16..16> OC1M2
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Output_OC2M2  ------------------------------
// SVD Line: 18425

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2M2
//    <name> OC2M2 </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40014018) Output Compare 2 mode </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Output ) </loc>
//      <o.24..24> OC2M2
//    </check>
//  </item>
//  


// ---------------------------  Register RTree: TIM15_CCMR1_Output  -------------------------------
// SVD Line: 18143

//  <rtree> SFDITEM_REG__TIM15_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014018) capture/compare mode register (output  mode) </i>
//    <loc> ( (unsigned int)((TIM15_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM15_CCMR1_Output = (TIM15_CCMR1_Output & ~(0x1017F7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1017F7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_CC1S </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_CC2S </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2FE </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2PE </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2M1 </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC1M2 </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Output_OC2M2 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM15_CCMR1_Input  ----------------------------
// SVD Line: 18434

unsigned int TIM15_CCMR1_Input __AT (0x40014018);



// ---------------------------  Field Item: TIM15_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 18445

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014018) \nCapture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2\n3 : B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Input ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: B_0x2 = CC1 channel is configured as input, IC1 is mapped on TI2
//        <3=> 3: B_0x3 = CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 18476

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40014018) \nInput capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).\n0 : B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input\n1 : B_0x1 = capture is done once every 2 events\n2 : B_0x2 = capture is done once every 4 events\n3 : B_0x3 = capture is done once every 8 events </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Input ) </loc>
//      <o.3..2> IC1PSC
//        <0=> 0: B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input
//        <1=> 1: B_0x1 = capture is done once every 2 events
//        <2=> 2: B_0x2 = capture is done once every 4 events
//        <3=> 3: B_0x3 = capture is done once every 8 events
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM15_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 18506

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40014018) \nInput capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Input ) </loc>
//      <o.7..4> IC1F
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM15_CCMR1_Input_CC2S  -------------------------------
// SVD Line: 18596

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_CC2S
//    <name> CC2S </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014018) \nCapture/Compare 2 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Note: CC2S bits are writable only when the channel is OFF (CC2E = '0 in TIMx_CCER).\n0 : B_0x0 = CC2 channel is configured as output\n1 : B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2\n2 : B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1\n3 : B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCMR1_Input ) </loc>
//      <o.9..8> CC2S
//        <0=> 0: B_0x0 = CC2 channel is configured as output
//        <1=> 1: B_0x1 = CC2 channel is configured as input, IC2 is mapped on TI2
//        <2=> 2: B_0x2 = CC2 channel is configured as input, IC2 is mapped on TI1
//        <3=> 3: B_0x3 = CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM15_CCMR1_Input_IC2PSC  ------------------------------
// SVD Line: 18627

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC2PSC
//    <name> IC2PSC </name>
//    <rw> 
//    <i> [Bits 11..10] RW (@ 0x40014018) Input capture 2 prescaler </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM15_CCMR1_Input >> 10) & 0x3), ((TIM15_CCMR1_Input = (TIM15_CCMR1_Input & ~(0x3UL << 10 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3) << 10 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Field Item: TIM15_CCMR1_Input_IC2F  -------------------------------
// SVD Line: 18634

//  <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC2F
//    <name> IC2F </name>
//    <rw> 
//    <i> [Bits 15..12] RW (@ 0x40014018) Input capture 2 filter </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM15_CCMR1_Input >> 12) & 0xF), ((TIM15_CCMR1_Input = (TIM15_CCMR1_Input & ~(0xFUL << 12 )) | ((unsigned long)(Gui_u8:GuiVal & 0xF) << 12 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ----------------------------  Register RTree: TIM15_CCMR1_Input  -------------------------------
// SVD Line: 18434

//  <rtree> SFDITEM_REG__TIM15_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014018) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM15_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM15_CCMR1_Input = (TIM15_CCMR1_Input & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_CC1S </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC1F </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_CC2S </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC2PSC </item>
//    <item> SFDITEM_FIELD__TIM15_CCMR1_Input_IC2F </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_CCER  -------------------------------
// SVD Line: 18643

unsigned int TIM15_CCER __AT (0x40014020);



// -------------------------------  Field Item: TIM15_CCER_CC1E  ----------------------------------
// SVD Line: 18653

//  <item> SFDITEM_FIELD__TIM15_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014020) \nCapture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details.\n0 : B_0x0 = Capture mode disabled / OC1 is not active (see below)\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active (see below)
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CCER_CC1P  ----------------------------------
// SVD Line: 18673

//  <item> SFDITEM_FIELD__TIM15_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014020) \nCapture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: this configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_CCER_CC1NE  ----------------------------------
// SVD Line: 18699

//  <item> SFDITEM_FIELD__TIM15_CCER_CC1NE
//    <name> CC1NE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014020) \nCapture/Compare 1 complementary output enable\n0 : B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.\n1 : B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.2..2> CC1NE
//        <0=> 0: B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//        <1=> 1: B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_CCER_CC1NP  ----------------------------------
// SVD Line: 18718

//  <item> SFDITEM_FIELD__TIM15_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014020) \nCapture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1N active high\n1 : B_0x1 = OC1N active low </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.3..3> CC1NP
//        <0=> 0: B_0x0 = OC1N active high
//        <1=> 1: B_0x1 = OC1N active low
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CCER_CC2E  ----------------------------------
// SVD Line: 18743

//  <item> SFDITEM_FIELD__TIM15_CCER_CC2E
//    <name> CC2E </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40014020) Capture/Compare 2 output enable Refer to CC1E description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.4..4> CC2E
//    </check>
//  </item>
//  


// -------------------------------  Field Item: TIM15_CCER_CC2P  ----------------------------------
// SVD Line: 18751

//  <item> SFDITEM_FIELD__TIM15_CCER_CC2P
//    <name> CC2P </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40014020) Capture/Compare 2 output polarity Refer to CC1P description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.5..5> CC2P
//    </check>
//  </item>
//  


// ------------------------------  Field Item: TIM15_CCER_CC2NP  ----------------------------------
// SVD Line: 18759

//  <item> SFDITEM_FIELD__TIM15_CCER_CC2NP
//    <name> CC2NP </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014020) Capture/Compare 2 complementary output polarity Refer to CC1NP description </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CCER ) </loc>
//      <o.7..7> CC2NP
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_CCER  -----------------------------------
// SVD Line: 18643

//  <rtree> SFDITEM_REG__TIM15_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014020) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM15_CCER >> 0) & 0xFFFFFFFF), ((TIM15_CCER = (TIM15_CCER & ~(0xBFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xBF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC1NE </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC1NP </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC2E </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC2P </item>
//    <item> SFDITEM_FIELD__TIM15_CCER_CC2NP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_CNT  --------------------------------
// SVD Line: 18769

unsigned int TIM15_CNT __AT (0x40014024);



// --------------------------------  Field Item: TIM15_CNT_CNT  -----------------------------------
// SVD Line: 18777

//  <item> SFDITEM_FIELD__TIM15_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014024) counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_CNT >> 0) & 0xFFFF), ((TIM15_CNT = (TIM15_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: TIM15_CNT_UIFCPY  ----------------------------------
// SVD Line: 18784

//  <item> SFDITEM_FIELD__TIM15_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40014024) UIF Copy </i>
//    <check> 
//      <loc> ( (unsigned int) TIM15_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_CNT  -----------------------------------
// SVD Line: 18769

//  <rtree> SFDITEM_REG__TIM15_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014024) counter </i>
//    <loc> ( (unsigned int)((TIM15_CNT >> 0) & 0xFFFFFFFF), ((TIM15_CNT = (TIM15_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM15_CNT_UIFCPY </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_PSC  --------------------------------
// SVD Line: 18793

unsigned int TIM15_PSC __AT (0x40014028);



// --------------------------------  Field Item: TIM15_PSC_PSC  -----------------------------------
// SVD Line: 18802

//  <item> SFDITEM_FIELD__TIM15_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014028) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_PSC >> 0) & 0xFFFF), ((TIM15_PSC = (TIM15_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_PSC  -----------------------------------
// SVD Line: 18793

//  <rtree> SFDITEM_REG__TIM15_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014028) prescaler </i>
//    <loc> ( (unsigned int)((TIM15_PSC >> 0) & 0xFFFFFFFF), ((TIM15_PSC = (TIM15_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_PSC_PSC </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_ARR  --------------------------------
// SVD Line: 18810

unsigned int TIM15_ARR __AT (0x4001402C);



// --------------------------------  Field Item: TIM15_ARR_ARR  -----------------------------------
// SVD Line: 18819

//  <item> SFDITEM_FIELD__TIM15_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001402C) Auto-reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_ARR >> 0) & 0xFFFF), ((TIM15_ARR = (TIM15_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_ARR  -----------------------------------
// SVD Line: 18810

//  <rtree> SFDITEM_REG__TIM15_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001402C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM15_ARR >> 0) & 0xFFFFFFFF), ((TIM15_ARR = (TIM15_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_RCR  --------------------------------
// SVD Line: 18827

unsigned int TIM15_RCR __AT (0x40014030);



// --------------------------------  Field Item: TIM15_RCR_REP  -----------------------------------
// SVD Line: 18836

//  <item> SFDITEM_FIELD__TIM15_RCR_REP
//    <name> REP </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014030) Repetition counter value </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM15_RCR >> 0) & 0xFF), ((TIM15_RCR = (TIM15_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_RCR  -----------------------------------
// SVD Line: 18827

//  <rtree> SFDITEM_REG__TIM15_RCR
//    <name> RCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014030) repetition counter register </i>
//    <loc> ( (unsigned int)((TIM15_RCR >> 0) & 0xFFFFFFFF), ((TIM15_RCR = (TIM15_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_RCR_REP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_CCR1  -------------------------------
// SVD Line: 18844

unsigned int TIM15_CCR1 __AT (0x40014034);



// -------------------------------  Field Item: TIM15_CCR1_CCR1  ----------------------------------
// SVD Line: 18853

//  <item> SFDITEM_FIELD__TIM15_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014034) Capture/Compare 1 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_CCR1 >> 0) & 0xFFFF), ((TIM15_CCR1 = (TIM15_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_CCR1  -----------------------------------
// SVD Line: 18844

//  <rtree> SFDITEM_REG__TIM15_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014034) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM15_CCR1 >> 0) & 0xFFFFFFFF), ((TIM15_CCR1 = (TIM15_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CCR1_CCR1 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_CCR2  -------------------------------
// SVD Line: 18861

unsigned int TIM15_CCR2 __AT (0x40014038);



// -------------------------------  Field Item: TIM15_CCR2_CCR2  ----------------------------------
// SVD Line: 18870

//  <item> SFDITEM_FIELD__TIM15_CCR2_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014038) Capture/Compare 2 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_CCR2 >> 0) & 0xFFFF), ((TIM15_CCR2 = (TIM15_CCR2 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_CCR2  -----------------------------------
// SVD Line: 18861

//  <rtree> SFDITEM_REG__TIM15_CCR2
//    <name> CCR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014038) capture/compare register 2 </i>
//    <loc> ( (unsigned int)((TIM15_CCR2 >> 0) & 0xFFFFFFFF), ((TIM15_CCR2 = (TIM15_CCR2 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_CCR2_CCR2 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_BDTR  -------------------------------
// SVD Line: 18878

unsigned int TIM15_BDTR __AT (0x40014044);



// -------------------------------  Field Item: TIM15_BDTR_DTG  -----------------------------------
// SVD Line: 18887

//  <item> SFDITEM_FIELD__TIM15_BDTR_DTG
//    <name> DTG </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014044) Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS Example if TDTS=125ns (8MHz), dead-time possible values are: 0 to 15875 ns by 125 ns steps, 16 s to 31750 ns by 250 ns steps, 32 s to 63 s by 1 s steps, 64 s to 126 s by 2 s steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM15_BDTR >> 0) & 0xFF), ((TIM15_BDTR = (TIM15_BDTR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_LOCK  ----------------------------------
// SVD Line: 18905

//  <item> SFDITEM_FIELD__TIM15_BDTR_LOCK
//    <name> LOCK </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014044) \nLock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.\n0 : B_0x0 = LOCK OFF - No bit is write protected\n1 : B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written\n2 : B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.\n3 : B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.9..8> LOCK
//        <0=> 0: B_0x0 = LOCK OFF - No bit is write protected
//        <1=> 1: B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written
//        <2=> 2: B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
//        <3=> 3: B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_OSSI  ----------------------------------
// SVD Line: 18936

//  <item> SFDITEM_FIELD__TIM15_BDTR_OSSI
//    <name> OSSI </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014044) \nOff-state selection for Idle mode This bit is used when MOE=0 on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM15_CCER) on page818). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)\n1 : B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.10..10> OSSI
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_OSSR  ----------------------------------
// SVD Line: 18958

//  <item> SFDITEM_FIELD__TIM15_BDTR_OSSR
//    <name> OSSR </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014044) \nOff-state selection for Run mode This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM15_CCER) on page818). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)\n1 : B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.11..11> OSSR
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_BKE  -----------------------------------
// SVD Line: 18980

//  <item> SFDITEM_FIELD__TIM15_BDTR_BKE
//    <name> BKE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40014044) \nBreak enable 1; Break inputs (BRK and CCS clock failure event) enabled This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break inputs (BRK and CCS clock failure event) disabled\n1 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.12..12> BKE
//        <0=> 0: B_0x0 = Break inputs (BRK and CCS clock failure event) disabled
//        <1=> 1: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_BKP  -----------------------------------
// SVD Line: 18997

//  <item> SFDITEM_FIELD__TIM15_BDTR_BKP
//    <name> BKP </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40014044) \nBreak polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is active low\n1 : B_0x1 = Break input BRK is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.13..13> BKP
//        <0=> 0: B_0x0 = Break input BRK is active low
//        <1=> 1: B_0x1 = Break input BRK is active high
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_AOE  -----------------------------------
// SVD Line: 19018

//  <item> SFDITEM_FIELD__TIM15_BDTR_AOE
//    <name> AOE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40014044) \nAutomatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = MOE can be set only by software\n1 : B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.14..14> AOE
//        <0=> 0: B_0x0 = MOE can be set only by software
//        <1=> 1: B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_MOE  -----------------------------------
// SVD Line: 19038

//  <item> SFDITEM_FIELD__TIM15_BDTR_MOE
//    <name> MOE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40014044) \nMain output enable This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. See OC/OCN enable description for more details (enable register (TIM15_CCER) on page818).\n0 : B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\n1 : B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.15..15> MOE
//        <0=> 0: B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
//        <1=> 1: B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_BDTR_BKF  -----------------------------------
// SVD Line: 19059

//  <item> SFDITEM_FIELD__TIM15_BDTR_BKF
//    <name> BKF </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40014044) \nBreak filter This bit-field defines the frequency used to sample the BRK input signal and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output: Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = No filter, BRK acts asynchronously\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.19..16> BKF
//        <0=> 0: B_0x0 = No filter, BRK acts asynchronously
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_BDTR_BKDSRM  ---------------------------------
// SVD Line: 19150

//  <item> SFDITEM_FIELD__TIM15_BDTR_BKDSRM
//    <name> BKDSRM </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40014044) \nBreak Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is armed\n1 : B_0x1 = Break input BRK is disarmed </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.26..26> BKDSRM
//        <0=> 0: B_0x0 = Break input BRK is armed
//        <1=> 1: B_0x1 = Break input BRK is disarmed
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_BDTR_BKBID  ----------------------------------
// SVD Line: 19172

//  <item> SFDITEM_FIELD__TIM15_BDTR_BKBID
//    <name> BKBID </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40014044) \nBreak Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK in input mode\n1 : B_0x1 = Break input BRK in bidirectional mode </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_BDTR ) </loc>
//      <o.28..28> BKBID
//        <0=> 0: B_0x0 = Break input BRK in input mode
//        <1=> 1: B_0x1 = Break input BRK in bidirectional mode
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_BDTR  -----------------------------------
// SVD Line: 18878

//  <rtree> SFDITEM_REG__TIM15_BDTR
//    <name> BDTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014044) break and dead-time register </i>
//    <loc> ( (unsigned int)((TIM15_BDTR >> 0) & 0xFFFFFFFF), ((TIM15_BDTR = (TIM15_BDTR & ~(0x140FFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x140FFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_BDTR_DTG </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_LOCK </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_OSSI </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_OSSR </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_BKE </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_BKP </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_AOE </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_MOE </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_BKF </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_BKDSRM </item>
//    <item> SFDITEM_FIELD__TIM15_BDTR_BKBID </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_DCR  --------------------------------
// SVD Line: 19196

unsigned int TIM15_DCR __AT (0x40014048);



// --------------------------------  Field Item: TIM15_DCR_DBA  -----------------------------------
// SVD Line: 19205

//  <item> SFDITEM_FIELD__TIM15_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40014048) \nDMA base address This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ...\n0 : B_0x0 = TIMx_CR1,\n1 : B_0x1 = TIMx_CR2,\n2 : B_0x2 = TIMx_SMCR,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1,
//        <1=> 1: B_0x1 = TIMx_CR2,
//        <2=> 2: B_0x2 = TIMx_SMCR,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM15_DCR_DBL  -----------------------------------
// SVD Line: 19232

//  <item> SFDITEM_FIELD__TIM15_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40014048) \nDMA burst length This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address). ...\n0 : B_0x0 = 1 transfer,\n1 : B_0x1 = 2 transfers,\n2 : B_0x2 = 3 transfers,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers.\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer,
//        <1=> 1: B_0x1 = 2 transfers,
//        <2=> 2: B_0x2 = 3 transfers,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers.
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_DCR  -----------------------------------
// SVD Line: 19196

//  <rtree> SFDITEM_REG__TIM15_DCR
//    <name> DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014048) DMA control register </i>
//    <loc> ( (unsigned int)((TIM15_DCR >> 0) & 0xFFFFFFFF), ((TIM15_DCR = (TIM15_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM15_DCR_DBL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_DMAR  -------------------------------
// SVD Line: 19265

unsigned int TIM15_DMAR __AT (0x4001404C);



// -------------------------------  Field Item: TIM15_DMAR_DMAB  ----------------------------------
// SVD Line: 19274

//  <item> SFDITEM_FIELD__TIM15_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001404C) DMA register for burst  accesses </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM15_DMAR >> 0) & 0xFFFF), ((TIM15_DMAR = (TIM15_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_DMAR  -----------------------------------
// SVD Line: 19265

//  <rtree> SFDITEM_REG__TIM15_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001404C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM15_DMAR >> 0) & 0xFFFFFFFF), ((TIM15_DMAR = (TIM15_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_DMAR_DMAB </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM15_AF1  --------------------------------
// SVD Line: 19283

unsigned int TIM15_AF1 __AT (0x40014060);



// -------------------------------  Field Item: TIM15_AF1_BKINE  ----------------------------------
// SVD Line: 19292

//  <item> SFDITEM_FIELD__TIM15_AF1_BKINE
//    <name> BKINE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014060) \nBRK BKIN input enable This bit enables the BKIN alternate function input for the timers BRK input. BKIN input is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input disabled\n1 : B_0x1 = BKIN input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.0..0> BKINE
//        <0=> 0: B_0x0 = BKIN input disabled
//        <1=> 1: B_0x1 = BKIN input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP1E  ---------------------------------
// SVD Line: 19313

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP1E
//    <name> BKCMP1E </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014060) \nBRK COMP1 enable This bit enables the COMP1 for the timers BRK input. COMP1 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input disabled\n1 : B_0x1 = COMP1 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.1..1> BKCMP1E
//        <0=> 0: B_0x0 = COMP1 input disabled
//        <1=> 1: B_0x1 = COMP1 input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP2E  ---------------------------------
// SVD Line: 19334

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP2E
//    <name> BKCMP2E </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014060) \nBRK COMP2 enable This bit enables the COMP2 for the timers BRK input. COMP2 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input disabled\n1 : B_0x1 = COMP2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.2..2> BKCMP2E
//        <0=> 0: B_0x0 = COMP2 input disabled
//        <1=> 1: B_0x1 = COMP2 input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP3E  ---------------------------------
// SVD Line: 19355

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP3E
//    <name> BKCMP3E </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014060) \nBRK COMP3 enable This bit enables the COMP3 for the timers BRK input. COMP3 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP3 input disabled\n1 : B_0x1 = COMP3 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.3..3> BKCMP3E
//        <0=> 0: B_0x0 = COMP3 input disabled
//        <1=> 1: B_0x1 = COMP3 input enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM15_AF1_BKINP  ----------------------------------
// SVD Line: 19376

//  <item> SFDITEM_FIELD__TIM15_AF1_BKINP
//    <name> BKINP </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014060) \nBRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input is active low\n1 : B_0x1 = BKIN input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.9..9> BKINP
//        <0=> 0: B_0x0 = BKIN input is active low
//        <1=> 1: B_0x1 = BKIN input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP1P  ---------------------------------
// SVD Line: 19397

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP1P
//    <name> BKCMP1P </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014060) \nBRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input is active low\n1 : B_0x1 = COMP1 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.10..10> BKCMP1P
//        <0=> 0: B_0x0 = COMP1 input is active low
//        <1=> 1: B_0x1 = COMP1 input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP2P  ---------------------------------
// SVD Line: 19418

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP2P
//    <name> BKCMP2P </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014060) \nBRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input is active low\n1 : B_0x1 = COMP2 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.11..11> BKCMP2P
//        <0=> 0: B_0x0 = COMP2 input is active low
//        <1=> 1: B_0x1 = COMP2 input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM15_AF1_BKCMP3P  ---------------------------------
// SVD Line: 19439

//  <item> SFDITEM_FIELD__TIM15_AF1_BKCMP3P
//    <name> BKCMP3P </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40014060) \nBRK COMP3 input polarity This bit selects the COMP3 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP3 input is active low\n1 : B_0x1 = COMP3 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_AF1 ) </loc>
//      <o.12..12> BKCMP3P
//        <0=> 0: B_0x0 = COMP3 input is active low
//        <1=> 1: B_0x1 = COMP3 input is active high
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM15_AF1  -----------------------------------
// SVD Line: 19283

//  <rtree> SFDITEM_REG__TIM15_AF1
//    <name> AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014060) TIM15 alternate register 1 </i>
//    <loc> ( (unsigned int)((TIM15_AF1 >> 0) & 0xFFFFFFFF), ((TIM15_AF1 = (TIM15_AF1 & ~(0x1E0FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1E0F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKINE </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP1E </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP2E </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP3E </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKINP </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP1P </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP2P </item>
//    <item> SFDITEM_FIELD__TIM15_AF1_BKCMP3P </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: TIM15_TISEL  -------------------------------
// SVD Line: 19462

unsigned int TIM15_TISEL __AT (0x40014068);



// -----------------------------  Field Item: TIM15_TISEL_TI1SEL  ---------------------------------
// SVD Line: 19471

//  <item> SFDITEM_FIELD__TIM15_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40014068) \nselects TI1[0] to TI1[15] input Others: Reserved\n0 : B_0x0 = TIM15_CH1 input\n1 : B_0x1 = TIM2_IC1\n2 : B_0x2 = TIM3_IC1\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM15_CH1 input
//        <1=> 1: B_0x1 = TIM2_IC1
//        <2=> 2: B_0x2 = TIM3_IC1
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM15_TISEL_TI2SEL  ---------------------------------
// SVD Line: 19496

//  <item> SFDITEM_FIELD__TIM15_TISEL_TI2SEL
//    <name> TI2SEL </name>
//    <rw> 
//    <i> [Bits 11..8] RW (@ 0x40014068) \nselects TI2[0] to TI2[15] input Others: Reserved\n0 : B_0x0 = TIM15_CH2 input\n1 : B_0x1 = TIM2_IC2\n2 : B_0x2 = TIM3_IC2\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM15_TISEL ) </loc>
//      <o.11..8> TI2SEL
//        <0=> 0: B_0x0 = TIM15_CH2 input
//        <1=> 1: B_0x1 = TIM2_IC2
//        <2=> 2: B_0x2 = TIM3_IC2
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM15_TISEL  ----------------------------------
// SVD Line: 19462

//  <rtree> SFDITEM_REG__TIM15_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014068) input selection register </i>
//    <loc> ( (unsigned int)((TIM15_TISEL >> 0) & 0xFFFFFFFF), ((TIM15_TISEL = (TIM15_TISEL & ~(0xF0FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF0F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM15_TISEL_TI1SEL </item>
//    <item> SFDITEM_FIELD__TIM15_TISEL_TI2SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: TIM15  -------------------------------------
// SVD Line: 17065

//  <view> TIM15
//    <name> TIM15 </name>
//    <item> SFDITEM_REG__TIM15_CR1 </item>
//    <item> SFDITEM_REG__TIM15_CR2 </item>
//    <item> SFDITEM_REG__TIM15_SMCR </item>
//    <item> SFDITEM_REG__TIM15_DIER </item>
//    <item> SFDITEM_REG__TIM15_SR </item>
//    <item> SFDITEM_REG__TIM15_EGR </item>
//    <item> SFDITEM_REG__TIM15_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM15_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM15_CCER </item>
//    <item> SFDITEM_REG__TIM15_CNT </item>
//    <item> SFDITEM_REG__TIM15_PSC </item>
//    <item> SFDITEM_REG__TIM15_ARR </item>
//    <item> SFDITEM_REG__TIM15_RCR </item>
//    <item> SFDITEM_REG__TIM15_CCR1 </item>
//    <item> SFDITEM_REG__TIM15_CCR2 </item>
//    <item> SFDITEM_REG__TIM15_BDTR </item>
//    <item> SFDITEM_REG__TIM15_DCR </item>
//    <item> SFDITEM_REG__TIM15_DMAR </item>
//    <item> SFDITEM_REG__TIM15_AF1 </item>
//    <item> SFDITEM_REG__TIM15_TISEL </item>
//  </view>
//  


// ----------------------------  Register Item Address: TIM16_CR1  --------------------------------
// SVD Line: 19541

unsigned int TIM16_CR1 __AT (0x40014400);



// --------------------------------  Field Item: TIM16_CR1_CEN  -----------------------------------
// SVD Line: 19550

//  <item> SFDITEM_FIELD__TIM16_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014400) \nCounter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR1_UDIS  -----------------------------------
// SVD Line: 19570

//  <item> SFDITEM_FIELD__TIM16_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014400) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_CR1_URS  -----------------------------------
// SVD Line: 19594

//  <item> SFDITEM_FIELD__TIM16_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014400) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_CR1_OPM  -----------------------------------
// SVD Line: 19617

//  <item> SFDITEM_FIELD__TIM16_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014400) \nOne pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR1_ARPE  -----------------------------------
// SVD Line: 19636

//  <item> SFDITEM_FIELD__TIM16_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014400) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_CR1_CKD  -----------------------------------
// SVD Line: 19655

//  <item> SFDITEM_FIELD__TIM16_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014400) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),\n0 : B_0x0 = tDTS=tCK_INT\n1 : B_0x1 = tDTS=2*tCK_INT\n2 : B_0x2 = tDTS=4*tCK_INT\n3 : B_0x3 = Reserved, do not program this value </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS=tCK_INT
//        <1=> 1: B_0x1 = tDTS=2*tCK_INT
//        <2=> 2: B_0x2 = tDTS=4*tCK_INT
//        <3=> 3: B_0x3 = Reserved, do not program this value
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM16_CR1_UIFREMAP  ---------------------------------
// SVD Line: 19685

//  <item> SFDITEM_FIELD__TIM16_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014400) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_CR1  -----------------------------------
// SVD Line: 19541

//  <rtree> SFDITEM_REG__TIM16_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014400) control register 1 </i>
//    <loc> ( (unsigned int)((TIM16_CR1 >> 0) & 0xFFFFFFFF), ((TIM16_CR1 = (TIM16_CR1 & ~(0xB8FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xB8F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM16_CR1_UIFREMAP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_CR2  --------------------------------
// SVD Line: 19706

unsigned int TIM16_CR2 __AT (0x40014404);



// -------------------------------  Field Item: TIM16_CR2_CCPC  -----------------------------------
// SVD Line: 19715

//  <item> SFDITEM_FIELD__TIM16_CR2_CCPC
//    <name> CCPC </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014404) \nCapture/compare preloaded control Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded\n1 : B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR2 ) </loc>
//      <o.0..0> CCPC
//        <0=> 0: B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded
//        <1=> 1: B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR2_CCUS  -----------------------------------
// SVD Line: 19735

//  <item> SFDITEM_FIELD__TIM16_CR2_CCUS
//    <name> CCUS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014404) \nCapture/compare control update selection Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.\n1 : B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR2 ) </loc>
//      <o.2..2> CCUS
//        <0=> 0: B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.
//        <1=> 1: B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR2_CCDS  -----------------------------------
// SVD Line: 19755

//  <item> SFDITEM_FIELD__TIM16_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014404) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR2_OIS1  -----------------------------------
// SVD Line: 19774

//  <item> SFDITEM_FIELD__TIM16_CR2_OIS1
//    <name> OIS1 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40014404) \nOutput Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0\n1 : B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR2 ) </loc>
//      <o.8..8> OIS1
//        <0=> 0: B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
//        <1=> 1: B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CR2_OIS1N  ----------------------------------
// SVD Line: 19794

//  <item> SFDITEM_FIELD__TIM16_CR2_OIS1N
//    <name> OIS1N </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014404) \nOutput Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1N=0 after a dead-time when MOE=0\n1 : B_0x1 = OC1N=1 after a dead-time when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CR2 ) </loc>
//      <o.9..9> OIS1N
//        <0=> 0: B_0x0 = OC1N=0 after a dead-time when MOE=0
//        <1=> 1: B_0x1 = OC1N=1 after a dead-time when MOE=0
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_CR2  -----------------------------------
// SVD Line: 19706

//  <rtree> SFDITEM_REG__TIM16_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014404) control register 2 </i>
//    <loc> ( (unsigned int)((TIM16_CR2 >> 0) & 0xFFFFFFFF), ((TIM16_CR2 = (TIM16_CR2 & ~(0x30DUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x30D) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CR2_CCPC </item>
//    <item> SFDITEM_FIELD__TIM16_CR2_CCUS </item>
//    <item> SFDITEM_FIELD__TIM16_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM16_CR2_OIS1 </item>
//    <item> SFDITEM_FIELD__TIM16_CR2_OIS1N </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_DIER  -------------------------------
// SVD Line: 19816

unsigned int TIM16_DIER __AT (0x4001440C);



// -------------------------------  Field Item: TIM16_DIER_UIE  -----------------------------------
// SVD Line: 19825

//  <item> SFDITEM_FIELD__TIM16_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4001440C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled\n1 : B_0x1 = Update interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled
//        <1=> 1: B_0x1 = Update interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_DIER_CC1IE  ----------------------------------
// SVD Line: 19844

//  <item> SFDITEM_FIELD__TIM16_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4001440C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled\n1 : B_0x1 = CC1 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled
//        <1=> 1: B_0x1 = CC1 interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_DIER_COMIE  ----------------------------------
// SVD Line: 19863

//  <item> SFDITEM_FIELD__TIM16_DIER_COMIE
//    <name> COMIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x4001440C) \nCOM interrupt enable\n0 : B_0x0 = COM interrupt disabled\n1 : B_0x1 = COM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.5..5> COMIE
//        <0=> 0: B_0x0 = COM interrupt disabled
//        <1=> 1: B_0x1 = COM interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_DIER_BIE  -----------------------------------
// SVD Line: 19882

//  <item> SFDITEM_FIELD__TIM16_DIER_BIE
//    <name> BIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x4001440C) \nBreak interrupt enable\n0 : B_0x0 = Break interrupt disabled\n1 : B_0x1 = Break interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.7..7> BIE
//        <0=> 0: B_0x0 = Break interrupt disabled
//        <1=> 1: B_0x1 = Break interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_DIER_UDE  -----------------------------------
// SVD Line: 19901

//  <item> SFDITEM_FIELD__TIM16_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4001440C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled\n1 : B_0x1 = Update DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled
//        <1=> 1: B_0x1 = Update DMA request enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_DIER_CC1DE  ----------------------------------
// SVD Line: 19920

//  <item> SFDITEM_FIELD__TIM16_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4001440C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled\n1 : B_0x1 = CC1 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled
//        <1=> 1: B_0x1 = CC1 DMA request enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_DIER  -----------------------------------
// SVD Line: 19816

//  <rtree> SFDITEM_REG__TIM16_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001440C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM16_DIER >> 0) & 0xFFFFFFFF), ((TIM16_DIER = (TIM16_DIER & ~(0x3A3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3A3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM16_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM16_DIER_COMIE </item>
//    <item> SFDITEM_FIELD__TIM16_DIER_BIE </item>
//    <item> SFDITEM_FIELD__TIM16_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM16_DIER_CC1DE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM16_SR  --------------------------------
// SVD Line: 19941

unsigned int TIM16_SR __AT (0x40014410);



// --------------------------------  Field Item: TIM16_SR_UIF  ------------------------------------
// SVD Line: 19950

//  <item> SFDITEM_FIELD__TIM16_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014410) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_SR_CC1IF  -----------------------------------
// SVD Line: 19972

//  <item> SFDITEM_FIELD__TIM16_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014410) \nCapture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_SR_COMIF  -----------------------------------
// SVD Line: 19994

//  <item> SFDITEM_FIELD__TIM16_SR_COMIF
//    <name> COMIF </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40014410) \nCOM interrupt flag This flag is set by hardware on a COM event (once the capture/compare control bits CCxE, CCxNE, OCxM have been updated). It is cleared by software.\n0 : B_0x0 = No COM event occurred\n1 : B_0x1 = COM interrupt pending </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_SR ) </loc>
//      <o.5..5> COMIF
//        <0=> 0: B_0x0 = No COM event occurred
//        <1=> 1: B_0x1 = COM interrupt pending
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_SR_BIF  ------------------------------------
// SVD Line: 20014

//  <item> SFDITEM_FIELD__TIM16_SR_BIF
//    <name> BIF </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014410) \nBreak interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.\n0 : B_0x0 = No break event occurred\n1 : B_0x1 = An active level has been detected on the break input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_SR ) </loc>
//      <o.7..7> BIF
//        <0=> 0: B_0x0 = No break event occurred
//        <1=> 1: B_0x1 = An active level has been detected on the break input
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_SR_CC1OF  -----------------------------------
// SVD Line: 20034

//  <item> SFDITEM_FIELD__TIM16_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014410) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_SR  ------------------------------------
// SVD Line: 19941

//  <rtree> SFDITEM_REG__TIM16_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014410) status register </i>
//    <loc> ( (unsigned int)((TIM16_SR >> 0) & 0xFFFFFFFF), ((TIM16_SR = (TIM16_SR & ~(0x2A3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x2A3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM16_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM16_SR_COMIF </item>
//    <item> SFDITEM_FIELD__TIM16_SR_BIF </item>
//    <item> SFDITEM_FIELD__TIM16_SR_CC1OF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_EGR  --------------------------------
// SVD Line: 20056

unsigned int TIM16_EGR __AT (0x40014414);



// --------------------------------  Field Item: TIM16_EGR_UG  ------------------------------------
// SVD Line: 20065

//  <item> SFDITEM_FIELD__TIM16_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40014414) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_EGR_CC1G  -----------------------------------
// SVD Line: 20085

//  <item> SFDITEM_FIELD__TIM16_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40014414) \nCapture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action.\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_EGR_COMG  -----------------------------------
// SVD Line: 20109

//  <item> SFDITEM_FIELD__TIM16_EGR_COMG
//    <name> COMG </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40014414) \nCapture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware. Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = No action\n1 : B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_EGR ) </loc>
//      <o.5..5> COMG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_EGR_BG  ------------------------------------
// SVD Line: 20130

//  <item> SFDITEM_FIELD__TIM16_EGR_BG
//    <name> BG </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40014414) \nBreak generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_EGR ) </loc>
//      <o.7..7> BG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_EGR  -----------------------------------
// SVD Line: 20056

//  <rtree> SFDITEM_REG__TIM16_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40014414) event generation register </i>
//    <loc> ( (unsigned int)((TIM16_EGR >> 0) & 0xFFFFFFFF), ((TIM16_EGR = (TIM16_EGR & ~(0xA3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xA3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM16_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM16_EGR_COMG </item>
//    <item> SFDITEM_FIELD__TIM16_EGR_BG </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM16_CCMR1_Output  ---------------------------
// SVD Line: 20152

unsigned int TIM16_CCMR1_Output __AT (0x40014418);



// ---------------------------  Field Item: TIM16_CCMR1_Output_CC1S  ------------------------------
// SVD Line: 20162

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014418) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM16_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 20184

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014418) \nOutput Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.\n0 : B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.\n1 : B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//        <0=> 0: B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.
//        <1=> 1: B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM16_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 20204

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014418) \nOutput Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM16_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 20225

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40014418) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.\n7 : B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.
//        <7=> 7: B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM16_CCMR1_Output_OC1M2  ------------------------------
// SVD Line: 20279

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1M2
//    <name> OC1M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40014418) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Output ) </loc>
//      <o.16..16> OC1M2
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: TIM16_CCMR1_Output  -------------------------------
// SVD Line: 20152

//  <rtree> SFDITEM_REG__TIM16_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014418) capture/compare mode register (output  mode) </i>
//    <loc> ( (unsigned int)((TIM16_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM16_CCMR1_Output = (TIM16_CCMR1_Output & ~(0x1007FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1007F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Output_CC1S </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Output_OC1M2 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM16_CCMR1_Input  ----------------------------
// SVD Line: 20335

unsigned int TIM16_CCMR1_Input __AT (0x40014418);



// ---------------------------  Field Item: TIM16_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 20346

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014418) \nCapture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Input ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM16_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 20368

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40014418) \nInput capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).\n0 : B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input.\n1 : B_0x1 = capture is done once every 2 events\n2 : B_0x2 = capture is done once every 4 events\n3 : B_0x3 = capture is done once every 8 events </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Input ) </loc>
//      <o.3..2> IC1PSC
//        <0=> 0: B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input.
//        <1=> 1: B_0x1 = capture is done once every 2 events
//        <2=> 2: B_0x2 = capture is done once every 4 events
//        <3=> 3: B_0x3 = capture is done once every 8 events
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM16_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 20399

//  <item> SFDITEM_FIELD__TIM16_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40014418) \nInput capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCMR1_Input ) </loc>
//      <o.7..4> IC1F
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM16_CCMR1_Input  -------------------------------
// SVD Line: 20335

//  <rtree> SFDITEM_REG__TIM16_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014418) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM16_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM16_CCMR1_Input = (TIM16_CCMR1_Input & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Input_CC1S </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM16_CCMR1_Input_IC1F </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_CCER  -------------------------------
// SVD Line: 20491

unsigned int TIM16_CCER __AT (0x40014420);



// -------------------------------  Field Item: TIM16_CCER_CC1E  ----------------------------------
// SVD Line: 20501

//  <item> SFDITEM_FIELD__TIM16_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014420) \nCapture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details.\n0 : B_0x0 = Capture mode disabled / OC1 is not active (see below)\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active (see below)
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_CCER_CC1P  ----------------------------------
// SVD Line: 20521

//  <item> SFDITEM_FIELD__TIM16_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014420) \nCapture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: this configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_CCER_CC1NE  ----------------------------------
// SVD Line: 20547

//  <item> SFDITEM_FIELD__TIM16_CCER_CC1NE
//    <name> CC1NE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014420) \nCapture/Compare 1 complementary output enable\n0 : B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.\n1 : B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCER ) </loc>
//      <o.2..2> CC1NE
//        <0=> 0: B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//        <1=> 1: B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_CCER_CC1NP  ----------------------------------
// SVD Line: 20566

//  <item> SFDITEM_FIELD__TIM16_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014420) \nCapture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to the description of CC1P. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.\n0 : B_0x0 = OC1N active high\n1 : B_0x1 = OC1N active low </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_CCER ) </loc>
//      <o.3..3> CC1NP
//        <0=> 0: B_0x0 = OC1N active high
//        <1=> 1: B_0x1 = OC1N active low
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_CCER  -----------------------------------
// SVD Line: 20491

//  <rtree> SFDITEM_REG__TIM16_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014420) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM16_CCER >> 0) & 0xFFFFFFFF), ((TIM16_CCER = (TIM16_CCER & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM16_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM16_CCER_CC1NE </item>
//    <item> SFDITEM_FIELD__TIM16_CCER_CC1NP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_CNT  --------------------------------
// SVD Line: 20593

unsigned int TIM16_CNT __AT (0x40014424);



// --------------------------------  Field Item: TIM16_CNT_CNT  -----------------------------------
// SVD Line: 20601

//  <item> SFDITEM_FIELD__TIM16_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014424) counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM16_CNT >> 0) & 0xFFFF), ((TIM16_CNT = (TIM16_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: TIM16_CNT_UIFCPY  ----------------------------------
// SVD Line: 20608

//  <item> SFDITEM_FIELD__TIM16_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40014424) UIF Copy </i>
//    <check> 
//      <loc> ( (unsigned int) TIM16_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_CNT  -----------------------------------
// SVD Line: 20593

//  <rtree> SFDITEM_REG__TIM16_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014424) counter </i>
//    <loc> ( (unsigned int)((TIM16_CNT >> 0) & 0xFFFFFFFF), ((TIM16_CNT = (TIM16_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM16_CNT_UIFCPY </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_PSC  --------------------------------
// SVD Line: 20617

unsigned int TIM16_PSC __AT (0x40014428);



// --------------------------------  Field Item: TIM16_PSC_PSC  -----------------------------------
// SVD Line: 20626

//  <item> SFDITEM_FIELD__TIM16_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014428) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM16_PSC >> 0) & 0xFFFF), ((TIM16_PSC = (TIM16_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_PSC  -----------------------------------
// SVD Line: 20617

//  <rtree> SFDITEM_REG__TIM16_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014428) prescaler </i>
//    <loc> ( (unsigned int)((TIM16_PSC >> 0) & 0xFFFFFFFF), ((TIM16_PSC = (TIM16_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_PSC_PSC </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_ARR  --------------------------------
// SVD Line: 20634

unsigned int TIM16_ARR __AT (0x4001442C);



// --------------------------------  Field Item: TIM16_ARR_ARR  -----------------------------------
// SVD Line: 20643

//  <item> SFDITEM_FIELD__TIM16_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001442C) Auto-reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM16_ARR >> 0) & 0xFFFF), ((TIM16_ARR = (TIM16_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_ARR  -----------------------------------
// SVD Line: 20634

//  <rtree> SFDITEM_REG__TIM16_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001442C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM16_ARR >> 0) & 0xFFFFFFFF), ((TIM16_ARR = (TIM16_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_RCR  --------------------------------
// SVD Line: 20651

unsigned int TIM16_RCR __AT (0x40014430);



// --------------------------------  Field Item: TIM16_RCR_REP  -----------------------------------
// SVD Line: 20660

//  <item> SFDITEM_FIELD__TIM16_RCR_REP
//    <name> REP </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014430) Repetition counter value </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM16_RCR >> 0) & 0xFF), ((TIM16_RCR = (TIM16_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_RCR  -----------------------------------
// SVD Line: 20651

//  <rtree> SFDITEM_REG__TIM16_RCR
//    <name> RCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014430) repetition counter register </i>
//    <loc> ( (unsigned int)((TIM16_RCR >> 0) & 0xFFFFFFFF), ((TIM16_RCR = (TIM16_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_RCR_REP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_CCR1  -------------------------------
// SVD Line: 20668

unsigned int TIM16_CCR1 __AT (0x40014434);



// -------------------------------  Field Item: TIM16_CCR1_CCR1  ----------------------------------
// SVD Line: 20677

//  <item> SFDITEM_FIELD__TIM16_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014434) Capture/Compare 1 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM16_CCR1 >> 0) & 0xFFFF), ((TIM16_CCR1 = (TIM16_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_CCR1  -----------------------------------
// SVD Line: 20668

//  <rtree> SFDITEM_REG__TIM16_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014434) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM16_CCR1 >> 0) & 0xFFFFFFFF), ((TIM16_CCR1 = (TIM16_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_CCR1_CCR1 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_BDTR  -------------------------------
// SVD Line: 20685

unsigned int TIM16_BDTR __AT (0x40014444);



// -------------------------------  Field Item: TIM16_BDTR_DTG  -----------------------------------
// SVD Line: 20694

//  <item> SFDITEM_FIELD__TIM16_BDTR_DTG
//    <name> DTG </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014444) Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS Example if TDTS=125ns (8MHz), dead-time possible values are: 0 to 15875 ns by 125 ns steps, 16 s to 31750 ns by 250 ns steps, 32 s to 63 s by 1 s steps, 64 s to 126 s by 2 s steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM16_BDTR >> 0) & 0xFF), ((TIM16_BDTR = (TIM16_BDTR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_LOCK  ----------------------------------
// SVD Line: 20712

//  <item> SFDITEM_FIELD__TIM16_BDTR_LOCK
//    <name> LOCK </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014444) \nLock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.\n0 : B_0x0 = LOCK OFF - No bit is write protected\n1 : B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.\n2 : B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.\n3 : B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.9..8> LOCK
//        <0=> 0: B_0x0 = LOCK OFF - No bit is write protected
//        <1=> 1: B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.
//        <2=> 2: B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
//        <3=> 3: B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_OSSI  ----------------------------------
// SVD Line: 20743

//  <item> SFDITEM_FIELD__TIM16_BDTR_OSSI
//    <name> OSSI </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014444) \nOff-state selection for Idle mode This bit is used when MOE=0 on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)\n1 : B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.10..10> OSSI
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_OSSR  ----------------------------------
// SVD Line: 20765

//  <item> SFDITEM_FIELD__TIM16_BDTR_OSSR
//    <name> OSSR </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014444) \nOff-state selection for Run mode This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)\n1 : B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.11..11> OSSR
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_BKE  -----------------------------------
// SVD Line: 20787

//  <item> SFDITEM_FIELD__TIM16_BDTR_BKE
//    <name> BKE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40014444) \nBreak enable 1; Break inputs (BRK and CCS clock failure event) enabled Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break inputs (BRK and CCS clock failure event) disabled\n1 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.12..12> BKE
//        <0=> 0: B_0x0 = Break inputs (BRK and CCS clock failure event) disabled
//        <1=> 1: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_BKP  -----------------------------------
// SVD Line: 20804

//  <item> SFDITEM_FIELD__TIM16_BDTR_BKP
//    <name> BKP </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40014444) \nBreak polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is active low\n1 : B_0x1 = Break input BRK is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.13..13> BKP
//        <0=> 0: B_0x0 = Break input BRK is active low
//        <1=> 1: B_0x1 = Break input BRK is active high
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_AOE  -----------------------------------
// SVD Line: 20825

//  <item> SFDITEM_FIELD__TIM16_BDTR_AOE
//    <name> AOE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40014444) \nAutomatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = MOE can be set only by software\n1 : B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.14..14> AOE
//        <0=> 0: B_0x0 = MOE can be set only by software
//        <1=> 1: B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_MOE  -----------------------------------
// SVD Line: 20845

//  <item> SFDITEM_FIELD__TIM16_BDTR_MOE
//    <name> MOE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40014444) \nMain output enable This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846).\n0 : B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\n1 : B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details ( </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.15..15> MOE
//        <0=> 0: B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
//        <1=> 1: B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details (
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_BDTR_BKF  -----------------------------------
// SVD Line: 20866

//  <item> SFDITEM_FIELD__TIM16_BDTR_BKF
//    <name> BKF </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40014444) \nBreak filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = No filter, BRK acts asynchronously\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.19..16> BKF
//        <0=> 0: B_0x0 = No filter, BRK acts asynchronously
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_BDTR_BKDSRM  ---------------------------------
// SVD Line: 20957

//  <item> SFDITEM_FIELD__TIM16_BDTR_BKDSRM
//    <name> BKDSRM </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40014444) \nBreak Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is armed\n1 : B_0x1 = Break input BRK is disarmed </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.26..26> BKDSRM
//        <0=> 0: B_0x0 = Break input BRK is armed
//        <1=> 1: B_0x1 = Break input BRK is disarmed
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_BDTR_BKBID  ----------------------------------
// SVD Line: 20979

//  <item> SFDITEM_FIELD__TIM16_BDTR_BKBID
//    <name> BKBID </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40014444) \nBreak Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK in input mode\n1 : B_0x1 = Break input BRK in bidirectional mode </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_BDTR ) </loc>
//      <o.28..28> BKBID
//        <0=> 0: B_0x0 = Break input BRK in input mode
//        <1=> 1: B_0x1 = Break input BRK in bidirectional mode
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_BDTR  -----------------------------------
// SVD Line: 20685

//  <rtree> SFDITEM_REG__TIM16_BDTR
//    <name> BDTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014444) break and dead-time register </i>
//    <loc> ( (unsigned int)((TIM16_BDTR >> 0) & 0xFFFFFFFF), ((TIM16_BDTR = (TIM16_BDTR & ~(0x140FFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x140FFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_BDTR_DTG </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_LOCK </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_OSSI </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_OSSR </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_BKE </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_BKP </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_AOE </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_MOE </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_BKF </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_BKDSRM </item>
//    <item> SFDITEM_FIELD__TIM16_BDTR_BKBID </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_DCR  --------------------------------
// SVD Line: 21003

unsigned int TIM16_DCR __AT (0x40014448);



// --------------------------------  Field Item: TIM16_DCR_DBA  -----------------------------------
// SVD Line: 21012

//  <item> SFDITEM_FIELD__TIM16_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40014448) \nDMA base address This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ... Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.\n0 : B_0x0 = TIMx_CR1,\n1 : B_0x1 = TIMx_CR2,\n2 : B_0x2 = TIMx_SMCR,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1,
//        <1=> 1: B_0x1 = TIMx_CR2,
//        <2=> 2: B_0x2 = TIMx_SMCR,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM16_DCR_DBL  -----------------------------------
// SVD Line: 21040

//  <item> SFDITEM_FIELD__TIM16_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40014448) \nDMA burst length This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ...\n0 : B_0x0 = 1 transfer,\n1 : B_0x1 = 2 transfers,\n2 : B_0x2 = 3 transfers,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers.\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer,
//        <1=> 1: B_0x1 = 2 transfers,
//        <2=> 2: B_0x2 = 3 transfers,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers.
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_DCR  -----------------------------------
// SVD Line: 21003

//  <rtree> SFDITEM_REG__TIM16_DCR
//    <name> DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014448) DMA control register </i>
//    <loc> ( (unsigned int)((TIM16_DCR >> 0) & 0xFFFFFFFF), ((TIM16_DCR = (TIM16_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM16_DCR_DBL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_DMAR  -------------------------------
// SVD Line: 21073

unsigned int TIM16_DMAR __AT (0x4001444C);



// -------------------------------  Field Item: TIM16_DMAR_DMAB  ----------------------------------
// SVD Line: 21082

//  <item> SFDITEM_FIELD__TIM16_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001444C) DMA register for burst  accesses </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM16_DMAR >> 0) & 0xFFFF), ((TIM16_DMAR = (TIM16_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_DMAR  -----------------------------------
// SVD Line: 21073

//  <rtree> SFDITEM_REG__TIM16_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001444C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM16_DMAR >> 0) & 0xFFFFFFFF), ((TIM16_DMAR = (TIM16_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_DMAR_DMAB </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM16_AF1  --------------------------------
// SVD Line: 21091

unsigned int TIM16_AF1 __AT (0x40014460);



// -------------------------------  Field Item: TIM16_AF1_BKINE  ----------------------------------
// SVD Line: 21100

//  <item> SFDITEM_FIELD__TIM16_AF1_BKINE
//    <name> BKINE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014460) \nBRK BKIN input enable This bit enables the BKIN alternate function input for the timers BRK input. BKIN input is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input disabled\n1 : B_0x1 = BKIN input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.0..0> BKINE
//        <0=> 0: B_0x0 = BKIN input disabled
//        <1=> 1: B_0x1 = BKIN input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_AF1_BKCMP1E  ---------------------------------
// SVD Line: 21121

//  <item> SFDITEM_FIELD__TIM16_AF1_BKCMP1E
//    <name> BKCMP1E </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014460) \nBRK COMP1 enable This bit enables the COMP1 for the timers BRK input. COMP1 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input disabled\n1 : B_0x1 = COMP1 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.1..1> BKCMP1E
//        <0=> 0: B_0x0 = COMP1 input disabled
//        <1=> 1: B_0x1 = COMP1 input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_AF1_BKCMP2E  ---------------------------------
// SVD Line: 21142

//  <item> SFDITEM_FIELD__TIM16_AF1_BKCMP2E
//    <name> BKCMP2E </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014460) \nBRK COMP2 enable This bit enables the COMP2 for the timers BRK input. COMP2 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input disabled\n1 : B_0x1 = COMP2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.2..2> BKCMP2E
//        <0=> 0: B_0x0 = COMP2 input disabled
//        <1=> 1: B_0x1 = COMP2 input enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM16_AF1_BKINP  ----------------------------------
// SVD Line: 21163

//  <item> SFDITEM_FIELD__TIM16_AF1_BKINP
//    <name> BKINP </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014460) \nBRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input is active low\n1 : B_0x1 = BKIN input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.9..9> BKINP
//        <0=> 0: B_0x0 = BKIN input is active low
//        <1=> 1: B_0x1 = BKIN input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_AF1_BKCMP1P  ---------------------------------
// SVD Line: 21184

//  <item> SFDITEM_FIELD__TIM16_AF1_BKCMP1P
//    <name> BKCMP1P </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014460) \nBRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input is active low\n1 : B_0x1 = COMP1 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.10..10> BKCMP1P
//        <0=> 0: B_0x0 = COMP1 input is active low
//        <1=> 1: B_0x1 = COMP1 input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM16_AF1_BKCMP2P  ---------------------------------
// SVD Line: 21205

//  <item> SFDITEM_FIELD__TIM16_AF1_BKCMP2P
//    <name> BKCMP2P </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014460) \nBRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input is active low\n1 : B_0x1 = COMP2 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_AF1 ) </loc>
//      <o.11..11> BKCMP2P
//        <0=> 0: B_0x0 = COMP2 input is active low
//        <1=> 1: B_0x1 = COMP2 input is active high
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM16_AF1  -----------------------------------
// SVD Line: 21091

//  <rtree> SFDITEM_REG__TIM16_AF1
//    <name> AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014460) TIM17 option register 1 </i>
//    <loc> ( (unsigned int)((TIM16_AF1 >> 0) & 0xFFFFFFFF), ((TIM16_AF1 = (TIM16_AF1 & ~(0xE07UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE07) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKINE </item>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKCMP1E </item>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKCMP2E </item>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKINP </item>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKCMP1P </item>
//    <item> SFDITEM_FIELD__TIM16_AF1_BKCMP2P </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: TIM16_TISEL  -------------------------------
// SVD Line: 21228

unsigned int TIM16_TISEL __AT (0x40014468);



// -----------------------------  Field Item: TIM16_TISEL_TI1SEL  ---------------------------------
// SVD Line: 21237

//  <item> SFDITEM_FIELD__TIM16_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40014468) \nselects TI1[0] to TI1[15] input Others: Reserved\n0 : B_0x0 = TIM16_CH1 input\n1 : B_0x1 = LSI\n2 : B_0x2 = LSE\n3 : B_0x3 = RTC wakeup\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM16_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM16_CH1 input
//        <1=> 1: B_0x1 = LSI
//        <2=> 2: B_0x2 = LSE
//        <3=> 3: B_0x3 = RTC wakeup
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM16_TISEL  ----------------------------------
// SVD Line: 21228

//  <rtree> SFDITEM_REG__TIM16_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014468) input selection register </i>
//    <loc> ( (unsigned int)((TIM16_TISEL >> 0) & 0xFFFFFFFF), ((TIM16_TISEL = (TIM16_TISEL & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM16_TISEL_TI1SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: TIM16  -------------------------------------
// SVD Line: 19525

//  <view> TIM16
//    <name> TIM16 </name>
//    <item> SFDITEM_REG__TIM16_CR1 </item>
//    <item> SFDITEM_REG__TIM16_CR2 </item>
//    <item> SFDITEM_REG__TIM16_DIER </item>
//    <item> SFDITEM_REG__TIM16_SR </item>
//    <item> SFDITEM_REG__TIM16_EGR </item>
//    <item> SFDITEM_REG__TIM16_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM16_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM16_CCER </item>
//    <item> SFDITEM_REG__TIM16_CNT </item>
//    <item> SFDITEM_REG__TIM16_PSC </item>
//    <item> SFDITEM_REG__TIM16_ARR </item>
//    <item> SFDITEM_REG__TIM16_RCR </item>
//    <item> SFDITEM_REG__TIM16_CCR1 </item>
//    <item> SFDITEM_REG__TIM16_BDTR </item>
//    <item> SFDITEM_REG__TIM16_DCR </item>
//    <item> SFDITEM_REG__TIM16_DMAR </item>
//    <item> SFDITEM_REG__TIM16_AF1 </item>
//    <item> SFDITEM_REG__TIM16_TISEL </item>
//  </view>
//  


// ----------------------------  Register Item Address: TIM17_CR1  --------------------------------
// SVD Line: 19541

unsigned int TIM17_CR1 __AT (0x40014800);



// --------------------------------  Field Item: TIM17_CR1_CEN  -----------------------------------
// SVD Line: 19550

//  <item> SFDITEM_FIELD__TIM17_CR1_CEN
//    <name> CEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014800) \nCounter enable Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n0 : B_0x0 = Counter disabled\n1 : B_0x1 = Counter enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.0..0> CEN
//        <0=> 0: B_0x0 = Counter disabled
//        <1=> 1: B_0x1 = Counter enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR1_UDIS  -----------------------------------
// SVD Line: 19570

//  <item> SFDITEM_FIELD__TIM17_CR1_UDIS
//    <name> UDIS </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014800) \nUpdate disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values.\n0 : B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:\n1 : B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.1..1> UDIS
//        <0=> 0: B_0x0 = UEV enabled. The Update (UEV) event is generated by one of the following events:
//        <1=> 1: B_0x1 = UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_CR1_URS  -----------------------------------
// SVD Line: 19594

//  <item> SFDITEM_FIELD__TIM17_CR1_URS
//    <name> URS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014800) \nUpdate request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller\n0 : B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:\n1 : B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.2..2> URS
//        <0=> 0: B_0x0 = Any of the following events generate an update interrupt or DMA request if enabled. These events can be:
//        <1=> 1: B_0x1 = Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_CR1_OPM  -----------------------------------
// SVD Line: 19617

//  <item> SFDITEM_FIELD__TIM17_CR1_OPM
//    <name> OPM </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014800) \nOne pulse mode\n0 : B_0x0 = Counter is not stopped at update event\n1 : B_0x1 = Counter stops counting at the next update event (clearing the bit CEN) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.3..3> OPM
//        <0=> 0: B_0x0 = Counter is not stopped at update event
//        <1=> 1: B_0x1 = Counter stops counting at the next update event (clearing the bit CEN)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR1_ARPE  -----------------------------------
// SVD Line: 19636

//  <item> SFDITEM_FIELD__TIM17_CR1_ARPE
//    <name> ARPE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014800) \nAuto-reload preload enable\n0 : B_0x0 = TIMx_ARR register is not buffered\n1 : B_0x1 = TIMx_ARR register is buffered </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.7..7> ARPE
//        <0=> 0: B_0x0 = TIMx_ARR register is not buffered
//        <1=> 1: B_0x1 = TIMx_ARR register is buffered
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_CR1_CKD  -----------------------------------
// SVD Line: 19655

//  <item> SFDITEM_FIELD__TIM17_CR1_CKD
//    <name> CKD </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014800) \nClock division This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),\n0 : B_0x0 = tDTS=tCK_INT\n1 : B_0x1 = tDTS=2*tCK_INT\n2 : B_0x2 = tDTS=4*tCK_INT\n3 : B_0x3 = Reserved, do not program this value </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.9..8> CKD
//        <0=> 0: B_0x0 = tDTS=tCK_INT
//        <1=> 1: B_0x1 = tDTS=2*tCK_INT
//        <2=> 2: B_0x2 = tDTS=4*tCK_INT
//        <3=> 3: B_0x3 = Reserved, do not program this value
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: TIM17_CR1_UIFREMAP  ---------------------------------
// SVD Line: 19685

//  <item> SFDITEM_FIELD__TIM17_CR1_UIFREMAP
//    <name> UIFREMAP </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014800) \nUIF status bit remapping\n0 : B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.\n1 : B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR1 ) </loc>
//      <o.11..11> UIFREMAP
//        <0=> 0: B_0x0 = No remapping. UIF status bit is not copied to TIMx_CNT register bit 31.
//        <1=> 1: B_0x1 = Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_CR1  -----------------------------------
// SVD Line: 19541

//  <rtree> SFDITEM_REG__TIM17_CR1
//    <name> CR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014800) control register 1 </i>
//    <loc> ( (unsigned int)((TIM17_CR1 >> 0) & 0xFFFFFFFF), ((TIM17_CR1 = (TIM17_CR1 & ~(0xB8FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xB8F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CR1_CEN </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_UDIS </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_URS </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_OPM </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_ARPE </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_CKD </item>
//    <item> SFDITEM_FIELD__TIM17_CR1_UIFREMAP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_CR2  --------------------------------
// SVD Line: 19706

unsigned int TIM17_CR2 __AT (0x40014804);



// -------------------------------  Field Item: TIM17_CR2_CCPC  -----------------------------------
// SVD Line: 19715

//  <item> SFDITEM_FIELD__TIM17_CR2_CCPC
//    <name> CCPC </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014804) \nCapture/compare preloaded control Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded\n1 : B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR2 ) </loc>
//      <o.0..0> CCPC
//        <0=> 0: B_0x0 = CCxE, CCxNE and OCxM bits are not preloaded
//        <1=> 1: B_0x1 = CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when COM bit is set.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR2_CCUS  -----------------------------------
// SVD Line: 19735

//  <item> SFDITEM_FIELD__TIM17_CR2_CCUS
//    <name> CCUS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014804) \nCapture/compare control update selection Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.\n1 : B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR2 ) </loc>
//      <o.2..2> CCUS
//        <0=> 0: B_0x0 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only.
//        <1=> 1: B_0x1 = When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGI.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR2_CCDS  -----------------------------------
// SVD Line: 19755

//  <item> SFDITEM_FIELD__TIM17_CR2_CCDS
//    <name> CCDS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014804) \nCapture/compare DMA selection\n0 : B_0x0 = CCx DMA request sent when CCx event occurs\n1 : B_0x1 = CCx DMA requests sent when update event occurs </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR2 ) </loc>
//      <o.3..3> CCDS
//        <0=> 0: B_0x0 = CCx DMA request sent when CCx event occurs
//        <1=> 1: B_0x1 = CCx DMA requests sent when update event occurs
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR2_OIS1  -----------------------------------
// SVD Line: 19774

//  <item> SFDITEM_FIELD__TIM17_CR2_OIS1
//    <name> OIS1 </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40014804) \nOutput Idle state 1 (OC1 output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0\n1 : B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR2 ) </loc>
//      <o.8..8> OIS1
//        <0=> 0: B_0x0 = OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
//        <1=> 1: B_0x1 = OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CR2_OIS1N  ----------------------------------
// SVD Line: 19794

//  <item> SFDITEM_FIELD__TIM17_CR2_OIS1N
//    <name> OIS1N </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014804) \nOutput Idle state 1 (OC1N output) Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = OC1N=0 after a dead-time when MOE=0\n1 : B_0x1 = OC1N=1 after a dead-time when MOE=0 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CR2 ) </loc>
//      <o.9..9> OIS1N
//        <0=> 0: B_0x0 = OC1N=0 after a dead-time when MOE=0
//        <1=> 1: B_0x1 = OC1N=1 after a dead-time when MOE=0
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_CR2  -----------------------------------
// SVD Line: 19706

//  <rtree> SFDITEM_REG__TIM17_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014804) control register 2 </i>
//    <loc> ( (unsigned int)((TIM17_CR2 >> 0) & 0xFFFFFFFF), ((TIM17_CR2 = (TIM17_CR2 & ~(0x30DUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x30D) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CR2_CCPC </item>
//    <item> SFDITEM_FIELD__TIM17_CR2_CCUS </item>
//    <item> SFDITEM_FIELD__TIM17_CR2_CCDS </item>
//    <item> SFDITEM_FIELD__TIM17_CR2_OIS1 </item>
//    <item> SFDITEM_FIELD__TIM17_CR2_OIS1N </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_DIER  -------------------------------
// SVD Line: 19816

unsigned int TIM17_DIER __AT (0x4001480C);



// -------------------------------  Field Item: TIM17_DIER_UIE  -----------------------------------
// SVD Line: 19825

//  <item> SFDITEM_FIELD__TIM17_DIER_UIE
//    <name> UIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x4001480C) \nUpdate interrupt enable\n0 : B_0x0 = Update interrupt disabled\n1 : B_0x1 = Update interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.0..0> UIE
//        <0=> 0: B_0x0 = Update interrupt disabled
//        <1=> 1: B_0x1 = Update interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_DIER_CC1IE  ----------------------------------
// SVD Line: 19844

//  <item> SFDITEM_FIELD__TIM17_DIER_CC1IE
//    <name> CC1IE </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x4001480C) \nCapture/Compare 1 interrupt enable\n0 : B_0x0 = CC1 interrupt disabled\n1 : B_0x1 = CC1 interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.1..1> CC1IE
//        <0=> 0: B_0x0 = CC1 interrupt disabled
//        <1=> 1: B_0x1 = CC1 interrupt enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_DIER_COMIE  ----------------------------------
// SVD Line: 19863

//  <item> SFDITEM_FIELD__TIM17_DIER_COMIE
//    <name> COMIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x4001480C) \nCOM interrupt enable\n0 : B_0x0 = COM interrupt disabled\n1 : B_0x1 = COM interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.5..5> COMIE
//        <0=> 0: B_0x0 = COM interrupt disabled
//        <1=> 1: B_0x1 = COM interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_DIER_BIE  -----------------------------------
// SVD Line: 19882

//  <item> SFDITEM_FIELD__TIM17_DIER_BIE
//    <name> BIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x4001480C) \nBreak interrupt enable\n0 : B_0x0 = Break interrupt disabled\n1 : B_0x1 = Break interrupt enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.7..7> BIE
//        <0=> 0: B_0x0 = Break interrupt disabled
//        <1=> 1: B_0x1 = Break interrupt enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_DIER_UDE  -----------------------------------
// SVD Line: 19901

//  <item> SFDITEM_FIELD__TIM17_DIER_UDE
//    <name> UDE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x4001480C) \nUpdate DMA request enable\n0 : B_0x0 = Update DMA request disabled\n1 : B_0x1 = Update DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.8..8> UDE
//        <0=> 0: B_0x0 = Update DMA request disabled
//        <1=> 1: B_0x1 = Update DMA request enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_DIER_CC1DE  ----------------------------------
// SVD Line: 19920

//  <item> SFDITEM_FIELD__TIM17_DIER_CC1DE
//    <name> CC1DE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x4001480C) \nCapture/Compare 1 DMA request enable\n0 : B_0x0 = CC1 DMA request disabled\n1 : B_0x1 = CC1 DMA request enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DIER ) </loc>
//      <o.9..9> CC1DE
//        <0=> 0: B_0x0 = CC1 DMA request disabled
//        <1=> 1: B_0x1 = CC1 DMA request enabled
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_DIER  -----------------------------------
// SVD Line: 19816

//  <rtree> SFDITEM_REG__TIM17_DIER
//    <name> DIER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001480C) DMA/Interrupt enable register </i>
//    <loc> ( (unsigned int)((TIM17_DIER >> 0) & 0xFFFFFFFF), ((TIM17_DIER = (TIM17_DIER & ~(0x3A3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3A3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_DIER_UIE </item>
//    <item> SFDITEM_FIELD__TIM17_DIER_CC1IE </item>
//    <item> SFDITEM_FIELD__TIM17_DIER_COMIE </item>
//    <item> SFDITEM_FIELD__TIM17_DIER_BIE </item>
//    <item> SFDITEM_FIELD__TIM17_DIER_UDE </item>
//    <item> SFDITEM_FIELD__TIM17_DIER_CC1DE </item>
//  </rtree>
//  


// -----------------------------  Register Item Address: TIM17_SR  --------------------------------
// SVD Line: 19941

unsigned int TIM17_SR __AT (0x40014810);



// --------------------------------  Field Item: TIM17_SR_UIF  ------------------------------------
// SVD Line: 19950

//  <item> SFDITEM_FIELD__TIM17_SR_UIF
//    <name> UIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014810) \nUpdate interrupt flag This bit is set by hardware on an update event. It is cleared by software. At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n0 : B_0x0 = No update occurred.\n1 : B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_SR ) </loc>
//      <o.0..0> UIF
//        <0=> 0: B_0x0 = No update occurred.
//        <1=> 1: B_0x1 = Update interrupt pending. This bit is set by hardware when the registers are updated:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_SR_CC1IF  -----------------------------------
// SVD Line: 19972

//  <item> SFDITEM_FIELD__TIM17_SR_CC1IF
//    <name> CC1IF </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014810) \nCapture/Compare 1 interrupt flag This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only). If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description. If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).\n0 : B_0x0 = No compare match / No input capture occurred\n1 : B_0x1 = A compare match or an input capture occurred </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_SR ) </loc>
//      <o.1..1> CC1IF
//        <0=> 0: B_0x0 = No compare match / No input capture occurred
//        <1=> 1: B_0x1 = A compare match or an input capture occurred
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_SR_COMIF  -----------------------------------
// SVD Line: 19994

//  <item> SFDITEM_FIELD__TIM17_SR_COMIF
//    <name> COMIF </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40014810) \nCOM interrupt flag This flag is set by hardware on a COM event (once the capture/compare control bits CCxE, CCxNE, OCxM have been updated). It is cleared by software.\n0 : B_0x0 = No COM event occurred\n1 : B_0x1 = COM interrupt pending </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_SR ) </loc>
//      <o.5..5> COMIF
//        <0=> 0: B_0x0 = No COM event occurred
//        <1=> 1: B_0x1 = COM interrupt pending
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_SR_BIF  ------------------------------------
// SVD Line: 20014

//  <item> SFDITEM_FIELD__TIM17_SR_BIF
//    <name> BIF </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40014810) \nBreak interrupt flag This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.\n0 : B_0x0 = No break event occurred\n1 : B_0x1 = An active level has been detected on the break input </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_SR ) </loc>
//      <o.7..7> BIF
//        <0=> 0: B_0x0 = No break event occurred
//        <1=> 1: B_0x1 = An active level has been detected on the break input
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_SR_CC1OF  -----------------------------------
// SVD Line: 20034

//  <item> SFDITEM_FIELD__TIM17_SR_CC1OF
//    <name> CC1OF </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014810) \nCapture/Compare 1 overcapture flag This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0.\n0 : B_0x0 = No overcapture has been detected\n1 : B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_SR ) </loc>
//      <o.9..9> CC1OF
//        <0=> 0: B_0x0 = No overcapture has been detected
//        <1=> 1: B_0x1 = The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_SR  ------------------------------------
// SVD Line: 19941

//  <rtree> SFDITEM_REG__TIM17_SR
//    <name> SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014810) status register </i>
//    <loc> ( (unsigned int)((TIM17_SR >> 0) & 0xFFFFFFFF), ((TIM17_SR = (TIM17_SR & ~(0x2A3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x2A3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_SR_UIF </item>
//    <item> SFDITEM_FIELD__TIM17_SR_CC1IF </item>
//    <item> SFDITEM_FIELD__TIM17_SR_COMIF </item>
//    <item> SFDITEM_FIELD__TIM17_SR_BIF </item>
//    <item> SFDITEM_FIELD__TIM17_SR_CC1OF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_EGR  --------------------------------
// SVD Line: 20056

unsigned int TIM17_EGR __AT (0x40014814);



// --------------------------------  Field Item: TIM17_EGR_UG  ------------------------------------
// SVD Line: 20065

//  <item> SFDITEM_FIELD__TIM17_EGR_UG
//    <name> UG </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40014814) \nUpdate generation This bit can be set by software, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_EGR ) </loc>
//      <o.0..0> UG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_EGR_CC1G  -----------------------------------
// SVD Line: 20085

//  <item> SFDITEM_FIELD__TIM17_EGR_CC1G
//    <name> CC1G </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40014814) \nCapture/Compare 1 generation This bit is set by software in order to generate an event, it is automatically cleared by hardware. If channel CC1 is configured as output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If channel CC1 is configured as input: The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.\n0 : B_0x0 = No action.\n1 : B_0x1 = A capture/compare event is generated on channel 1: </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_EGR ) </loc>
//      <o.1..1> CC1G
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = A capture/compare event is generated on channel 1:
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_EGR_COMG  -----------------------------------
// SVD Line: 20109

//  <item> SFDITEM_FIELD__TIM17_EGR_COMG
//    <name> COMG </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40014814) \nCapture/Compare control update generation This bit can be set by software, it is automatically cleared by hardware. Note: This bit acts only on channels that have a complementary output.\n0 : B_0x0 = No action\n1 : B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_EGR ) </loc>
//      <o.5..5> COMG
//        <0=> 0: B_0x0 = No action
//        <1=> 1: B_0x1 = When the CCPC bit is set, it is possible to update the CCxE, CCxNE and OCxM bits
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_EGR_BG  ------------------------------------
// SVD Line: 20130

//  <item> SFDITEM_FIELD__TIM17_EGR_BG
//    <name> BG </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40014814) \nBreak generation This bit is set by software in order to generate an event, it is automatically cleared by hardware.\n0 : B_0x0 = No action.\n1 : B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_EGR ) </loc>
//      <o.7..7> BG
//        <0=> 0: B_0x0 = No action.
//        <1=> 1: B_0x1 = A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_EGR  -----------------------------------
// SVD Line: 20056

//  <rtree> SFDITEM_REG__TIM17_EGR
//    <name> EGR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40014814) event generation register </i>
//    <loc> ( (unsigned int)((TIM17_EGR >> 0) & 0xFFFFFFFF), ((TIM17_EGR = (TIM17_EGR & ~(0xA3UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xA3) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_EGR_UG </item>
//    <item> SFDITEM_FIELD__TIM17_EGR_CC1G </item>
//    <item> SFDITEM_FIELD__TIM17_EGR_COMG </item>
//    <item> SFDITEM_FIELD__TIM17_EGR_BG </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM17_CCMR1_Output  ---------------------------
// SVD Line: 20152

unsigned int TIM17_CCMR1_Output __AT (0x40014818);



// ---------------------------  Field Item: TIM17_CCMR1_Output_CC1S  ------------------------------
// SVD Line: 20162

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Output_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014818) \nCapture/Compare 1 selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Output ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM17_CCMR1_Output_OC1FE  ------------------------------
// SVD Line: 20184

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1FE
//    <name> OC1FE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014818) \nOutput Compare 1 fast enable This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.\n0 : B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.\n1 : B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Output ) </loc>
//      <o.2..2> OC1FE
//        <0=> 0: B_0x0 = CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.
//        <1=> 1: B_0x1 = An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM17_CCMR1_Output_OC1PE  ------------------------------
// SVD Line: 20204

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1PE
//    <name> OC1PE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014818) \nOutput Compare 1 preload enable Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\n0 : B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.\n1 : B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Output ) </loc>
//      <o.3..3> OC1PE
//        <0=> 0: B_0x0 = Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.
//        <1=> 1: B_0x1 = Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM17_CCMR1_Output_OC1M1  ------------------------------
// SVD Line: 20225

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1M1
//    <name> OC1M1 </name>
//    <rw> 
//    <i> [Bits 6..4] RW (@ 0x40014818) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n2 : B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n3 : B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n4 : B_0x4 = Force inactive level - OC1REF is forced low.\n5 : B_0x5 = Force active level - OC1REF is forced high.\n6 : B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.\n7 : B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Output ) </loc>
//      <o.6..4> OC1M1
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <2=> 2: B_0x2 = Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//        <3=> 3: B_0x3 = Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
//        <4=> 4: B_0x4 = Force inactive level - OC1REF is forced low.
//        <5=> 5: B_0x5 = Force active level - OC1REF is forced high.
//        <6=> 6: B_0x6 = PWM mode 1 - Channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive.
//        <7=> 7: B_0x7 = PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active.
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM17_CCMR1_Output_OC1M2  ------------------------------
// SVD Line: 20279

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1M2
//    <name> OC1M2 </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40014818) \nOutput Compare 1 mode These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits. All other values: Reserved Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from frozen mode to PWM mode. The OC1M[3] bit is not contiguous, located in bit 16.\n0 : B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.\n1 : B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Output ) </loc>
//      <o.16..16> OC1M2
//        <0=> 0: B_0x0 = Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
//        <1=> 1: B_0x1 = Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: TIM17_CCMR1_Output  -------------------------------
// SVD Line: 20152

//  <rtree> SFDITEM_REG__TIM17_CCMR1_Output
//    <name> CCMR1_Output </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014818) capture/compare mode register (output  mode) </i>
//    <loc> ( (unsigned int)((TIM17_CCMR1_Output >> 0) & 0xFFFFFFFF), ((TIM17_CCMR1_Output = (TIM17_CCMR1_Output & ~(0x1007FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1007F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Output_CC1S </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1FE </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1PE </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1M1 </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Output_OC1M2 </item>
//  </rtree>
//  


// ------------------------  Register Item Address: TIM17_CCMR1_Input  ----------------------------
// SVD Line: 20335

unsigned int TIM17_CCMR1_Input __AT (0x40014818);



// ---------------------------  Field Item: TIM17_CCMR1_Input_CC1S  -------------------------------
// SVD Line: 20346

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Input_CC1S
//    <name> CC1S </name>
//    <rw> 
//    <i> [Bits 1..0] RW (@ 0x40014818) \nCapture/Compare 1 Selection This bit-field defines the direction of the channel (input/output) as well as the used input. Others: Reserved Note: CC1S bits are writable only when the channel is OFF (CC1E = '0 in TIMx_CCER).\n0 : B_0x0 = CC1 channel is configured as output\n1 : B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1\n2 : Reserved - do not use\n3 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Input ) </loc>
//      <o.1..0> CC1S
//        <0=> 0: B_0x0 = CC1 channel is configured as output
//        <1=> 1: B_0x1 = CC1 channel is configured as input, IC1 is mapped on TI1
//        <2=> 2: 
//        <3=> 3: 
//    </combo>
//  </item>
//  


// --------------------------  Field Item: TIM17_CCMR1_Input_IC1PSC  ------------------------------
// SVD Line: 20368

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Input_IC1PSC
//    <name> IC1PSC </name>
//    <rw> 
//    <i> [Bits 3..2] RW (@ 0x40014818) \nInput capture 1 prescaler This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).\n0 : B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input.\n1 : B_0x1 = capture is done once every 2 events\n2 : B_0x2 = capture is done once every 4 events\n3 : B_0x3 = capture is done once every 8 events </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Input ) </loc>
//      <o.3..2> IC1PSC
//        <0=> 0: B_0x0 = no prescaler, capture is done each time an edge is detected on the capture input.
//        <1=> 1: B_0x1 = capture is done once every 2 events
//        <2=> 2: B_0x2 = capture is done once every 4 events
//        <3=> 3: B_0x3 = capture is done once every 8 events
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: TIM17_CCMR1_Input_IC1F  -------------------------------
// SVD Line: 20399

//  <item> SFDITEM_FIELD__TIM17_CCMR1_Input_IC1F
//    <name> IC1F </name>
//    <rw> 
//    <i> [Bits 7..4] RW (@ 0x40014818) \nInput capture 1 filter This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n0 : B_0x0 = No filter, sampling is done at fDTS\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCMR1_Input ) </loc>
//      <o.7..4> IC1F
//        <0=> 0: B_0x0 = No filter, sampling is done at fDTS
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ----------------------------  Register RTree: TIM17_CCMR1_Input  -------------------------------
// SVD Line: 20335

//  <rtree> SFDITEM_REG__TIM17_CCMR1_Input
//    <name> CCMR1_Input </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014818) capture/compare mode register 1 (input  mode) </i>
//    <loc> ( (unsigned int)((TIM17_CCMR1_Input >> 0) & 0xFFFFFFFF), ((TIM17_CCMR1_Input = (TIM17_CCMR1_Input & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Input_CC1S </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Input_IC1PSC </item>
//    <item> SFDITEM_FIELD__TIM17_CCMR1_Input_IC1F </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_CCER  -------------------------------
// SVD Line: 20491

unsigned int TIM17_CCER __AT (0x40014820);



// -------------------------------  Field Item: TIM17_CCER_CC1E  ----------------------------------
// SVD Line: 20501

//  <item> SFDITEM_FIELD__TIM17_CCER_CC1E
//    <name> CC1E </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014820) \nCapture/Compare 1 output enable When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details.\n0 : B_0x0 = Capture mode disabled / OC1 is not active (see below)\n1 : B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCER ) </loc>
//      <o.0..0> CC1E
//        <0=> 0: B_0x0 = Capture mode disabled / OC1 is not active (see below)
//        <1=> 1: B_0x1 = Capture mode enabled / OC1 signal is output on the corresponding output pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_CCER_CC1P  ----------------------------------
// SVD Line: 20521

//  <item> SFDITEM_FIELD__TIM17_CCER_CC1P
//    <name> CC1P </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014820) \nCapture/Compare 1 output polarity When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations. CC1NP=0, CC1P=0: non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode). CC1NP=0, CC1P=1: inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode). CC1NP=1, CC1P=1: non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode. CC1NP=1, CC1P=0: this configuration is reserved, it must not be used. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.\n0 : B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)\n1 : B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCER ) </loc>
//      <o.1..1> CC1P
//        <0=> 0: B_0x0 = OC1 active high (output mode) / Edge sensitivity selection (input mode, see below)
//        <1=> 1: B_0x1 = OC1 active low (output mode) / Edge sensitivity selection (input mode, see below)
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_CCER_CC1NE  ----------------------------------
// SVD Line: 20547

//  <item> SFDITEM_FIELD__TIM17_CCER_CC1NE
//    <name> CC1NE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014820) \nCapture/Compare 1 complementary output enable\n0 : B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.\n1 : B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCER ) </loc>
//      <o.2..2> CC1NE
//        <0=> 0: B_0x0 = Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//        <1=> 1: B_0x1 = On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_CCER_CC1NP  ----------------------------------
// SVD Line: 20566

//  <item> SFDITEM_FIELD__TIM17_CCER_CC1NP
//    <name> CC1NP </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40014820) \nCapture/Compare 1 complementary output polarity CC1 channel configured as output: CC1 channel configured as input: This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to the description of CC1P. Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output). On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.\n0 : B_0x0 = OC1N active high\n1 : B_0x1 = OC1N active low </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_CCER ) </loc>
//      <o.3..3> CC1NP
//        <0=> 0: B_0x0 = OC1N active high
//        <1=> 1: B_0x1 = OC1N active low
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_CCER  -----------------------------------
// SVD Line: 20491

//  <rtree> SFDITEM_REG__TIM17_CCER
//    <name> CCER </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014820) capture/compare enable  register </i>
//    <loc> ( (unsigned int)((TIM17_CCER >> 0) & 0xFFFFFFFF), ((TIM17_CCER = (TIM17_CCER & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CCER_CC1E </item>
//    <item> SFDITEM_FIELD__TIM17_CCER_CC1P </item>
//    <item> SFDITEM_FIELD__TIM17_CCER_CC1NE </item>
//    <item> SFDITEM_FIELD__TIM17_CCER_CC1NP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_CNT  --------------------------------
// SVD Line: 20593

unsigned int TIM17_CNT __AT (0x40014824);



// --------------------------------  Field Item: TIM17_CNT_CNT  -----------------------------------
// SVD Line: 20601

//  <item> SFDITEM_FIELD__TIM17_CNT_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014824) counter value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM17_CNT >> 0) & 0xFFFF), ((TIM17_CNT = (TIM17_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: TIM17_CNT_UIFCPY  ----------------------------------
// SVD Line: 20608

//  <item> SFDITEM_FIELD__TIM17_CNT_UIFCPY
//    <name> UIFCPY </name>
//    <r> 
//    <i> [Bit 31] RO (@ 0x40014824) UIF Copy </i>
//    <check> 
//      <loc> ( (unsigned int) TIM17_CNT ) </loc>
//      <o.31..31> UIFCPY
//    </check>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_CNT  -----------------------------------
// SVD Line: 20593

//  <rtree> SFDITEM_REG__TIM17_CNT
//    <name> CNT </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014824) counter </i>
//    <loc> ( (unsigned int)((TIM17_CNT >> 0) & 0xFFFFFFFF), ((TIM17_CNT = (TIM17_CNT & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CNT_CNT </item>
//    <item> SFDITEM_FIELD__TIM17_CNT_UIFCPY </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_PSC  --------------------------------
// SVD Line: 20617

unsigned int TIM17_PSC __AT (0x40014828);



// --------------------------------  Field Item: TIM17_PSC_PSC  -----------------------------------
// SVD Line: 20626

//  <item> SFDITEM_FIELD__TIM17_PSC_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014828) Prescaler value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM17_PSC >> 0) & 0xFFFF), ((TIM17_PSC = (TIM17_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_PSC  -----------------------------------
// SVD Line: 20617

//  <rtree> SFDITEM_REG__TIM17_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014828) prescaler </i>
//    <loc> ( (unsigned int)((TIM17_PSC >> 0) & 0xFFFFFFFF), ((TIM17_PSC = (TIM17_PSC & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_PSC_PSC </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_ARR  --------------------------------
// SVD Line: 20634

unsigned int TIM17_ARR __AT (0x4001482C);



// --------------------------------  Field Item: TIM17_ARR_ARR  -----------------------------------
// SVD Line: 20643

//  <item> SFDITEM_FIELD__TIM17_ARR_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001482C) Auto-reload value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM17_ARR >> 0) & 0xFFFF), ((TIM17_ARR = (TIM17_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_ARR  -----------------------------------
// SVD Line: 20634

//  <rtree> SFDITEM_REG__TIM17_ARR
//    <name> ARR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001482C) auto-reload register </i>
//    <loc> ( (unsigned int)((TIM17_ARR >> 0) & 0xFFFFFFFF), ((TIM17_ARR = (TIM17_ARR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_ARR_ARR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_RCR  --------------------------------
// SVD Line: 20651

unsigned int TIM17_RCR __AT (0x40014830);



// --------------------------------  Field Item: TIM17_RCR_REP  -----------------------------------
// SVD Line: 20660

//  <item> SFDITEM_FIELD__TIM17_RCR_REP
//    <name> REP </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014830) Repetition counter value </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM17_RCR >> 0) & 0xFF), ((TIM17_RCR = (TIM17_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_RCR  -----------------------------------
// SVD Line: 20651

//  <rtree> SFDITEM_REG__TIM17_RCR
//    <name> RCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014830) repetition counter register </i>
//    <loc> ( (unsigned int)((TIM17_RCR >> 0) & 0xFFFFFFFF), ((TIM17_RCR = (TIM17_RCR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_RCR_REP </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_CCR1  -------------------------------
// SVD Line: 20668

unsigned int TIM17_CCR1 __AT (0x40014834);



// -------------------------------  Field Item: TIM17_CCR1_CCR1  ----------------------------------
// SVD Line: 20677

//  <item> SFDITEM_FIELD__TIM17_CCR1_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x40014834) Capture/Compare 1 value </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM17_CCR1 >> 0) & 0xFFFF), ((TIM17_CCR1 = (TIM17_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_CCR1  -----------------------------------
// SVD Line: 20668

//  <rtree> SFDITEM_REG__TIM17_CCR1
//    <name> CCR1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014834) capture/compare register 1 </i>
//    <loc> ( (unsigned int)((TIM17_CCR1 >> 0) & 0xFFFFFFFF), ((TIM17_CCR1 = (TIM17_CCR1 & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_CCR1_CCR1 </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_BDTR  -------------------------------
// SVD Line: 20685

unsigned int TIM17_BDTR __AT (0x40014844);



// -------------------------------  Field Item: TIM17_BDTR_DTG  -----------------------------------
// SVD Line: 20694

//  <item> SFDITEM_FIELD__TIM17_BDTR_DTG
//    <name> DTG </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40014844) Dead-time generator setup This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration. DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS Example if TDTS=125ns (8MHz), dead-time possible values are: 0 to 15875 ns by 125 ns steps, 16 s to 31750 ns by 250 ns steps, 32 s to 63 s by 1 s steps, 64 s to 126 s by 2 s steps Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register). </i>
//    <edit> 
//      <loc> ( (unsigned char)((TIM17_BDTR >> 0) & 0xFF), ((TIM17_BDTR = (TIM17_BDTR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_LOCK  ----------------------------------
// SVD Line: 20712

//  <item> SFDITEM_FIELD__TIM17_BDTR_LOCK
//    <name> LOCK </name>
//    <rw> 
//    <i> [Bits 9..8] RW (@ 0x40014844) \nLock configuration These bits offer a write protection against software errors. Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.\n0 : B_0x0 = LOCK OFF - No bit is write protected\n1 : B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.\n2 : B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.\n3 : B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written. </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.9..8> LOCK
//        <0=> 0: B_0x0 = LOCK OFF - No bit is write protected
//        <1=> 1: B_0x1 = LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.
//        <2=> 2: B_0x2 = LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
//        <3=> 3: B_0x3 = LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_OSSI  ----------------------------------
// SVD Line: 20743

//  <item> SFDITEM_FIELD__TIM17_BDTR_OSSI
//    <name> OSSI </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014844) \nOff-state selection for Idle mode This bit is used when MOE=0 on channels configured as outputs. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)\n1 : B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.10..10> OSSI
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_OSSR  ----------------------------------
// SVD Line: 20765

//  <item> SFDITEM_FIELD__TIM17_BDTR_OSSR
//    <name> OSSR </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014844) \nOff-state selection for Run mode This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer. See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846). Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)\n1 : B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer). </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.11..11> OSSR
//        <0=> 0: B_0x0 = When inactive, OC/OCN outputs are disabled (the timer releases the output control which is taken over by the AFIO logic, which forces a Hi-Z state)
//        <1=> 1: B_0x1 = When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_BKE  -----------------------------------
// SVD Line: 20787

//  <item> SFDITEM_FIELD__TIM17_BDTR_BKE
//    <name> BKE </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40014844) \nBreak enable 1; Break inputs (BRK and CCS clock failure event) enabled Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break inputs (BRK and CCS clock failure event) disabled\n1 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.12..12> BKE
//        <0=> 0: B_0x0 = Break inputs (BRK and CCS clock failure event) disabled
//        <1=> 1: 
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_BKP  -----------------------------------
// SVD Line: 20804

//  <item> SFDITEM_FIELD__TIM17_BDTR_BKP
//    <name> BKP </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40014844) \nBreak polarity Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is active low\n1 : B_0x1 = Break input BRK is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.13..13> BKP
//        <0=> 0: B_0x0 = Break input BRK is active low
//        <1=> 1: B_0x1 = Break input BRK is active high
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_AOE  -----------------------------------
// SVD Line: 20825

//  <item> SFDITEM_FIELD__TIM17_BDTR_AOE
//    <name> AOE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40014844) \nAutomatic output enable Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = MOE can be set only by software\n1 : B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active) </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.14..14> AOE
//        <0=> 0: B_0x0 = MOE can be set only by software
//        <1=> 1: B_0x1 = MOE can be set by software or automatically at the next update event (if the break input is not be active)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_MOE  -----------------------------------
// SVD Line: 20845

//  <item> SFDITEM_FIELD__TIM17_BDTR_MOE
//    <name> MOE </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40014844) \nMain output enable This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846).\n0 : B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\n1 : B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details ( </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.15..15> MOE
//        <0=> 0: B_0x0 = OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
//        <1=> 1: B_0x1 = OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register)See OC/OCN enable description for more details (
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_BDTR_BKF  -----------------------------------
// SVD Line: 20866

//  <item> SFDITEM_FIELD__TIM17_BDTR_BKF
//    <name> BKF </name>
//    <rw> 
//    <i> [Bits 19..16] RW (@ 0x40014844) \nBreak filter This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = No filter, BRK acts asynchronously\n1 : B_0x1 = fSAMPLING=fCK_INT, N=2\n2 : B_0x2 = fSAMPLING=fCK_INT, N=4\n3 : B_0x3 = fSAMPLING=fCK_INT, N=8\n4 : B_0x4 = fSAMPLING=fDTS/2, N=6\n5 : B_0x5 = fSAMPLING=fDTS/2, N=8\n6 : B_0x6 = fSAMPLING=fDTS/4, N=6\n7 : B_0x7 = fSAMPLING=fDTS/4, N=8\n8 : B_0x8 = fSAMPLING=fDTS/8, N=6\n9 : B_0x9 = fSAMPLING=fDTS/8, N=8\n10 : B_0xA = fSAMPLING=fDTS/16, N=5\n11 : B_0xB = fSAMPLING=fDTS/16, N=6\n12 : B_0xC = fSAMPLING=fDTS/16, N=8\n13 : B_0xD = fSAMPLING=fDTS/32, N=5\n14 : B_0xE = fSAMPLING=fDTS/32, N=6\n15 : B_0xF = fSAMPLING=fDTS/32, N=8 </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.19..16> BKF
//        <0=> 0: B_0x0 = No filter, BRK acts asynchronously
//        <1=> 1: B_0x1 = fSAMPLING=fCK_INT, N=2
//        <2=> 2: B_0x2 = fSAMPLING=fCK_INT, N=4
//        <3=> 3: B_0x3 = fSAMPLING=fCK_INT, N=8
//        <4=> 4: B_0x4 = fSAMPLING=fDTS/2, N=6
//        <5=> 5: B_0x5 = fSAMPLING=fDTS/2, N=8
//        <6=> 6: B_0x6 = fSAMPLING=fDTS/4, N=6
//        <7=> 7: B_0x7 = fSAMPLING=fDTS/4, N=8
//        <8=> 8: B_0x8 = fSAMPLING=fDTS/8, N=6
//        <9=> 9: B_0x9 = fSAMPLING=fDTS/8, N=8
//        <10=> 10: B_0xA = fSAMPLING=fDTS/16, N=5
//        <11=> 11: B_0xB = fSAMPLING=fDTS/16, N=6
//        <12=> 12: B_0xC = fSAMPLING=fDTS/16, N=8
//        <13=> 13: B_0xD = fSAMPLING=fDTS/32, N=5
//        <14=> 14: B_0xE = fSAMPLING=fDTS/32, N=6
//        <15=> 15: B_0xF = fSAMPLING=fDTS/32, N=8
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_BDTR_BKDSRM  ---------------------------------
// SVD Line: 20957

//  <item> SFDITEM_FIELD__TIM17_BDTR_BKDSRM
//    <name> BKDSRM </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40014844) \nBreak Disarm This bit is cleared by hardware when no break source is active. The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared. Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK is armed\n1 : B_0x1 = Break input BRK is disarmed </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.26..26> BKDSRM
//        <0=> 0: B_0x0 = Break input BRK is armed
//        <1=> 1: B_0x1 = Break input BRK is disarmed
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_BDTR_BKBID  ----------------------------------
// SVD Line: 20979

//  <item> SFDITEM_FIELD__TIM17_BDTR_BKBID
//    <name> BKBID </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40014844) \nBreak Bidirectional In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices. Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register). Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\n0 : B_0x0 = Break input BRK in input mode\n1 : B_0x1 = Break input BRK in bidirectional mode </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_BDTR ) </loc>
//      <o.28..28> BKBID
//        <0=> 0: B_0x0 = Break input BRK in input mode
//        <1=> 1: B_0x1 = Break input BRK in bidirectional mode
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_BDTR  -----------------------------------
// SVD Line: 20685

//  <rtree> SFDITEM_REG__TIM17_BDTR
//    <name> BDTR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014844) break and dead-time register </i>
//    <loc> ( (unsigned int)((TIM17_BDTR >> 0) & 0xFFFFFFFF), ((TIM17_BDTR = (TIM17_BDTR & ~(0x140FFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x140FFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_BDTR_DTG </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_LOCK </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_OSSI </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_OSSR </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_BKE </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_BKP </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_AOE </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_MOE </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_BKF </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_BKDSRM </item>
//    <item> SFDITEM_FIELD__TIM17_BDTR_BKBID </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_DCR  --------------------------------
// SVD Line: 21003

unsigned int TIM17_DCR __AT (0x40014848);



// --------------------------------  Field Item: TIM17_DCR_DBA  -----------------------------------
// SVD Line: 21012

//  <item> SFDITEM_FIELD__TIM17_DCR_DBA
//    <name> DBA </name>
//    <rw> 
//    <i> [Bits 4..0] RW (@ 0x40014848) \nDMA base address This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register. Example: ... Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.\n0 : B_0x0 = TIMx_CR1,\n1 : B_0x1 = TIMx_CR2,\n2 : B_0x2 = TIMx_SMCR,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : Reserved - do not use\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DCR ) </loc>
//      <o.4..0> DBA
//        <0=> 0: B_0x0 = TIMx_CR1,
//        <1=> 1: B_0x1 = TIMx_CR2,
//        <2=> 2: B_0x2 = TIMx_SMCR,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: 
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Field Item: TIM17_DCR_DBL  -----------------------------------
// SVD Line: 21040

//  <item> SFDITEM_FIELD__TIM17_DCR_DBL
//    <name> DBL </name>
//    <rw> 
//    <i> [Bits 12..8] RW (@ 0x40014848) \nDMA burst length This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below). ...\n0 : B_0x0 = 1 transfer,\n1 : B_0x1 = 2 transfers,\n2 : B_0x2 = 3 transfers,\n3 : Reserved - do not use\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use\n16 : Reserved - do not use\n17 : B_0x11 = 18 transfers.\n18 : Reserved - do not use\n19 : Reserved - do not use\n20 : Reserved - do not use\n21 : Reserved - do not use\n22 : Reserved - do not use\n23 : Reserved - do not use\n24 : Reserved - do not use\n25 : Reserved - do not use\n26 : Reserved - do not use\n27 : Reserved - do not use\n28 : Reserved - do not use\n29 : Reserved - do not use\n30 : Reserved - do not use\n31 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_DCR ) </loc>
//      <o.12..8> DBL
//        <0=> 0: B_0x0 = 1 transfer,
//        <1=> 1: B_0x1 = 2 transfers,
//        <2=> 2: B_0x2 = 3 transfers,
//        <3=> 3: 
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//        <16=> 16: 
//        <17=> 17: B_0x11 = 18 transfers.
//        <18=> 18: 
//        <19=> 19: 
//        <20=> 20: 
//        <21=> 21: 
//        <22=> 22: 
//        <23=> 23: 
//        <24=> 24: 
//        <25=> 25: 
//        <26=> 26: 
//        <27=> 27: 
//        <28=> 28: 
//        <29=> 29: 
//        <30=> 30: 
//        <31=> 31: 
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_DCR  -----------------------------------
// SVD Line: 21003

//  <rtree> SFDITEM_REG__TIM17_DCR
//    <name> DCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014848) DMA control register </i>
//    <loc> ( (unsigned int)((TIM17_DCR >> 0) & 0xFFFFFFFF), ((TIM17_DCR = (TIM17_DCR & ~(0x1F1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_DCR_DBA </item>
//    <item> SFDITEM_FIELD__TIM17_DCR_DBL </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_DMAR  -------------------------------
// SVD Line: 21073

unsigned int TIM17_DMAR __AT (0x4001484C);



// -------------------------------  Field Item: TIM17_DMAR_DMAB  ----------------------------------
// SVD Line: 21082

//  <item> SFDITEM_FIELD__TIM17_DMAR_DMAB
//    <name> DMAB </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001484C) DMA register for burst  accesses </i>
//    <edit> 
//      <loc> ( (unsigned short)((TIM17_DMAR >> 0) & 0xFFFF), ((TIM17_DMAR = (TIM17_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_DMAR  -----------------------------------
// SVD Line: 21073

//  <rtree> SFDITEM_REG__TIM17_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001484C) DMA address for full transfer </i>
//    <loc> ( (unsigned int)((TIM17_DMAR >> 0) & 0xFFFFFFFF), ((TIM17_DMAR = (TIM17_DMAR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_DMAR_DMAB </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: TIM17_AF1  --------------------------------
// SVD Line: 21091

unsigned int TIM17_AF1 __AT (0x40014860);



// -------------------------------  Field Item: TIM17_AF1_BKINE  ----------------------------------
// SVD Line: 21100

//  <item> SFDITEM_FIELD__TIM17_AF1_BKINE
//    <name> BKINE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40014860) \nBRK BKIN input enable This bit enables the BKIN alternate function input for the timers BRK input. BKIN input is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input disabled\n1 : B_0x1 = BKIN input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.0..0> BKINE
//        <0=> 0: B_0x0 = BKIN input disabled
//        <1=> 1: B_0x1 = BKIN input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_AF1_BKCMP1E  ---------------------------------
// SVD Line: 21121

//  <item> SFDITEM_FIELD__TIM17_AF1_BKCMP1E
//    <name> BKCMP1E </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40014860) \nBRK COMP1 enable This bit enables the COMP1 for the timers BRK input. COMP1 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input disabled\n1 : B_0x1 = COMP1 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.1..1> BKCMP1E
//        <0=> 0: B_0x0 = COMP1 input disabled
//        <1=> 1: B_0x1 = COMP1 input enabled
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_AF1_BKCMP2E  ---------------------------------
// SVD Line: 21142

//  <item> SFDITEM_FIELD__TIM17_AF1_BKCMP2E
//    <name> BKCMP2E </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40014860) \nBRK COMP2 enable This bit enables the COMP2 for the timers BRK input. COMP2 output is 'ORed with the other BRK sources. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input disabled\n1 : B_0x1 = COMP2 input enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.2..2> BKCMP2E
//        <0=> 0: B_0x0 = COMP2 input disabled
//        <1=> 1: B_0x1 = COMP2 input enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: TIM17_AF1_BKINP  ----------------------------------
// SVD Line: 21163

//  <item> SFDITEM_FIELD__TIM17_AF1_BKINP
//    <name> BKINP </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40014860) \nBRK BKIN input polarity This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = BKIN input is active low\n1 : B_0x1 = BKIN input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.9..9> BKINP
//        <0=> 0: B_0x0 = BKIN input is active low
//        <1=> 1: B_0x1 = BKIN input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_AF1_BKCMP1P  ---------------------------------
// SVD Line: 21184

//  <item> SFDITEM_FIELD__TIM17_AF1_BKCMP1P
//    <name> BKCMP1P </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40014860) \nBRK COMP1 input polarity This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP1 input is active low\n1 : B_0x1 = COMP1 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.10..10> BKCMP1P
//        <0=> 0: B_0x0 = COMP1 input is active low
//        <1=> 1: B_0x1 = COMP1 input is active high
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: TIM17_AF1_BKCMP2P  ---------------------------------
// SVD Line: 21205

//  <item> SFDITEM_FIELD__TIM17_AF1_BKCMP2P
//    <name> BKCMP2P </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40014860) \nBRK COMP2 input polarity This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit. Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n0 : B_0x0 = COMP2 input is active low\n1 : B_0x1 = COMP2 input is active high </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_AF1 ) </loc>
//      <o.11..11> BKCMP2P
//        <0=> 0: B_0x0 = COMP2 input is active low
//        <1=> 1: B_0x1 = COMP2 input is active high
//    </combo>
//  </item>
//  


// --------------------------------  Register RTree: TIM17_AF1  -----------------------------------
// SVD Line: 21091

//  <rtree> SFDITEM_REG__TIM17_AF1
//    <name> AF1 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014860) TIM17 option register 1 </i>
//    <loc> ( (unsigned int)((TIM17_AF1 >> 0) & 0xFFFFFFFF), ((TIM17_AF1 = (TIM17_AF1 & ~(0xE07UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xE07) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKINE </item>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKCMP1E </item>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKCMP2E </item>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKINP </item>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKCMP1P </item>
//    <item> SFDITEM_FIELD__TIM17_AF1_BKCMP2P </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: TIM17_TISEL  -------------------------------
// SVD Line: 21228

unsigned int TIM17_TISEL __AT (0x40014868);



// -----------------------------  Field Item: TIM17_TISEL_TI1SEL  ---------------------------------
// SVD Line: 21237

//  <item> SFDITEM_FIELD__TIM17_TISEL_TI1SEL
//    <name> TI1SEL </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x40014868) \nselects TI1[0] to TI1[15] input Others: Reserved\n0 : B_0x0 = TIM16_CH1 input\n1 : B_0x1 = LSI\n2 : B_0x2 = LSE\n3 : B_0x3 = RTC wakeup\n4 : Reserved - do not use\n5 : Reserved - do not use\n6 : Reserved - do not use\n7 : Reserved - do not use\n8 : Reserved - do not use\n9 : Reserved - do not use\n10 : Reserved - do not use\n11 : Reserved - do not use\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) TIM17_TISEL ) </loc>
//      <o.3..0> TI1SEL
//        <0=> 0: B_0x0 = TIM16_CH1 input
//        <1=> 1: B_0x1 = LSI
//        <2=> 2: B_0x2 = LSE
//        <3=> 3: B_0x3 = RTC wakeup
//        <4=> 4: 
//        <5=> 5: 
//        <6=> 6: 
//        <7=> 7: 
//        <8=> 8: 
//        <9=> 9: 
//        <10=> 10: 
//        <11=> 11: 
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: TIM17_TISEL  ----------------------------------
// SVD Line: 21228

//  <rtree> SFDITEM_REG__TIM17_TISEL
//    <name> TISEL </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40014868) input selection register </i>
//    <loc> ( (unsigned int)((TIM17_TISEL >> 0) & 0xFFFFFFFF), ((TIM17_TISEL = (TIM17_TISEL & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__TIM17_TISEL_TI1SEL </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: TIM17  -------------------------------------
// SVD Line: 21271

//  <view> TIM17
//    <name> TIM17 </name>
//    <item> SFDITEM_REG__TIM17_CR1 </item>
//    <item> SFDITEM_REG__TIM17_CR2 </item>
//    <item> SFDITEM_REG__TIM17_DIER </item>
//    <item> SFDITEM_REG__TIM17_SR </item>
//    <item> SFDITEM_REG__TIM17_EGR </item>
//    <item> SFDITEM_REG__TIM17_CCMR1_Output </item>
//    <item> SFDITEM_REG__TIM17_CCMR1_Input </item>
//    <item> SFDITEM_REG__TIM17_CCER </item>
//    <item> SFDITEM_REG__TIM17_CNT </item>
//    <item> SFDITEM_REG__TIM17_PSC </item>
//    <item> SFDITEM_REG__TIM17_ARR </item>
//    <item> SFDITEM_REG__TIM17_RCR </item>
//    <item> SFDITEM_REG__TIM17_CCR1 </item>
//    <item> SFDITEM_REG__TIM17_BDTR </item>
//    <item> SFDITEM_REG__TIM17_DCR </item>
//    <item> SFDITEM_REG__TIM17_DMAR </item>
//    <item> SFDITEM_REG__TIM17_AF1 </item>
//    <item> SFDITEM_REG__TIM17_TISEL </item>
//  </view>
//  


// ---------------------  Register Item Address: USART1_CR1_FIFO_ENABLED  -------------------------
// SVD Line: 21297

unsigned int USART1_CR1_FIFO_ENABLED __AT (0x40013800);



// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_UE  -----------------------------
// SVD Line: 21306

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_UE
//    <name> UE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40013800) \nUSART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.\n0 : B_0x0 = USART prescaler and outputs disabled, low-power mode\n1 : B_0x1 = USART enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.0..0> UE
//        <0=> 0: B_0x0 = USART prescaler and outputs disabled, low-power mode
//        <1=> 1: B_0x1 = USART enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_UESM  ----------------------------
// SVD Line: 21329

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_UESM
//    <name> UESM </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40013800) \nUSART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = USART not able to wake up the MCU from low-power mode.\n1 : B_0x1 = USART able to wake up the MCU from low-power mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.1..1> UESM
//        <0=> 0: B_0x0 = USART not able to wake up the MCU from low-power mode.
//        <1=> 1: B_0x1 = USART able to wake up the MCU from low-power mode.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_RE  -----------------------------
// SVD Line: 21353

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RE
//    <name> RE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40013800) \nReceiver enable This bit enables the receiver. It is set and cleared by software.\n0 : B_0x0 = Receiver is disabled\n1 : B_0x1 = Receiver is enabled and begins searching for a start bit </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.2..2> RE
//        <0=> 0: B_0x0 = Receiver is disabled
//        <1=> 1: B_0x1 = Receiver is enabled and begins searching for a start bit
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_TE  -----------------------------
// SVD Line: 21373

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TE
//    <name> TE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40013800) \nTransmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0 followed by '1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.\n0 : B_0x0 = Transmitter is disabled\n1 : B_0x1 = Transmitter is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.3..3> TE
//        <0=> 0: B_0x0 = Transmitter is disabled
//        <1=> 1: B_0x1 = Transmitter is enabled
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_IDLEIE  ---------------------------
// SVD Line: 21395

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_IDLEIE
//    <name> IDLEIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40013800) \nIDLE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.4..4> IDLEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_RXFNEIE  --------------------------
// SVD Line: 21415

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RXFNEIE
//    <name> RXFNEIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40013800) \nRXFIFO not empty interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.5..5> RXFNEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_TCIE  ----------------------------
// SVD Line: 21435

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40013800) \nTransmission complete interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_TXFNFIE  --------------------------
// SVD Line: 21455

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TXFNFIE
//    <name> TXFNFIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40013800) \nTXFIFO not full interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TXFNF =1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.7..7> TXFNFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TXFNF =1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_PEIE  ----------------------------
// SVD Line: 21475

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PEIE
//    <name> PEIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40013800) \nPE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.8..8> PEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_PS  -----------------------------
// SVD Line: 21495

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PS
//    <name> PS </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40013800) \nParity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Even parity\n1 : B_0x1 = Odd parity </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.9..9> PS
//        <0=> 0: B_0x0 = Even parity
//        <1=> 1: B_0x1 = Odd parity
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_PCE  ----------------------------
// SVD Line: 21516

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PCE
//    <name> PCE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40013800) \nParity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Parity control disabled\n1 : B_0x1 = Parity control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.10..10> PCE
//        <0=> 0: B_0x0 = Parity control disabled
//        <1=> 1: B_0x1 = Parity control enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_WAKE  ----------------------------
// SVD Line: 21537

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_WAKE
//    <name> WAKE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40013800) \nReceiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Idle line\n1 : B_0x1 = Address mark </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.11..11> WAKE
//        <0=> 0: B_0x0 = Idle line
//        <1=> 1: B_0x1 = Address mark
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_M0  -----------------------------
// SVD Line: 21558

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_M0
//    <name> M0 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40013800) Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE=0). </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.12..12> M0
//    </check>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_MME  ----------------------------
// SVD Line: 21567

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_MME
//    <name> MME </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40013800) \nMute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0 : B_0x0 = Receiver in active mode permanently\n1 : B_0x1 = Receiver can switch between Mute mode and active mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.13..13> MME
//        <0=> 0: B_0x0 = Receiver in active mode permanently
//        <1=> 1: B_0x1 = Receiver can switch between Mute mode and active mode.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_CMIE  ----------------------------
// SVD Line: 21587

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_CMIE
//    <name> CMIE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40013800) \nCharacter match interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.14..14> CMIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_OVER8  ---------------------------
// SVD Line: 21607

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_OVER8
//    <name> OVER8 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40013800) \nOversampling mode This bit can only be written when the USART is disabled (UE=0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.\n0 : B_0x0 = Oversampling by 16\n1 : B_0x1 = Oversampling by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.15..15> OVER8
//        <0=> 0: B_0x0 = Oversampling by 16
//        <1=> 1: B_0x1 = Oversampling by 8
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_DEDT  ----------------------------
// SVD Line: 21628

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_DEDT
//    <name> DEDT </name>
//    <rw> 
//    <i> [Bits 20..16] RW (@ 0x40013800) Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_CR1_FIFO_ENABLED >> 16) & 0x1F), ((USART1_CR1_FIFO_ENABLED = (USART1_CR1_FIFO_ENABLED & ~(0x1FUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_DEAT  ----------------------------
// SVD Line: 21639

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_DEAT
//    <name> DEAT </name>
//    <rw> 
//    <i> [Bits 25..21] RW (@ 0x40013800) Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_CR1_FIFO_ENABLED >> 21) & 0x1F), ((USART1_CR1_FIFO_ENABLED = (USART1_CR1_FIFO_ENABLED & ~(0x1FUL << 21 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 21 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_RTOIE  ---------------------------
// SVD Line: 21649

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RTOIE
//    <name> RTOIE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40013800) \nReceiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.26..26> RTOIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_ENABLED_EOBIE  ---------------------------
// SVD Line: 21670

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_EOBIE
//    <name> EOBIE </name>
//    <rw> 
//    <i> [Bit 27] RW (@ 0x40013800) \nEnd of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.27..27> EOBIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_ENABLED_M1  -----------------------------
// SVD Line: 21691

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_M1
//    <name> M1 </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40013800) Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UE=0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.28..28> M1
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_FIFOEN  ---------------------------
// SVD Line: 21704

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_FIFOEN
//    <name> FIFOEN </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40013800) \nFIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.\n0 : B_0x0 = FIFO mode is disabled.\n1 : B_0x1 = FIFO mode is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.29..29> FIFOEN
//        <0=> 0: B_0x0 = FIFO mode is disabled.
//        <1=> 1: B_0x1 = FIFO mode is enabled.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_TXFEIE  ---------------------------
// SVD Line: 21726

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TXFEIE
//    <name> TXFEIE </name>
//    <rw> 
//    <i> [Bit 30] RW (@ 0x40013800) \nTXFIFO empty interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when TXFE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.30..30> TXFEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when TXFE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_ENABLED_RXFFIE  ---------------------------
// SVD Line: 21746

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RXFFIE
//    <name> RXFFIE </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40013800) \nRXFIFO Full interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when RXFF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_ENABLED ) </loc>
//      <o.31..31> RXFFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when RXFF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Register RTree: USART1_CR1_FIFO_ENABLED  ----------------------------
// SVD Line: 21297

//  <rtree> SFDITEM_REG__USART1_CR1_FIFO_ENABLED
//    <name> CR1_FIFO_ENABLED </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013800) Control register 1 </i>
//    <loc> ( (unsigned int)((USART1_CR1_FIFO_ENABLED >> 0) & 0xFFFFFFFF), ((USART1_CR1_FIFO_ENABLED = (USART1_CR1_FIFO_ENABLED & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_UE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_UESM </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_IDLEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RXFNEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TCIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TXFNFIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PS </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_PCE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_WAKE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_M0 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_MME </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_CMIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_OVER8 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_DEDT </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_DEAT </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RTOIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_EOBIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_M1 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_FIFOEN </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_TXFEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_ENABLED_RXFFIE </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART1_CR1_FIFO_DISABLED  ------------------------
// SVD Line: 21768

unsigned int USART1_CR1_FIFO_DISABLED __AT (0x40013800);



// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_UE  ----------------------------
// SVD Line: 21778

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_UE
//    <name> UE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40013800) \nUSART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.\n0 : B_0x0 = USART prescaler and outputs disabled, low-power mode\n1 : B_0x1 = USART enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.0..0> UE
//        <0=> 0: B_0x0 = USART prescaler and outputs disabled, low-power mode
//        <1=> 1: B_0x1 = USART enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_UESM  ---------------------------
// SVD Line: 21801

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_UESM
//    <name> UESM </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40013800) \nUSART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = USART not able to wake up the MCU from low-power mode.\n1 : B_0x1 = USART able to wake up the MCU from low-power mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.1..1> UESM
//        <0=> 0: B_0x0 = USART not able to wake up the MCU from low-power mode.
//        <1=> 1: B_0x1 = USART able to wake up the MCU from low-power mode.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_RE  ----------------------------
// SVD Line: 21825

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RE
//    <name> RE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40013800) \nReceiver enable This bit enables the receiver. It is set and cleared by software.\n0 : B_0x0 = Receiver is disabled\n1 : B_0x1 = Receiver is enabled and begins searching for a start bit </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.2..2> RE
//        <0=> 0: B_0x0 = Receiver is disabled
//        <1=> 1: B_0x1 = Receiver is enabled and begins searching for a start bit
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_TE  ----------------------------
// SVD Line: 21845

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TE
//    <name> TE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40013800) \nTransmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0 followed by '1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.\n0 : B_0x0 = Transmitter is disabled\n1 : B_0x1 = Transmitter is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.3..3> TE
//        <0=> 0: B_0x0 = Transmitter is disabled
//        <1=> 1: B_0x1 = Transmitter is enabled
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_IDLEIE  --------------------------
// SVD Line: 21867

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_IDLEIE
//    <name> IDLEIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40013800) \nIDLE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.4..4> IDLEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_RXNEIE  --------------------------
// SVD Line: 21887

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RXNEIE
//    <name> RXNEIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40013800) \nReceive data register not empty This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.5..5> RXNEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_TCIE  ---------------------------
// SVD Line: 21907

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40013800) \nTransmission complete interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_TXEIE  ---------------------------
// SVD Line: 21927

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TXEIE
//    <name> TXEIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40013800) \nTransmit data register empty This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TXE =1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.7..7> TXEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TXE =1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_PEIE  ---------------------------
// SVD Line: 21947

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PEIE
//    <name> PEIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40013800) \nPE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.8..8> PEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_PS  ----------------------------
// SVD Line: 21967

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PS
//    <name> PS </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40013800) \nParity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Even parity\n1 : B_0x1 = Odd parity </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.9..9> PS
//        <0=> 0: B_0x0 = Even parity
//        <1=> 1: B_0x1 = Odd parity
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_PCE  ----------------------------
// SVD Line: 21988

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PCE
//    <name> PCE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40013800) \nParity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Parity control disabled\n1 : B_0x1 = Parity control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.10..10> PCE
//        <0=> 0: B_0x0 = Parity control disabled
//        <1=> 1: B_0x1 = Parity control enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_WAKE  ---------------------------
// SVD Line: 22009

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_WAKE
//    <name> WAKE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40013800) \nReceiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Idle line\n1 : B_0x1 = Address mark </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.11..11> WAKE
//        <0=> 0: B_0x0 = Idle line
//        <1=> 1: B_0x1 = Address mark
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_M0  ----------------------------
// SVD Line: 22030

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_M0
//    <name> M0 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40013800) Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE=0). </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.12..12> M0
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_MME  ----------------------------
// SVD Line: 22039

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_MME
//    <name> MME </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40013800) \nMute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0 : B_0x0 = Receiver in active mode permanently\n1 : B_0x1 = Receiver can switch between Mute mode and active mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.13..13> MME
//        <0=> 0: B_0x0 = Receiver in active mode permanently
//        <1=> 1: B_0x1 = Receiver can switch between Mute mode and active mode.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_CMIE  ---------------------------
// SVD Line: 22059

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_CMIE
//    <name> CMIE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40013800) \nCharacter match interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.14..14> CMIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_OVER8  ---------------------------
// SVD Line: 22079

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_OVER8
//    <name> OVER8 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40013800) \nOversampling mode This bit can only be written when the USART is disabled (UE=0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.\n0 : B_0x0 = Oversampling by 16\n1 : B_0x1 = Oversampling by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.15..15> OVER8
//        <0=> 0: B_0x0 = Oversampling by 16
//        <1=> 1: B_0x1 = Oversampling by 8
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_DEDT  ---------------------------
// SVD Line: 22100

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_DEDT
//    <name> DEDT </name>
//    <rw> 
//    <i> [Bits 20..16] RW (@ 0x40013800) Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_CR1_FIFO_DISABLED >> 16) & 0x1F), ((USART1_CR1_FIFO_DISABLED = (USART1_CR1_FIFO_DISABLED & ~(0x1FUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART1_CR1_FIFO_DISABLED_DEAT  ---------------------------
// SVD Line: 22111

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_DEAT
//    <name> DEAT </name>
//    <rw> 
//    <i> [Bits 25..21] RW (@ 0x40013800) Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_CR1_FIFO_DISABLED >> 21) & 0x1F), ((USART1_CR1_FIFO_DISABLED = (USART1_CR1_FIFO_DISABLED & ~(0x1FUL << 21 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 21 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_RTOIE  ---------------------------
// SVD Line: 22121

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RTOIE
//    <name> RTOIE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40013800) \nReceiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.26..26> RTOIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_EOBIE  ---------------------------
// SVD Line: 22142

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_EOBIE
//    <name> EOBIE </name>
//    <rw> 
//    <i> [Bit 27] RW (@ 0x40013800) \nEnd of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.27..27> EOBIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_CR1_FIFO_DISABLED_M1  ----------------------------
// SVD Line: 22163

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_M1
//    <name> M1 </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40013800) Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UE=0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.28..28> M1
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART1_CR1_FIFO_DISABLED_FIFOEN  --------------------------
// SVD Line: 22176

//  <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_FIFOEN
//    <name> FIFOEN </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40013800) \nFIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.\n0 : B_0x0 = FIFO mode is disabled.\n1 : B_0x1 = FIFO mode is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR1_FIFO_DISABLED ) </loc>
//      <o.29..29> FIFOEN
//        <0=> 0: B_0x0 = FIFO mode is disabled.
//        <1=> 1: B_0x1 = FIFO mode is enabled.
//    </combo>
//  </item>
//  


// ------------------------  Register RTree: USART1_CR1_FIFO_DISABLED  ----------------------------
// SVD Line: 21768

//  <rtree> SFDITEM_REG__USART1_CR1_FIFO_DISABLED
//    <name> CR1_FIFO_DISABLED </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013800) Control register 1 </i>
//    <loc> ( (unsigned int)((USART1_CR1_FIFO_DISABLED >> 0) & 0xFFFFFFFF), ((USART1_CR1_FIFO_DISABLED = (USART1_CR1_FIFO_DISABLED & ~(0x3FFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_UE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_UESM </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_IDLEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RXNEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TCIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_TXEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PEIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PS </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_PCE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_WAKE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_M0 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_MME </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_CMIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_OVER8 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_DEDT </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_DEAT </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_RTOIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_EOBIE </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_M1 </item>
//    <item> SFDITEM_FIELD__USART1_CR1_FIFO_DISABLED_FIFOEN </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_CR2  -------------------------------
// SVD Line: 22200

unsigned int USART1_CR2 __AT (0x40013804);



// ------------------------------  Field Item: USART1_CR2_SLVEN  ----------------------------------
// SVD Line: 22209

//  <item> SFDITEM_FIELD__USART1_CR2_SLVEN
//    <name> SLVEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40013804) \nSynchronous Slave mode enable When the SLVEN bit is set, the synchronous slave mode is enabled. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Slave mode disabled.\n1 : B_0x1 = Slave mode enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.0..0> SLVEN
//        <0=> 0: B_0x0 = Slave mode disabled.
//        <1=> 1: B_0x1 = Slave mode enabled.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR2_DIS_NSS  ---------------------------------
// SVD Line: 22230

//  <item> SFDITEM_FIELD__USART1_CR2_DIS_NSS
//    <name> DIS_NSS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40013804) \nWhen the DIS_NSS bit is set, the NSS pin input is ignored. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = SPI slave selection depends on NSS input pin.\n1 : B_0x1 = SPI slave is always selected and NSS input pin is ignored. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.3..3> DIS_NSS
//        <0=> 0: B_0x0 = SPI slave selection depends on NSS input pin.
//        <1=> 1: B_0x1 = SPI slave is always selected and NSS input pin is ignored.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_ADDM7  ----------------------------------
// SVD Line: 22250

//  <item> SFDITEM_FIELD__USART1_CR2_ADDM7
//    <name> ADDM7 </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40013804) \n7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the USART is disabled (UE=0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.\n0 : B_0x0 = 4-bit address detection\n1 : B_0x1 = 7-bit address detection (in 8-bit data mode) </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.4..4> ADDM7
//        <0=> 0: B_0x0 = 4-bit address detection
//        <1=> 1: B_0x1 = 7-bit address detection (in 8-bit data mode)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_LBDL  ----------------------------------
// SVD Line: 22272

//  <item> SFDITEM_FIELD__USART1_CR2_LBDL
//    <name> LBDL </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40013804) \nLIN break detection length This bit is for selection between 11 bit or 10 bit break detection. This bit can only be written when the USART is disabled (UE=0). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = 10-bit break detection\n1 : B_0x1 = 11-bit break detection </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.5..5> LBDL
//        <0=> 0: B_0x0 = 10-bit break detection
//        <1=> 1: B_0x1 = 11-bit break detection
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_LBDIE  ----------------------------------
// SVD Line: 22294

//  <item> SFDITEM_FIELD__USART1_CR2_LBDIE
//    <name> LBDIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40013804) \nLIN break detection interrupt enable Break interrupt mask (break detection using break delimiter). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt is inhibited\n1 : B_0x1 = An interrupt is generated whenever LBDF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.6..6> LBDIE
//        <0=> 0: B_0x0 = Interrupt is inhibited
//        <1=> 1: B_0x1 = An interrupt is generated whenever LBDF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_LBCL  ----------------------------------
// SVD Line: 22315

//  <item> SFDITEM_FIELD__USART1_CR2_LBCL
//    <name> LBCL </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40013804) \nLast bit clock pulse This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in synchronous mode. The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register. This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = The clock pulse of the last data bit is not output to the SCLK pin\n1 : B_0x1 = The clock pulse of the last data bit is output to the SCLK pin </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.8..8> LBCL
//        <0=> 0: B_0x0 = The clock pulse of the last data bit is not output to the SCLK pin
//        <1=> 1: B_0x1 = The clock pulse of the last data bit is output to the SCLK pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_CPHA  ----------------------------------
// SVD Line: 22338

//  <item> SFDITEM_FIELD__USART1_CR2_CPHA
//    <name> CPHA </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40013804) \nClock phase This bit is used to select the phase of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see and ) This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = The first clock transition is the first data capture edge\n1 : B_0x1 = The second clock transition is the first data capture edge </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.9..9> CPHA
//        <0=> 0: B_0x0 = The first clock transition is the first data capture edge
//        <1=> 1: B_0x1 = The second clock transition is the first data capture edge
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_CPOL  ----------------------------------
// SVD Line: 22360

//  <item> SFDITEM_FIELD__USART1_CR2_CPOL
//    <name> CPOL </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40013804) \nClock polarity This bit enables the user to select the polarity of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Steady low value on SCLK pin outside transmission window\n1 : B_0x1 = Steady high value on SCLK pin outside transmission window </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.10..10> CPOL
//        <0=> 0: B_0x0 = Steady low value on SCLK pin outside transmission window
//        <1=> 1: B_0x1 = Steady high value on SCLK pin outside transmission window
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_CLKEN  ----------------------------------
// SVD Line: 22382

//  <item> SFDITEM_FIELD__USART1_CR2_CLKEN
//    <name> CLKEN </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40013804) \nClock enable This bit enables the user to enable the SCLK pin. This bit can only be written when the USART is disabled (UE=0). Note: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to . In Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected: UE = 0 SCEN = 1 GTPR configuration CLKEN= 1 UE = 1\n0 : B_0x0 = SCLK pin disabled\n1 : B_0x1 = SCLK pin enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.11..11> CLKEN
//        <0=> 0: B_0x0 = SCLK pin disabled
//        <1=> 1: B_0x1 = SCLK pin enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_STOP  ----------------------------------
// SVD Line: 22410

//  <item> SFDITEM_FIELD__USART1_CR2_STOP
//    <name> STOP </name>
//    <rw> 
//    <i> [Bits 13..12] RW (@ 0x40013804) \nstop bits These bits are used for programming the stop bits. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = 1 stop bit\n1 : B_0x1 = 0.5 stop bit.\n2 : B_0x2 = 2 stop bits\n3 : B_0x3 = 1.5 stop bits </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.13..12> STOP
//        <0=> 0: B_0x0 = 1 stop bit
//        <1=> 1: B_0x1 = 0.5 stop bit.
//        <2=> 2: B_0x2 = 2 stop bits
//        <3=> 3: B_0x3 = 1.5 stop bits
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_LINEN  ----------------------------------
// SVD Line: 22441

//  <item> SFDITEM_FIELD__USART1_CR2_LINEN
//    <name> LINEN </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40013804) \nLIN mode enable This bit is set and cleared by software. The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = LIN mode disabled\n1 : B_0x1 = LIN mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.14..14> LINEN
//        <0=> 0: B_0x0 = LIN mode disabled
//        <1=> 1: B_0x1 = LIN mode enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_SWAP  ----------------------------------
// SVD Line: 22464

//  <item> SFDITEM_FIELD__USART1_CR2_SWAP
//    <name> SWAP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40013804) \nSwap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = TX/RX pins are used as defined in standard pinout\n1 : B_0x1 = The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.15..15> SWAP
//        <0=> 0: B_0x0 = TX/RX pins are used as defined in standard pinout
//        <1=> 1: B_0x1 = The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_RXINV  ----------------------------------
// SVD Line: 22485

//  <item> SFDITEM_FIELD__USART1_CR2_RXINV
//    <name> RXINV </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40013804) \nRX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = RX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)\n1 : B_0x1 = RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.16..16> RXINV
//        <0=> 0: B_0x0 = RX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)
//        <1=> 1: B_0x1 = RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle).
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_TXINV  ----------------------------------
// SVD Line: 22507

//  <item> SFDITEM_FIELD__USART1_CR2_TXINV
//    <name> TXINV </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40013804) \nTX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)\n1 : B_0x1 = TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.17..17> TXINV
//        <0=> 0: B_0x0 = TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)
//        <1=> 1: B_0x1 = TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR2_DATAINV  ---------------------------------
// SVD Line: 22529

//  <item> SFDITEM_FIELD__USART1_CR2_DATAINV
//    <name> DATAINV </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40013804) \nBinary data inversion This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)\n1 : B_0x1 = Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.18..18> DATAINV
//        <0=> 0: B_0x0 = Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)
//        <1=> 1: B_0x1 = Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR2_MSBFIRST  --------------------------------
// SVD Line: 22550

//  <item> SFDITEM_FIELD__USART1_CR2_MSBFIRST
//    <name> MSBFIRST </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40013804) \nMost significant bit first This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = data is transmitted/received with data bit 0 first, following the start bit.\n1 : B_0x1 = data is transmitted/received with the MSB (bit 7/8) first, following the start bit. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.19..19> MSBFIRST
//        <0=> 0: B_0x0 = data is transmitted/received with data bit 0 first, following the start bit.
//        <1=> 1: B_0x1 = data is transmitted/received with the MSB (bit 7/8) first, following the start bit.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_ABREN  ----------------------------------
// SVD Line: 22571

//  <item> SFDITEM_FIELD__USART1_CR2_ABREN
//    <name> ABREN </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40013804) \nAuto baud rate enable This bit is set and cleared by software. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Auto baud rate detection is disabled.\n1 : B_0x1 = Auto baud rate detection is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.20..20> ABREN
//        <0=> 0: B_0x0 = Auto baud rate detection is disabled.
//        <1=> 1: B_0x1 = Auto baud rate detection is enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_ABRMOD  ---------------------------------
// SVD Line: 22592

//  <item> SFDITEM_FIELD__USART1_CR2_ABRMOD
//    <name> ABRMOD </name>
//    <rw> 
//    <i> [Bits 22..21] RW (@ 0x40013804) \nAuto baud rate mode These bits are set and cleared by software. This bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0). Note: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST) If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Measurement of the start bit is used to detect the baud rate.\n1 : B_0x1 = Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)\n2 : B_0x2 = 0x7F frame detection.\n3 : B_0x3 = 0x55 frame detection </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.22..21> ABRMOD
//        <0=> 0: B_0x0 = Measurement of the start bit is used to detect the baud rate.
//        <1=> 1: B_0x1 = Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)
//        <2=> 2: B_0x2 = 0x7F frame detection.
//        <3=> 3: B_0x3 = 0x55 frame detection
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR2_RTOEN  ----------------------------------
// SVD Line: 22625

//  <item> SFDITEM_FIELD__USART1_CR2_RTOEN
//    <name> RTOEN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40013804) \nReceiver timeout enable This bit is set and cleared by software. When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register). Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Receiver timeout feature disabled.\n1 : B_0x1 = Receiver timeout feature enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR2 ) </loc>
//      <o.23..23> RTOEN
//        <0=> 0: B_0x0 = Receiver timeout feature disabled.
//        <1=> 1: B_0x1 = Receiver timeout feature enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR2_ADD  -----------------------------------
// SVD Line: 22647

//  <item> SFDITEM_FIELD__USART1_CR2_ADD
//    <name> ADD </name>
//    <rw> 
//    <i> [Bits 31..24] RW (@ 0x40013804) Address of the USART node ADD[7:4]: These bits give the address of the USART node or a character code to be recognized. They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or low-power mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0). ADD[3:0]: These bits give the address of the USART node or a character code to be recognized. They are used for wakeup with address mark detection, in multiprocessor communication during Mute mode or low-power mode. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_CR2 >> 24) & 0xFF), ((USART1_CR2 = (USART1_CR2 & ~(0xFFUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_CR2  -----------------------------------
// SVD Line: 22200

//  <rtree> SFDITEM_REG__USART1_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013804) Control register 2 </i>
//    <loc> ( (unsigned int)((USART1_CR2 >> 0) & 0xFFFFFFFF), ((USART1_CR2 = (USART1_CR2 & ~(0xFFFFFF79UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFF79) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_CR2_SLVEN </item>
//    <item> SFDITEM_FIELD__USART1_CR2_DIS_NSS </item>
//    <item> SFDITEM_FIELD__USART1_CR2_ADDM7 </item>
//    <item> SFDITEM_FIELD__USART1_CR2_LBDL </item>
//    <item> SFDITEM_FIELD__USART1_CR2_LBDIE </item>
//    <item> SFDITEM_FIELD__USART1_CR2_LBCL </item>
//    <item> SFDITEM_FIELD__USART1_CR2_CPHA </item>
//    <item> SFDITEM_FIELD__USART1_CR2_CPOL </item>
//    <item> SFDITEM_FIELD__USART1_CR2_CLKEN </item>
//    <item> SFDITEM_FIELD__USART1_CR2_STOP </item>
//    <item> SFDITEM_FIELD__USART1_CR2_LINEN </item>
//    <item> SFDITEM_FIELD__USART1_CR2_SWAP </item>
//    <item> SFDITEM_FIELD__USART1_CR2_RXINV </item>
//    <item> SFDITEM_FIELD__USART1_CR2_TXINV </item>
//    <item> SFDITEM_FIELD__USART1_CR2_DATAINV </item>
//    <item> SFDITEM_FIELD__USART1_CR2_MSBFIRST </item>
//    <item> SFDITEM_FIELD__USART1_CR2_ABREN </item>
//    <item> SFDITEM_FIELD__USART1_CR2_ABRMOD </item>
//    <item> SFDITEM_FIELD__USART1_CR2_RTOEN </item>
//    <item> SFDITEM_FIELD__USART1_CR2_ADD </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_CR3  -------------------------------
// SVD Line: 22664

unsigned int USART1_CR3 __AT (0x40013808);



// -------------------------------  Field Item: USART1_CR3_EIE  -----------------------------------
// SVD Line: 22673

//  <item> SFDITEM_FIELD__USART1_CR3_EIE
//    <name> EIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40013808) \nError interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1 or UDR = 1 in the USART_ISR register).\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.0..0> EIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_IREN  ----------------------------------
// SVD Line: 22693

//  <item> SFDITEM_FIELD__USART1_CR3_IREN
//    <name> IREN </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40013808) \nIrDA mode enable This bit is set and cleared by software. This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = IrDA disabled\n1 : B_0x1 = IrDA enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.1..1> IREN
//        <0=> 0: B_0x0 = IrDA disabled
//        <1=> 1: B_0x1 = IrDA enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_IRLP  ----------------------------------
// SVD Line: 22715

//  <item> SFDITEM_FIELD__USART1_CR3_IRLP
//    <name> IRLP </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40013808) \nIrDA low-power This bit is used for selecting between normal and low-power IrDA modes This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Normal mode\n1 : B_0x1 = Low-power mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.2..2> IRLP
//        <0=> 0: B_0x0 = Normal mode
//        <1=> 1: B_0x1 = Low-power mode
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_HDSEL  ----------------------------------
// SVD Line: 22737

//  <item> SFDITEM_FIELD__USART1_CR3_HDSEL
//    <name> HDSEL </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40013808) \nHalf-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Half duplex mode is not selected\n1 : B_0x1 = Half duplex mode is selected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.3..3> HDSEL
//        <0=> 0: B_0x0 = Half duplex mode is not selected
//        <1=> 1: B_0x1 = Half duplex mode is selected
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_NACK  ----------------------------------
// SVD Line: 22758

//  <item> SFDITEM_FIELD__USART1_CR3_NACK
//    <name> NACK </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40013808) \nSmartcard NACK enable This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = NACK transmission in case of parity error is disabled\n1 : B_0x1 = NACK transmission during parity error is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.4..4> NACK
//        <0=> 0: B_0x0 = NACK transmission in case of parity error is disabled
//        <1=> 1: B_0x1 = NACK transmission during parity error is enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_SCEN  ----------------------------------
// SVD Line: 22779

//  <item> SFDITEM_FIELD__USART1_CR3_SCEN
//    <name> SCEN </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40013808) \nSmartcard mode enable This bit is used for enabling Smartcard mode. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Smartcard Mode disabled\n1 : B_0x1 = Smartcard Mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.5..5> SCEN
//        <0=> 0: B_0x0 = Smartcard Mode disabled
//        <1=> 1: B_0x1 = Smartcard Mode enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_DMAR  ----------------------------------
// SVD Line: 22801

//  <item> SFDITEM_FIELD__USART1_CR3_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40013808) \nDMA enable receiver This bit is set/reset by software\n0 : B_0x0 = DMA mode is disabled for reception\n1 : B_0x1 = DMA mode is enabled for reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.6..6> DMAR
//        <0=> 0: B_0x0 = DMA mode is disabled for reception
//        <1=> 1: B_0x1 = DMA mode is enabled for reception
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_DMAT  ----------------------------------
// SVD Line: 22821

//  <item> SFDITEM_FIELD__USART1_CR3_DMAT
//    <name> DMAT </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40013808) \nDMA enable transmitter This bit is set/reset by software\n0 : B_0x0 = DMA mode is disabled for transmission\n1 : B_0x1 = DMA mode is enabled for transmission </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.7..7> DMAT
//        <0=> 0: B_0x0 = DMA mode is disabled for transmission
//        <1=> 1: B_0x1 = DMA mode is enabled for transmission
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_RTSE  ----------------------------------
// SVD Line: 22841

//  <item> SFDITEM_FIELD__USART1_CR3_RTSE
//    <name> RTSE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40013808) \nRTS enable This bit can only be written when the USART is disabled (UE=0). Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = RTS hardware flow control disabled\n1 : B_0x1 = RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.8..8> RTSE
//        <0=> 0: B_0x0 = RTS hardware flow control disabled
//        <1=> 1: B_0x1 = RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_CTSE  ----------------------------------
// SVD Line: 22862

//  <item> SFDITEM_FIELD__USART1_CR3_CTSE
//    <name> CTSE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40013808) \nCTS enable This bit can only be written when the USART is disabled (UE=0) Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = CTS hardware flow control disabled\n1 : B_0x1 = CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.9..9> CTSE
//        <0=> 0: B_0x0 = CTS hardware flow control disabled
//        <1=> 1: B_0x1 = CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_CTSIE  ----------------------------------
// SVD Line: 22883

//  <item> SFDITEM_FIELD__USART1_CR3_CTSIE
//    <name> CTSIE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40013808) \nCTS interrupt enable Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt is inhibited\n1 : B_0x1 = An interrupt is generated whenever CTSIF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.10..10> CTSIE
//        <0=> 0: B_0x0 = Interrupt is inhibited
//        <1=> 1: B_0x1 = An interrupt is generated whenever CTSIF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_ONEBIT  ---------------------------------
// SVD Line: 22903

//  <item> SFDITEM_FIELD__USART1_CR3_ONEBIT
//    <name> ONEBIT </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40013808) \nOne sample bit method enable This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled. This bit can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Three sample bit method\n1 : B_0x1 = One sample bit method </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.11..11> ONEBIT
//        <0=> 0: B_0x0 = Three sample bit method
//        <1=> 1: B_0x1 = One sample bit method
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_OVRDIS  ---------------------------------
// SVD Line: 22924

//  <item> SFDITEM_FIELD__USART1_CR3_OVRDIS
//    <name> OVRDIS </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40013808) \nOverrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used. This bit can only be written when the USART is disabled (UE=0). Note: This control bit enables checking the communication flow w/o reading the data\n0 : B_0x0 = Overrun Error Flag, ORE, is set when received data is not read before receiving new data.\n1 : B_0x1 = Overrun functionality is disabled. If new data is received while the RXNE flag is still set </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.12..12> OVRDIS
//        <0=> 0: B_0x0 = Overrun Error Flag, ORE, is set when received data is not read before receiving new data.
//        <1=> 1: B_0x1 = Overrun functionality is disabled. If new data is received while the RXNE flag is still set
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_DDRE  ----------------------------------
// SVD Line: 22947

//  <item> SFDITEM_FIELD__USART1_CR3_DDRE
//    <name> DDRE </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40013808) \nDMA Disable on Reception Error This bit can only be written when the USART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.\n0 : B_0x0 = DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode).\n1 : B_0x1 = DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.13..13> DDRE
//        <0=> 0: B_0x0 = DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode).
//        <1=> 1: B_0x1 = DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_DEM  -----------------------------------
// SVD Line: 22968

//  <item> SFDITEM_FIELD__USART1_CR3_DEM
//    <name> DEM </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40013808) \nDriver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = DE function is disabled.\n1 : B_0x1 = DE function is enabled. The DE signal is output on the RTS pin. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.14..14> DEM
//        <0=> 0: B_0x0 = DE function is disabled.
//        <1=> 1: B_0x1 = DE function is enabled. The DE signal is output on the RTS pin.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_DEP  -----------------------------------
// SVD Line: 22990

//  <item> SFDITEM_FIELD__USART1_CR3_DEP
//    <name> DEP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40013808) \nDriver enable polarity selection This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = DE signal is active high.\n1 : B_0x1 = DE signal is active low. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.15..15> DEP
//        <0=> 0: B_0x0 = DE signal is active high.
//        <1=> 1: B_0x1 = DE signal is active low.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR3_SCARCNT  ---------------------------------
// SVD Line: 23011

//  <item> SFDITEM_FIELD__USART1_CR3_SCARCNT
//    <name> SCARCNT </name>
//    <rw> 
//    <i> [Bits 19..17] RW (@ 0x40013808) \nSmartcard auto-retry count This bitfield specifies the number of retries for transmission and reception in Smartcard mode. In transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set). In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set). This bitfield must be programmed only when the USART is disabled (UE=0). When the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission. Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = retransmission disabled - No automatic retransmission in transmit mode.\n1 : B_0x1 = number of automatic retransmission attempts (before signaling error)\n2 : B_0x2 = number of automatic retransmission attempts (before signaling error)\n3 : B_0x3 = number of automatic retransmission attempts (before signaling error)\n4 : B_0x4 = number of automatic retransmission attempts (before signaling error)\n5 : B_0x5 = number of automatic retransmission attempts (before signaling error)\n6 : B_0x6 = number of automatic retransmission attempts (before signaling error)\n7 : B_0x7 = number of automatic retransmission attempts (before signaling error) </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.19..17> SCARCNT
//        <0=> 0: B_0x0 = retransmission disabled - No automatic retransmission in transmit mode.
//        <1=> 1: B_0x1 = number of automatic retransmission attempts (before signaling error)
//        <2=> 2: B_0x2 = number of automatic retransmission attempts (before signaling error)
//        <3=> 3: B_0x3 = number of automatic retransmission attempts (before signaling error)
//        <4=> 4: B_0x4 = number of automatic retransmission attempts (before signaling error)
//        <5=> 5: B_0x5 = number of automatic retransmission attempts (before signaling error)
//        <6=> 6: B_0x6 = number of automatic retransmission attempts (before signaling error)
//        <7=> 7: B_0x7 = number of automatic retransmission attempts (before signaling error)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART1_CR3_WUS  -----------------------------------
// SVD Line: 23066

//  <item> SFDITEM_FIELD__USART1_CR3_WUS
//    <name> WUS </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40013808) \nWakeup from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag). This bitfield can only be written when the USART is disabled (UE=0). If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835.\n0 : B_0x0 = WUF active on address match (as defined by ADD[7:0] and ADDM7)\n1 : Reserved - do not use\n2 : B_0x2 = WUF active on start bit detection\n3 : B_0x3 = WUF active on RXNE/RXFNE. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.21..20> WUS
//        <0=> 0: B_0x0 = WUF active on address match (as defined by ADD[7:0] and ADDM7)
//        <1=> 1: 
//        <2=> 2: B_0x2 = WUF active on start bit detection
//        <3=> 3: B_0x3 = WUF active on RXNE/RXFNE.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_WUFIE  ----------------------------------
// SVD Line: 23093

//  <item> SFDITEM_FIELD__USART1_CR3_WUFIE
//    <name> WUFIE </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40013808) \nWakeup from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever WUF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.22..22> WUFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever WUF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_TXFTIE  ---------------------------------
// SVD Line: 23115

//  <item> SFDITEM_FIELD__USART1_CR3_TXFTIE
//    <name> TXFTIE </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40013808) \nTXFIFO threshold interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.23..23> TXFTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR3_TCBGTIE  ---------------------------------
// SVD Line: 23135

//  <item> SFDITEM_FIELD__USART1_CR3_TCBGTIE
//    <name> TCBGTIE </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40013808) \nTransmission Complete before guard time, interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TCBGT=1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.24..24> TCBGTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TCBGT=1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR3_RXFTCFG  ---------------------------------
// SVD Line: 23156

//  <item> SFDITEM_FIELD__USART1_CR3_RXFTCFG
//    <name> RXFTCFG </name>
//    <rw> 
//    <i> [Bits 27..25] RW (@ 0x40013808) \nReceive FIFO threshold configuration Remaining combinations: Reserved\n0 : B_0x0 = Receive FIFO reaches 1/8 of its depth\n1 : B_0x1 = Receive FIFO reaches 1/4 of its depth\n2 : B_0x2 = Receive FIFO reaches 1/2 of its depth\n3 : B_0x3 = Receive FIFO reaches 3/4 of its depth\n4 : B_0x4 = Receive FIFO reaches 7/8 of its depth\n5 : B_0x5 = Receive FIFO becomes full\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.27..25> RXFTCFG
//        <0=> 0: B_0x0 = Receive FIFO reaches 1/8 of its depth
//        <1=> 1: B_0x1 = Receive FIFO reaches 1/4 of its depth
//        <2=> 2: B_0x2 = Receive FIFO reaches 1/2 of its depth
//        <3=> 3: B_0x3 = Receive FIFO reaches 3/4 of its depth
//        <4=> 4: B_0x4 = Receive FIFO reaches 7/8 of its depth
//        <5=> 5: B_0x5 = Receive FIFO becomes full
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART1_CR3_RXFTIE  ---------------------------------
// SVD Line: 23196

//  <item> SFDITEM_FIELD__USART1_CR3_RXFTIE
//    <name> RXFTIE </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40013808) \nRXFIFO threshold interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.28..28> RXFTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART1_CR3_TXFTCFG  ---------------------------------
// SVD Line: 23216

//  <item> SFDITEM_FIELD__USART1_CR3_TXFTCFG
//    <name> TXFTCFG </name>
//    <rw> 
//    <i> [Bits 31..29] RW (@ 0x40013808) \nTXFIFO threshold configuration Remaining combinations: Reserved\n0 : B_0x0 = TXFIFO reaches 1/8 of its depth\n1 : B_0x1 = TXFIFO reaches 1/4 of its depth\n2 : B_0x2 = TXFIFO reaches 1/2 of its depth\n3 : B_0x3 = TXFIFO reaches 3/4 of its depth\n4 : B_0x4 = TXFIFO reaches 7/8 of its depth\n5 : B_0x5 = TXFIFO becomes empty\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_CR3 ) </loc>
//      <o.31..29> TXFTCFG
//        <0=> 0: B_0x0 = TXFIFO reaches 1/8 of its depth
//        <1=> 1: B_0x1 = TXFIFO reaches 1/4 of its depth
//        <2=> 2: B_0x2 = TXFIFO reaches 1/2 of its depth
//        <3=> 3: B_0x3 = TXFIFO reaches 3/4 of its depth
//        <4=> 4: B_0x4 = TXFIFO reaches 7/8 of its depth
//        <5=> 5: B_0x5 = TXFIFO becomes empty
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: USART1_CR3  -----------------------------------
// SVD Line: 22664

//  <rtree> SFDITEM_REG__USART1_CR3
//    <name> CR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013808) Control register 3 </i>
//    <loc> ( (unsigned int)((USART1_CR3 >> 0) & 0xFFFFFFFF), ((USART1_CR3 = (USART1_CR3 & ~(0xFFFEFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFEFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_CR3_EIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_IREN </item>
//    <item> SFDITEM_FIELD__USART1_CR3_IRLP </item>
//    <item> SFDITEM_FIELD__USART1_CR3_HDSEL </item>
//    <item> SFDITEM_FIELD__USART1_CR3_NACK </item>
//    <item> SFDITEM_FIELD__USART1_CR3_SCEN </item>
//    <item> SFDITEM_FIELD__USART1_CR3_DMAR </item>
//    <item> SFDITEM_FIELD__USART1_CR3_DMAT </item>
//    <item> SFDITEM_FIELD__USART1_CR3_RTSE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_CTSE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_CTSIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_ONEBIT </item>
//    <item> SFDITEM_FIELD__USART1_CR3_OVRDIS </item>
//    <item> SFDITEM_FIELD__USART1_CR3_DDRE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_DEM </item>
//    <item> SFDITEM_FIELD__USART1_CR3_DEP </item>
//    <item> SFDITEM_FIELD__USART1_CR3_SCARCNT </item>
//    <item> SFDITEM_FIELD__USART1_CR3_WUS </item>
//    <item> SFDITEM_FIELD__USART1_CR3_WUFIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_TXFTIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_TCBGTIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_RXFTCFG </item>
//    <item> SFDITEM_FIELD__USART1_CR3_RXFTIE </item>
//    <item> SFDITEM_FIELD__USART1_CR3_TXFTCFG </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_BRR  -------------------------------
// SVD Line: 23258

unsigned int USART1_BRR __AT (0x4001380C);



// -------------------------------  Field Item: USART1_BRR_BRR  -----------------------------------
// SVD Line: 23267

//  <item> SFDITEM_FIELD__USART1_BRR_BRR
//    <name> BRR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4001380C) USART baud rate </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART1_BRR >> 0) & 0xFFFF), ((USART1_BRR = (USART1_BRR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_BRR  -----------------------------------
// SVD Line: 23258

//  <rtree> SFDITEM_REG__USART1_BRR
//    <name> BRR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001380C) Baud rate register </i>
//    <loc> ( (unsigned int)((USART1_BRR >> 0) & 0xFFFFFFFF), ((USART1_BRR = (USART1_BRR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_BRR_BRR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART1_GTPR  -------------------------------
// SVD Line: 23276

unsigned int USART1_GTPR __AT (0x40013810);



// -------------------------------  Field Item: USART1_GTPR_PSC  ----------------------------------
// SVD Line: 23286

//  <item> SFDITEM_FIELD__USART1_GTPR_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40013810) Prescaler value In IrDA low-power and normal IrDA mode: PSC[7:0] = IrDA Normal and Low-Power baud rate PSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits): In Smartcard mode: PSC[4:0]=Prescaler value PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency: ... 00100000: Divides the source clock by 32 (IrDA mode) ... 11111111: Divides the source clock by 255 (IrDA mode) This bitfield can only be written when the USART is disabled (UE=0). Note: Bits [7:5] must be kept cleared if Smartcard mode is used. This bitfield is reserved and forced by hardware to '0 when the Smartcard and IrDA modes are not supported. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_GTPR >> 0) & 0xFF), ((USART1_GTPR = (USART1_GTPR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: USART1_GTPR_GT  -----------------------------------
// SVD Line: 23333

//  <item> SFDITEM_FIELD__USART1_GTPR_GT
//    <name> GT </name>
//    <rw> 
//    <i> [Bits 15..8] RW (@ 0x40013810) Guard time value This bitfield is used to program the Guard time value in terms of number of baud clock periods. This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value. This bitfield can only be written when the USART is disabled (UE=0). Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_GTPR >> 8) & 0xFF), ((USART1_GTPR = (USART1_GTPR & ~(0xFFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_GTPR  ----------------------------------
// SVD Line: 23276

//  <rtree> SFDITEM_REG__USART1_GTPR
//    <name> GTPR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013810) Guard time and prescaler  register </i>
//    <loc> ( (unsigned int)((USART1_GTPR >> 0) & 0xFFFFFFFF), ((USART1_GTPR = (USART1_GTPR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_GTPR_PSC </item>
//    <item> SFDITEM_FIELD__USART1_GTPR_GT </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART1_RTOR  -------------------------------
// SVD Line: 23346

unsigned int USART1_RTOR __AT (0x40013814);



// -------------------------------  Field Item: USART1_RTOR_RTO  ----------------------------------
// SVD Line: 23355

//  <item> SFDITEM_FIELD__USART1_RTOR_RTO
//    <name> RTO </name>
//    <rw> 
//    <i> [Bits 23..0] RW (@ 0x40013814) Receiver timeout value </i>
//    <edit> 
//      <loc> ( (unsigned int)((USART1_RTOR >> 0) & 0xFFFFFF), ((USART1_RTOR = (USART1_RTOR & ~(0xFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: USART1_RTOR_BLEN  ----------------------------------
// SVD Line: 23361

//  <item> SFDITEM_FIELD__USART1_RTOR_BLEN
//    <name> BLEN </name>
//    <rw> 
//    <i> [Bits 31..24] RW (@ 0x40013814) Block Length </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART1_RTOR >> 24) & 0xFF), ((USART1_RTOR = (USART1_RTOR & ~(0xFFUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_RTOR  ----------------------------------
// SVD Line: 23346

//  <rtree> SFDITEM_REG__USART1_RTOR
//    <name> RTOR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013814) Receiver timeout register </i>
//    <loc> ( (unsigned int)((USART1_RTOR >> 0) & 0xFFFFFFFF), ((USART1_RTOR = (USART1_RTOR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_RTOR_RTO </item>
//    <item> SFDITEM_FIELD__USART1_RTOR_BLEN </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_RQR  -------------------------------
// SVD Line: 23369

unsigned int USART1_RQR __AT (0x40013818);



// ------------------------------  Field Item: USART1_RQR_ABRRQ  ----------------------------------
// SVD Line: 23378

//  <item> SFDITEM_FIELD__USART1_RQR_ABRRQ
//    <name> ABRRQ </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40013818) Auto baud rate request Writing 1 to this bit resets the ABRF flag in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_RQR ) </loc>
//      <o.0..0> ABRRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_RQR_SBKRQ  ----------------------------------
// SVD Line: 23387

//  <item> SFDITEM_FIELD__USART1_RQR_SBKRQ
//    <name> SBKRQ </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40013818) Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_RQR ) </loc>
//      <o.1..1> SBKRQ
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_RQR_MMRQ  ----------------------------------
// SVD Line: 23396

//  <item> SFDITEM_FIELD__USART1_RQR_MMRQ
//    <name> MMRQ </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40013818) Mute mode request Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_RQR ) </loc>
//      <o.2..2> MMRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_RQR_RXFRQ  ----------------------------------
// SVD Line: 23404

//  <item> SFDITEM_FIELD__USART1_RQR_RXFRQ
//    <name> RXFRQ </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40013818) Receive data flush request Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE. This enables to discard the received data without reading them, and avoid an overrun condition. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_RQR ) </loc>
//      <o.3..3> RXFRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_RQR_TXFRQ  ----------------------------------
// SVD Line: 23413

//  <item> SFDITEM_FIELD__USART1_RQR_TXFRQ
//    <name> TXFRQ </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40013818) Transmit data flush request When FIFO mode is disabled, writing '1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_RQR ) </loc>
//      <o.4..4> TXFRQ
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: USART1_RQR  -----------------------------------
// SVD Line: 23369

//  <rtree> SFDITEM_REG__USART1_RQR
//    <name> RQR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40013818) Request register </i>
//    <loc> ( (unsigned int)((USART1_RQR >> 0) & 0xFFFFFFFF), ((USART1_RQR = (USART1_RQR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_RQR_ABRRQ </item>
//    <item> SFDITEM_FIELD__USART1_RQR_SBKRQ </item>
//    <item> SFDITEM_FIELD__USART1_RQR_MMRQ </item>
//    <item> SFDITEM_FIELD__USART1_RQR_RXFRQ </item>
//    <item> SFDITEM_FIELD__USART1_RQR_TXFRQ </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART1_ISR_FIFO_ENABLED  -------------------------
// SVD Line: 23425

unsigned int USART1_ISR_FIFO_ENABLED __AT (0x4001381C);



// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_PE  -----------------------------
// SVD Line: 23435

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_PE
//    <name> PE </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x4001381C) \nParity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No parity error\n1 : B_0x1 = Parity error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = No parity error
//        <1=> 1: B_0x1 = Parity error
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_FE  -----------------------------
// SVD Line: 23457

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_FE
//    <name> FE </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x4001381C) \nFraming error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE=1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No Framing error is detected\n1 : B_0x1 = Framing error or break character is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.1..1> FE
//        <0=> 0: B_0x0 = No Framing error is detected
//        <1=> 1: B_0x1 = Framing error or break character is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_NE  -----------------------------
// SVD Line: 23480

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_NE
//    <name> NE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x4001381C) \nNoise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page861). This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No noise is detected\n1 : B_0x1 = Noise is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.2..2> NE
//        <0=> 0: B_0x0 = No noise is detected
//        <1=> 1: B_0x1 = Noise is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_ORE  ----------------------------
// SVD Line: 23503

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ORE
//    <name> ORE </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x4001381C) \nOverrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.\n0 : B_0x0 = No overrun error\n1 : B_0x1 = Overrun error is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.3..3> ORE
//        <0=> 0: B_0x0 = No overrun error
//        <1=> 1: B_0x1 = Overrun error is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_IDLE  ----------------------------
// SVD Line: 23527

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_IDLE
//    <name> IDLE </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x4001381C) \nIdle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n0 : B_0x0 = No Idle line is detected\n1 : B_0x1 = Idle line is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.4..4> IDLE
//        <0=> 0: B_0x0 = No Idle line is detected
//        <1=> 1: B_0x1 = Idle line is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_RXFNE  ---------------------------
// SVD Line: 23549

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFNE
//    <name> RXFNE </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x4001381C) \nRXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXFNEIE=1 in the USART_CR1 register.\n0 : B_0x0 = Data is not received\n1 : B_0x1 = Received data is ready to be read. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.5..5> RXFNE
//        <0=> 0: B_0x0 = Data is not received
//        <1=> 1: B_0x1 = Received data is ready to be read.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TC  -----------------------------
// SVD Line: 23571

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x4001381C) \nTransmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.\n0 : B_0x0 = Transmission is not complete\n1 : B_0x1 = Transmission is complete </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.6..6> TC
//        <0=> 0: B_0x0 = Transmission is not complete
//        <1=> 1: B_0x1 = Transmission is complete
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TXFNF  ---------------------------
// SVD Line: 23595

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFNF
//    <name> TXFNF </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x4001381C) \nTXFIFO not full TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). This bit is used during single buffer transmission.\n0 : B_0x0 = Transmit FIFO is full\n1 : B_0x1 = Transmit FIFO is not full </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.7..7> TXFNF
//        <0=> 0: B_0x0 = Transmit FIFO is full
//        <1=> 1: B_0x1 = Transmit FIFO is not full
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_LBDF  ----------------------------
// SVD Line: 23618

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_LBDF
//    <name> LBDF </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x4001381C) \nLIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = LIN Break not detected\n1 : B_0x1 = LIN break detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.8..8> LBDF
//        <0=> 0: B_0x0 = LIN Break not detected
//        <1=> 1: B_0x1 = LIN break detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_CTSIF  ---------------------------
// SVD Line: 23640

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CTSIF
//    <name> CTSIF </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x4001381C) \nCTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE=1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = No change occurred on the nCTS status line\n1 : B_0x1 = A change occurred on the nCTS status line </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.9..9> CTSIF
//        <0=> 0: B_0x0 = No change occurred on the nCTS status line
//        <1=> 1: B_0x1 = A change occurred on the nCTS status line
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_CTS  ----------------------------
// SVD Line: 23662

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CTS
//    <name> CTS </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x4001381C) \nCTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = nCTS line set\n1 : B_0x1 = nCTS line reset </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.10..10> CTS
//        <0=> 0: B_0x0 = nCTS line set
//        <1=> 1: B_0x1 = nCTS line reset
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_RTOF  ----------------------------
// SVD Line: 23683

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RTOF
//    <name> RTOF </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x4001381C) \nReceiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE=1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.\n0 : B_0x0 = Timeout value not reached\n1 : B_0x1 = Timeout value reached without any data reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.11..11> RTOF
//        <0=> 0: B_0x0 = Timeout value not reached
//        <1=> 1: B_0x1 = Timeout value reached without any data reception
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_EOBF  ----------------------------
// SVD Line: 23708

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_EOBF
//    <name> EOBF </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x4001381C) \nEnd of block flag This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE=1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = End of Block not reached\n1 : B_0x1 = End of Block (number of characters) reached </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.12..12> EOBF
//        <0=> 0: B_0x0 = End of Block not reached
//        <1=> 1: B_0x1 = End of Block (number of characters) reached
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_UDR  ----------------------------
// SVD Line: 23731

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_UDR
//    <name> UDR </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x4001381C) \nSPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = No underrun error\n1 : B_0x1 = underrun error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.13..13> UDR
//        <0=> 0: B_0x0 = No underrun error
//        <1=> 1: B_0x1 = underrun error
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_ABRE  ----------------------------
// SVD Line: 23752

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ABRE
//    <name> ABRE </name>
//    <r> 
//    <i> [Bit 14] RO (@ 0x4001381C) Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.14..14> ABRE
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_ABRF  ----------------------------
// SVD Line: 23762

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ABRF
//    <name> ABRF </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x4001381C) Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.15..15> ABRF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_BUSY  ----------------------------
// SVD Line: 23772

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x4001381C) \nBusy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).\n0 : B_0x0 = USART is idle (no reception)\n1 : B_0x1 = Reception on going </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.16..16> BUSY
//        <0=> 0: B_0x0 = USART is idle (no reception)
//        <1=> 1: B_0x1 = Reception on going
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_CMF  ----------------------------
// SVD Line: 23792

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CMF
//    <name> CMF </name>
//    <r> 
//    <i> [Bit 17] RO (@ 0x4001381C) \nCharacter match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIE=1in the USART_CR1 register.\n0 : B_0x0 = No Character match detected\n1 : B_0x1 = Character Match detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.17..17> CMF
//        <0=> 0: B_0x0 = No Character match detected
//        <1=> 1: B_0x1 = Character Match detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_SBKF  ----------------------------
// SVD Line: 23813

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_SBKF
//    <name> SBKF </name>
//    <r> 
//    <i> [Bit 18] RO (@ 0x4001381C) \nSend break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.\n0 : B_0x0 = Break character transmitted\n1 : B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.18..18> SBKF
//        <0=> 0: B_0x0 = Break character transmitted
//        <1=> 1: B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_RWU  ----------------------------
// SVD Line: 23833

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RWU
//    <name> RWU </name>
//    <r> 
//    <i> [Bit 19] RO (@ 0x4001381C) \nReceiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = Receiver in active mode\n1 : B_0x1 = Receiver in Mute mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.19..19> RWU
//        <0=> 0: B_0x0 = Receiver in active mode
//        <1=> 1: B_0x1 = Receiver in Mute mode
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_ENABLED_WUF  ----------------------------
// SVD Line: 23855

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_WUF
//    <name> WUF </name>
//    <r> 
//    <i> [Bit 20] RO (@ 0x4001381C) Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE=1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.20..20> WUF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TEACK  ---------------------------
// SVD Line: 23866

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TEACK
//    <name> TEACK </name>
//    <r> 
//    <i> [Bit 21] RO (@ 0x4001381C) Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.21..21> TEACK
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_REACK  ---------------------------
// SVD Line: 23875

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_REACK
//    <name> REACK </name>
//    <r> 
//    <i> [Bit 22] RO (@ 0x4001381C) Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.22..22> REACK
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TXFE  ----------------------------
// SVD Line: 23885

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFE
//    <name> TXFE </name>
//    <r> 
//    <i> [Bit 23] RO (@ 0x4001381C) \nTXFIFO empty This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. An interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.\n0 : B_0x0 = TXFIFO not empty.\n1 : B_0x1 = TXFIFO empty. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.23..23> TXFE
//        <0=> 0: B_0x0 = TXFIFO not empty.
//        <1=> 1: B_0x1 = TXFIFO empty.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_RXFF  ----------------------------
// SVD Line: 23906

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFF
//    <name> RXFF </name>
//    <r> 
//    <i> [Bit 24] RO (@ 0x4001381C) \nRXFIFO full This bit is set by hardware when the number of received data corresponds to RXFIFOsize+1 (RXFIFO full + 1 data in the USART_RDR register. An interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.\n0 : B_0x0 = RXFIFO not full.\n1 : B_0x1 = RXFIFO Full. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.24..24> RXFF
//        <0=> 0: B_0x0 = RXFIFO not full.
//        <1=> 1: B_0x1 = RXFIFO Full.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TCBGT  ---------------------------
// SVD Line: 23927

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TCBGT
//    <name> TCBGT </name>
//    <r> 
//    <i> [Bit 25] RO (@ 0x4001381C) \nTransmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1. Refer to on page835.\n0 : B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)\n1 : B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.25..25> TCBGT
//        <0=> 0: B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)
//        <1=> 1: B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_RXFT  ----------------------------
// SVD Line: 23950

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFT
//    <name> RXFT </name>
//    <r> 
//    <i> [Bit 26] RO (@ 0x4001381C) \nRXFIFO threshold flag This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register. Note: When the RXFTCFG threshold is configured to '101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.\n0 : B_0x0 = Receive FIFO does not reach the programmed threshold.\n1 : B_0x1 = Receive FIFO reached the programmed threshold. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.26..26> RXFT
//        <0=> 0: B_0x0 = Receive FIFO does not reach the programmed threshold.
//        <1=> 1: B_0x1 = Receive FIFO reached the programmed threshold.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_ENABLED_TXFT  ----------------------------
// SVD Line: 23971

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFT
//    <name> TXFT </name>
//    <r> 
//    <i> [Bit 27] RO (@ 0x4001381C) \nTXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.\n0 : B_0x0 = TXFIFO does not reach the programmed threshold.\n1 : B_0x1 = TXFIFO reached the programmed threshold. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_ENABLED ) </loc>
//      <o.27..27> TXFT
//        <0=> 0: B_0x0 = TXFIFO does not reach the programmed threshold.
//        <1=> 1: B_0x1 = TXFIFO reached the programmed threshold.
//    </combo>
//  </item>
//  


// -------------------------  Register RTree: USART1_ISR_FIFO_ENABLED  ----------------------------
// SVD Line: 23425

//  <rtree> SFDITEM_REG__USART1_ISR_FIFO_ENABLED
//    <name> ISR_FIFO_ENABLED </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4001381C) Interrupt & status  register </i>
//    <loc> ( (unsigned int)((USART1_ISR_FIFO_ENABLED >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_PE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_FE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_NE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ORE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_IDLE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFNE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TC </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFNF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_LBDF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CTSIF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CTS </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RTOF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_EOBF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_UDR </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ABRE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_ABRF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_BUSY </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_CMF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_SBKF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RWU </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_WUF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TEACK </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_REACK </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TCBGT </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_RXFT </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_ENABLED_TXFT </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART1_ISR_FIFO_DISABLED  ------------------------
// SVD Line: 23993

unsigned int USART1_ISR_FIFO_DISABLED __AT (0x4001381C);



// -------------------------  Field Item: USART1_ISR_FIFO_DISABLED_PE  ----------------------------
// SVD Line: 24004

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_PE
//    <name> PE </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x4001381C) \nParity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0 : B_0x0 = No parity error\n1 : B_0x1 = Parity error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = No parity error
//        <1=> 1: B_0x1 = Parity error
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_DISABLED_FE  ----------------------------
// SVD Line: 24025

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_FE
//    <name> FE </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x4001381C) \nFraming error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE=1 in the USART_CR1 register.\n0 : B_0x0 = No Framing error is detected\n1 : B_0x1 = Framing error or break character is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.1..1> FE
//        <0=> 0: B_0x0 = No Framing error is detected
//        <1=> 1: B_0x1 = Framing error or break character is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_DISABLED_NE  ----------------------------
// SVD Line: 24047

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_NE
//    <name> NE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x4001381C) \nNoise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page861).\n0 : B_0x0 = No noise is detected\n1 : B_0x1 = Noise is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.2..2> NE
//        <0=> 0: B_0x0 = No noise is detected
//        <1=> 1: B_0x1 = Noise is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_ORE  ----------------------------
// SVD Line: 24069

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ORE
//    <name> ORE </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x4001381C) \nOverrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXNEIE=1 or EIE = 1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.\n0 : B_0x0 = No overrun error\n1 : B_0x1 = Overrun error is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.3..3> ORE
//        <0=> 0: B_0x0 = No overrun error
//        <1=> 1: B_0x1 = Overrun error is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_IDLE  ---------------------------
// SVD Line: 24093

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_IDLE
//    <name> IDLE </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x4001381C) \nIdle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n0 : B_0x0 = No Idle line is detected\n1 : B_0x1 = Idle line is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.4..4> IDLE
//        <0=> 0: B_0x0 = No Idle line is detected
//        <1=> 1: B_0x1 = Idle line is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_RXNE  ---------------------------
// SVD Line: 24115

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RXNE
//    <name> RXNE </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x4001381C) \nRead data register not empty RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXNEIE=1 in the USART_CR1 register.\n0 : B_0x0 = Data is not received\n1 : B_0x1 = Received data is ready to be read. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.5..5> RXNE
//        <0=> 0: B_0x0 = Data is not received
//        <1=> 1: B_0x1 = Received data is ready to be read.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART1_ISR_FIFO_DISABLED_TC  ----------------------------
// SVD Line: 24136

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x4001381C) \nTransmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.\n0 : B_0x0 = Transmission is not complete\n1 : B_0x1 = Transmission is complete </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.6..6> TC
//        <0=> 0: B_0x0 = Transmission is not complete
//        <1=> 1: B_0x1 = Transmission is complete
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_TXE  ----------------------------
// SVD Line: 24160

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TXE
//    <name> TXE </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x4001381C) \nTransmit data register empty TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T=0 mode, in case of transmission failure). An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.\n0 : B_0x0 = Data register full\n1 : B_0x1 = Data register not full </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.7..7> TXE
//        <0=> 0: B_0x0 = Data register full
//        <1=> 1: B_0x1 = Data register not full
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_LBDF  ---------------------------
// SVD Line: 24181

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_LBDF
//    <name> LBDF </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x4001381C) \nLIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = LIN Break not detected\n1 : B_0x1 = LIN break detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.8..8> LBDF
//        <0=> 0: B_0x0 = LIN Break not detected
//        <1=> 1: B_0x1 = LIN break detected
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART1_ISR_FIFO_DISABLED_CTSIF  ---------------------------
// SVD Line: 24203

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CTSIF
//    <name> CTSIF </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x4001381C) \nCTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE=1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = No change occurred on the nCTS status line\n1 : B_0x1 = A change occurred on the nCTS status line </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.9..9> CTSIF
//        <0=> 0: B_0x0 = No change occurred on the nCTS status line
//        <1=> 1: B_0x1 = A change occurred on the nCTS status line
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_CTS  ----------------------------
// SVD Line: 24225

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CTS
//    <name> CTS </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x4001381C) \nCTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = nCTS line set\n1 : B_0x1 = nCTS line reset </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.10..10> CTS
//        <0=> 0: B_0x0 = nCTS line set
//        <1=> 1: B_0x1 = nCTS line reset
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_RTOF  ---------------------------
// SVD Line: 24246

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RTOF
//    <name> RTOF </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x4001381C) \nReceiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE=1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.\n0 : B_0x0 = Timeout value not reached\n1 : B_0x1 = Timeout value reached without any data reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.11..11> RTOF
//        <0=> 0: B_0x0 = Timeout value not reached
//        <1=> 1: B_0x1 = Timeout value reached without any data reception
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_EOBF  ---------------------------
// SVD Line: 24271

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_EOBF
//    <name> EOBF </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x4001381C) \nEnd of block flag This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE=1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = End of Block not reached\n1 : B_0x1 = End of Block (number of characters) reached </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.12..12> EOBF
//        <0=> 0: B_0x0 = End of Block not reached
//        <1=> 1: B_0x1 = End of Block (number of characters) reached
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_UDR  ----------------------------
// SVD Line: 24294

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_UDR
//    <name> UDR </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x4001381C) \nSPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = No underrun error\n1 : B_0x1 = underrun error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.13..13> UDR
//        <0=> 0: B_0x0 = No underrun error
//        <1=> 1: B_0x1 = underrun error
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_ABRE  ---------------------------
// SVD Line: 24315

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ABRE
//    <name> ABRE </name>
//    <r> 
//    <i> [Bit 14] RO (@ 0x4001381C) Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.14..14> ABRE
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_ABRF  ---------------------------
// SVD Line: 24325

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ABRF
//    <name> ABRF </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x4001381C) Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.15..15> ABRF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_BUSY  ---------------------------
// SVD Line: 24335

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x4001381C) \nBusy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).\n0 : B_0x0 = USART is idle (no reception)\n1 : B_0x1 = Reception on going </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.16..16> BUSY
//        <0=> 0: B_0x0 = USART is idle (no reception)
//        <1=> 1: B_0x1 = Reception on going
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_CMF  ----------------------------
// SVD Line: 24355

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CMF
//    <name> CMF </name>
//    <r> 
//    <i> [Bit 17] RO (@ 0x4001381C) \nCharacter match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIE=1in the USART_CR1 register.\n0 : B_0x0 = No Character match detected\n1 : B_0x1 = Character Match detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.17..17> CMF
//        <0=> 0: B_0x0 = No Character match detected
//        <1=> 1: B_0x1 = Character Match detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_SBKF  ---------------------------
// SVD Line: 24376

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_SBKF
//    <name> SBKF </name>
//    <r> 
//    <i> [Bit 18] RO (@ 0x4001381C) \nSend break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.\n0 : B_0x0 = Break character transmitted\n1 : B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.18..18> SBKF
//        <0=> 0: B_0x0 = Break character transmitted
//        <1=> 1: B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_RWU  ----------------------------
// SVD Line: 24396

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RWU
//    <name> RWU </name>
//    <r> 
//    <i> [Bit 19] RO (@ 0x4001381C) \nReceiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = Receiver in active mode\n1 : B_0x1 = Receiver in Mute mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.19..19> RWU
//        <0=> 0: B_0x0 = Receiver in active mode
//        <1=> 1: B_0x1 = Receiver in Mute mode
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART1_ISR_FIFO_DISABLED_WUF  ----------------------------
// SVD Line: 24418

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_WUF
//    <name> WUF </name>
//    <r> 
//    <i> [Bit 20] RO (@ 0x4001381C) Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE=1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.20..20> WUF
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART1_ISR_FIFO_DISABLED_TEACK  ---------------------------
// SVD Line: 24429

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TEACK
//    <name> TEACK </name>
//    <r> 
//    <i> [Bit 21] RO (@ 0x4001381C) Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.21..21> TEACK
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART1_ISR_FIFO_DISABLED_REACK  ---------------------------
// SVD Line: 24438

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_REACK
//    <name> REACK </name>
//    <r> 
//    <i> [Bit 22] RO (@ 0x4001381C) Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.22..22> REACK
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART1_ISR_FIFO_DISABLED_TCBGT  ---------------------------
// SVD Line: 24448

//  <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TCBGT
//    <name> TCBGT </name>
//    <r> 
//    <i> [Bit 25] RO (@ 0x4001381C) \nTransmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1. Refer to on page835.\n0 : B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)\n1 : B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_ISR_FIFO_DISABLED ) </loc>
//      <o.25..25> TCBGT
//        <0=> 0: B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)
//        <1=> 1: B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).
//    </combo>
//  </item>
//  


// ------------------------  Register RTree: USART1_ISR_FIFO_DISABLED  ----------------------------
// SVD Line: 23993

//  <rtree> SFDITEM_REG__USART1_ISR_FIFO_DISABLED
//    <name> ISR_FIFO_DISABLED </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4001381C) Interrupt & status  register </i>
//    <loc> ( (unsigned int)((USART1_ISR_FIFO_DISABLED >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_PE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_FE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_NE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ORE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_IDLE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RXNE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TC </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TXE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_LBDF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CTSIF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CTS </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RTOF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_EOBF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_UDR </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ABRE </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_ABRF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_BUSY </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_CMF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_SBKF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_RWU </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_WUF </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TEACK </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_REACK </item>
//    <item> SFDITEM_FIELD__USART1_ISR_FIFO_DISABLED_TCBGT </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_ICR  -------------------------------
// SVD Line: 24473

unsigned int USART1_ICR __AT (0x40013820);



// -------------------------------  Field Item: USART1_ICR_PECF  ----------------------------------
// SVD Line: 24482

//  <item> SFDITEM_FIELD__USART1_ICR_PECF
//    <name> PECF </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40013820) Parity error clear flag Writing 1 to this bit clears the PE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.0..0> PECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_ICR_FECF  ----------------------------------
// SVD Line: 24490

//  <item> SFDITEM_FIELD__USART1_ICR_FECF
//    <name> FECF </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40013820) Framing error clear flag Writing 1 to this bit clears the FE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.1..1> FECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_ICR_NECF  ----------------------------------
// SVD Line: 24498

//  <item> SFDITEM_FIELD__USART1_ICR_NECF
//    <name> NECF </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40013820) Noise detected clear flag Writing 1 to this bit clears the NE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.2..2> NECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_ORECF  ----------------------------------
// SVD Line: 24506

//  <item> SFDITEM_FIELD__USART1_ICR_ORECF
//    <name> ORECF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40013820) Overrun error clear flag Writing 1 to this bit clears the ORE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.3..3> ORECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_IDLECF  ---------------------------------
// SVD Line: 24514

//  <item> SFDITEM_FIELD__USART1_ICR_IDLECF
//    <name> IDLECF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40013820) Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.4..4> IDLECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_TXFECF  ---------------------------------
// SVD Line: 24522

//  <item> SFDITEM_FIELD__USART1_ICR_TXFECF
//    <name> TXFECF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40013820) TXFIFO empty clear flag Writing 1 to this bit clears the TXFE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.5..5> TXFECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_ICR_TCCF  ----------------------------------
// SVD Line: 24530

//  <item> SFDITEM_FIELD__USART1_ICR_TCCF
//    <name> TCCF </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40013820) Transmission complete clear flag Writing 1 to this bit clears the TC flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.6..6> TCCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: USART1_ICR_TCBGTCF  ---------------------------------
// SVD Line: 24538

//  <item> SFDITEM_FIELD__USART1_ICR_TCBGTCF
//    <name> TCBGTCF </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40013820) Transmission complete before Guard time clear flag Writing 1 to this bit clears the TCBGT flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.7..7> TCBGTCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_LBDCF  ----------------------------------
// SVD Line: 24546

//  <item> SFDITEM_FIELD__USART1_ICR_LBDCF
//    <name> LBDCF </name>
//    <w> 
//    <i> [Bit 8] WO (@ 0x40013820) LIN break detection clear flag Writing 1 to this bit clears the LBDF flag in the USART_ISR register. Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.8..8> LBDCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_CTSCF  ----------------------------------
// SVD Line: 24555

//  <item> SFDITEM_FIELD__USART1_ICR_CTSCF
//    <name> CTSCF </name>
//    <w> 
//    <i> [Bit 9] WO (@ 0x40013820) CTS clear flag Writing 1 to this bit clears the CTSIF flag in the USART_ISR register. Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.9..9> CTSCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_RTOCF  ----------------------------------
// SVD Line: 24564

//  <item> SFDITEM_FIELD__USART1_ICR_RTOCF
//    <name> RTOCF </name>
//    <w> 
//    <i> [Bit 11] WO (@ 0x40013820) Receiver timeout clear flag Writing 1 to this bit clears the RTOF flag in the USART_ISR register. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page835. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.11..11> RTOCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_EOBCF  ----------------------------------
// SVD Line: 24573

//  <item> SFDITEM_FIELD__USART1_ICR_EOBCF
//    <name> EOBCF </name>
//    <w> 
//    <i> [Bit 12] WO (@ 0x40013820) End of block clear flag Writing 1 to this bit clears the EOBF flag in the USART_ISR register. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.12..12> EOBCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART1_ICR_UDRCF  ----------------------------------
// SVD Line: 24582

//  <item> SFDITEM_FIELD__USART1_ICR_UDRCF
//    <name> UDRCF </name>
//    <w> 
//    <i> [Bit 13] WO (@ 0x40013820) SPI slave underrun clear flag Writing 1 to this bit clears the UDRF flag in the USART_ISR register. Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.13..13> UDRCF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_ICR_CMCF  ----------------------------------
// SVD Line: 24591

//  <item> SFDITEM_FIELD__USART1_ICR_CMCF
//    <name> CMCF </name>
//    <w> 
//    <i> [Bit 17] WO (@ 0x40013820) Character match clear flag Writing 1 to this bit clears the CMF flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.17..17> CMCF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART1_ICR_WUCF  ----------------------------------
// SVD Line: 24599

//  <item> SFDITEM_FIELD__USART1_ICR_WUCF
//    <name> WUCF </name>
//    <w> 
//    <i> [Bit 20] WO (@ 0x40013820) Wakeup from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835. </i>
//    <check> 
//      <loc> ( (unsigned int) USART1_ICR ) </loc>
//      <o.20..20> WUCF
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: USART1_ICR  -----------------------------------
// SVD Line: 24473

//  <rtree> SFDITEM_REG__USART1_ICR
//    <name> ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40013820) Interrupt flag clear register </i>
//    <loc> ( (unsigned int)((USART1_ICR >> 0) & 0xFFFFFFFF), ((USART1_ICR = (USART1_ICR & ~(0x123BFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x123BFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_ICR_PECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_FECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_NECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_ORECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_IDLECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_TXFECF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_TCCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_TCBGTCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_LBDCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_CTSCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_RTOCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_EOBCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_UDRCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_CMCF </item>
//    <item> SFDITEM_FIELD__USART1_ICR_WUCF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_RDR  -------------------------------
// SVD Line: 24610

unsigned int USART1_RDR __AT (0x40013824);



// -------------------------------  Field Item: USART1_RDR_RDR  -----------------------------------
// SVD Line: 24619

//  <item> SFDITEM_FIELD__USART1_RDR_RDR
//    <name> RDR </name>
//    <r> 
//    <i> [Bits 8..0] RO (@ 0x40013824) Receive data value </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART1_RDR >> 0) & 0x1FF) ) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_RDR  -----------------------------------
// SVD Line: 24610

//  <rtree> SFDITEM_REG__USART1_RDR
//    <name> RDR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40013824) Receive data register </i>
//    <loc> ( (unsigned int)((USART1_RDR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART1_RDR_RDR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART1_TDR  -------------------------------
// SVD Line: 24627

unsigned int USART1_TDR __AT (0x40013828);



// -------------------------------  Field Item: USART1_TDR_TDR  -----------------------------------
// SVD Line: 24636

//  <item> SFDITEM_FIELD__USART1_TDR_TDR
//    <name> TDR </name>
//    <rw> 
//    <i> [Bits 8..0] RW (@ 0x40013828) Transmit data value </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART1_TDR >> 0) & 0x1FF), ((USART1_TDR = (USART1_TDR & ~(0x1FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x1FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART1_TDR  -----------------------------------
// SVD Line: 24627

//  <rtree> SFDITEM_REG__USART1_TDR
//    <name> TDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40013828) Transmit data register </i>
//    <loc> ( (unsigned int)((USART1_TDR >> 0) & 0xFFFFFFFF), ((USART1_TDR = (USART1_TDR & ~(0x1FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_TDR_TDR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART1_PRESC  ------------------------------
// SVD Line: 24644

unsigned int USART1_PRESC __AT (0x4001382C);



// ---------------------------  Field Item: USART1_PRESC_PRESCALER  -------------------------------
// SVD Line: 24653

//  <item> SFDITEM_FIELD__USART1_PRESC_PRESCALER
//    <name> PRESCALER </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x4001382C) \nClock prescaler The USART input clock can be divided by a prescaler factor: Remaining combinations: Reserved Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.\n0 : B_0x0 = input clock not divided\n1 : B_0x1 = input clock divided by 2\n2 : B_0x2 = input clock divided by 4\n3 : B_0x3 = input clock divided by 6\n4 : B_0x4 = input clock divided by 8\n5 : B_0x5 = input clock divided by 10\n6 : B_0x6 = input clock divided by 12\n7 : B_0x7 = input clock divided by 16\n8 : B_0x8 = input clock divided by 32\n9 : B_0x9 = input clock divided by 64\n10 : B_0xA = input clock divided by 128\n11 : B_0xB = input clock divided by 256\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART1_PRESC ) </loc>
//      <o.3..0> PRESCALER
//        <0=> 0: B_0x0 = input clock not divided
//        <1=> 1: B_0x1 = input clock divided by 2
//        <2=> 2: B_0x2 = input clock divided by 4
//        <3=> 3: B_0x3 = input clock divided by 6
//        <4=> 4: B_0x4 = input clock divided by 8
//        <5=> 5: B_0x5 = input clock divided by 10
//        <6=> 6: B_0x6 = input clock divided by 12
//        <7=> 7: B_0x7 = input clock divided by 16
//        <8=> 8: B_0x8 = input clock divided by 32
//        <9=> 9: B_0x9 = input clock divided by 64
//        <10=> 10: B_0xA = input clock divided by 128
//        <11=> 11: B_0xB = input clock divided by 256
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: USART1_PRESC  ----------------------------------
// SVD Line: 24644

//  <rtree> SFDITEM_REG__USART1_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4001382C) Prescaler register </i>
//    <loc> ( (unsigned int)((USART1_PRESC >> 0) & 0xFFFFFFFF), ((USART1_PRESC = (USART1_PRESC & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART1_PRESC_PRESCALER </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: USART1  ------------------------------------
// SVD Line: 21280

//  <view> USART1
//    <name> USART1 </name>
//    <item> SFDITEM_REG__USART1_CR1_FIFO_ENABLED </item>
//    <item> SFDITEM_REG__USART1_CR1_FIFO_DISABLED </item>
//    <item> SFDITEM_REG__USART1_CR2 </item>
//    <item> SFDITEM_REG__USART1_CR3 </item>
//    <item> SFDITEM_REG__USART1_BRR </item>
//    <item> SFDITEM_REG__USART1_GTPR </item>
//    <item> SFDITEM_REG__USART1_RTOR </item>
//    <item> SFDITEM_REG__USART1_RQR </item>
//    <item> SFDITEM_REG__USART1_ISR_FIFO_ENABLED </item>
//    <item> SFDITEM_REG__USART1_ISR_FIFO_DISABLED </item>
//    <item> SFDITEM_REG__USART1_ICR </item>
//    <item> SFDITEM_REG__USART1_RDR </item>
//    <item> SFDITEM_REG__USART1_TDR </item>
//    <item> SFDITEM_REG__USART1_PRESC </item>
//  </view>
//  


// ---------------------  Register Item Address: USART2_CR1_FIFO_ENABLED  -------------------------
// SVD Line: 21297

unsigned int USART2_CR1_FIFO_ENABLED __AT (0x40004400);



// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_UE  -----------------------------
// SVD Line: 21306

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_UE
//    <name> UE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40004400) \nUSART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.\n0 : B_0x0 = USART prescaler and outputs disabled, low-power mode\n1 : B_0x1 = USART enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.0..0> UE
//        <0=> 0: B_0x0 = USART prescaler and outputs disabled, low-power mode
//        <1=> 1: B_0x1 = USART enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_UESM  ----------------------------
// SVD Line: 21329

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_UESM
//    <name> UESM </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40004400) \nUSART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = USART not able to wake up the MCU from low-power mode.\n1 : B_0x1 = USART able to wake up the MCU from low-power mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.1..1> UESM
//        <0=> 0: B_0x0 = USART not able to wake up the MCU from low-power mode.
//        <1=> 1: B_0x1 = USART able to wake up the MCU from low-power mode.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_RE  -----------------------------
// SVD Line: 21353

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RE
//    <name> RE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40004400) \nReceiver enable This bit enables the receiver. It is set and cleared by software.\n0 : B_0x0 = Receiver is disabled\n1 : B_0x1 = Receiver is enabled and begins searching for a start bit </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.2..2> RE
//        <0=> 0: B_0x0 = Receiver is disabled
//        <1=> 1: B_0x1 = Receiver is enabled and begins searching for a start bit
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_TE  -----------------------------
// SVD Line: 21373

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TE
//    <name> TE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40004400) \nTransmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0 followed by '1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.\n0 : B_0x0 = Transmitter is disabled\n1 : B_0x1 = Transmitter is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.3..3> TE
//        <0=> 0: B_0x0 = Transmitter is disabled
//        <1=> 1: B_0x1 = Transmitter is enabled
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_IDLEIE  ---------------------------
// SVD Line: 21395

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_IDLEIE
//    <name> IDLEIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40004400) \nIDLE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.4..4> IDLEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_RXFNEIE  --------------------------
// SVD Line: 21415

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RXFNEIE
//    <name> RXFNEIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40004400) \nRXFIFO not empty interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.5..5> RXFNEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_TCIE  ----------------------------
// SVD Line: 21435

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40004400) \nTransmission complete interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_TXFNFIE  --------------------------
// SVD Line: 21455

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TXFNFIE
//    <name> TXFNFIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40004400) \nTXFIFO not full interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TXFNF =1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.7..7> TXFNFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TXFNF =1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_PEIE  ----------------------------
// SVD Line: 21475

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PEIE
//    <name> PEIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40004400) \nPE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.8..8> PEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_PS  -----------------------------
// SVD Line: 21495

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PS
//    <name> PS </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40004400) \nParity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Even parity\n1 : B_0x1 = Odd parity </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.9..9> PS
//        <0=> 0: B_0x0 = Even parity
//        <1=> 1: B_0x1 = Odd parity
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_PCE  ----------------------------
// SVD Line: 21516

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PCE
//    <name> PCE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40004400) \nParity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Parity control disabled\n1 : B_0x1 = Parity control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.10..10> PCE
//        <0=> 0: B_0x0 = Parity control disabled
//        <1=> 1: B_0x1 = Parity control enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_WAKE  ----------------------------
// SVD Line: 21537

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_WAKE
//    <name> WAKE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40004400) \nReceiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Idle line\n1 : B_0x1 = Address mark </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.11..11> WAKE
//        <0=> 0: B_0x0 = Idle line
//        <1=> 1: B_0x1 = Address mark
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_M0  -----------------------------
// SVD Line: 21558

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_M0
//    <name> M0 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40004400) Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE=0). </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.12..12> M0
//    </check>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_MME  ----------------------------
// SVD Line: 21567

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_MME
//    <name> MME </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40004400) \nMute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0 : B_0x0 = Receiver in active mode permanently\n1 : B_0x1 = Receiver can switch between Mute mode and active mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.13..13> MME
//        <0=> 0: B_0x0 = Receiver in active mode permanently
//        <1=> 1: B_0x1 = Receiver can switch between Mute mode and active mode.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_CMIE  ----------------------------
// SVD Line: 21587

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_CMIE
//    <name> CMIE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40004400) \nCharacter match interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.14..14> CMIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_OVER8  ---------------------------
// SVD Line: 21607

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_OVER8
//    <name> OVER8 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40004400) \nOversampling mode This bit can only be written when the USART is disabled (UE=0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.\n0 : B_0x0 = Oversampling by 16\n1 : B_0x1 = Oversampling by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.15..15> OVER8
//        <0=> 0: B_0x0 = Oversampling by 16
//        <1=> 1: B_0x1 = Oversampling by 8
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_DEDT  ----------------------------
// SVD Line: 21628

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_DEDT
//    <name> DEDT </name>
//    <rw> 
//    <i> [Bits 20..16] RW (@ 0x40004400) Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_CR1_FIFO_ENABLED >> 16) & 0x1F), ((USART2_CR1_FIFO_ENABLED = (USART2_CR1_FIFO_ENABLED & ~(0x1FUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_DEAT  ----------------------------
// SVD Line: 21639

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_DEAT
//    <name> DEAT </name>
//    <rw> 
//    <i> [Bits 25..21] RW (@ 0x40004400) Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_CR1_FIFO_ENABLED >> 21) & 0x1F), ((USART2_CR1_FIFO_ENABLED = (USART2_CR1_FIFO_ENABLED & ~(0x1FUL << 21 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 21 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_RTOIE  ---------------------------
// SVD Line: 21649

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RTOIE
//    <name> RTOIE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40004400) \nReceiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.26..26> RTOIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_ENABLED_EOBIE  ---------------------------
// SVD Line: 21670

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_EOBIE
//    <name> EOBIE </name>
//    <rw> 
//    <i> [Bit 27] RW (@ 0x40004400) \nEnd of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.27..27> EOBIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_ENABLED_M1  -----------------------------
// SVD Line: 21691

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_M1
//    <name> M1 </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40004400) Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UE=0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.28..28> M1
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_FIFOEN  ---------------------------
// SVD Line: 21704

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_FIFOEN
//    <name> FIFOEN </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40004400) \nFIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.\n0 : B_0x0 = FIFO mode is disabled.\n1 : B_0x1 = FIFO mode is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.29..29> FIFOEN
//        <0=> 0: B_0x0 = FIFO mode is disabled.
//        <1=> 1: B_0x1 = FIFO mode is enabled.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_TXFEIE  ---------------------------
// SVD Line: 21726

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TXFEIE
//    <name> TXFEIE </name>
//    <rw> 
//    <i> [Bit 30] RW (@ 0x40004400) \nTXFIFO empty interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when TXFE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.30..30> TXFEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when TXFE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_ENABLED_RXFFIE  ---------------------------
// SVD Line: 21746

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RXFFIE
//    <name> RXFFIE </name>
//    <rw> 
//    <i> [Bit 31] RW (@ 0x40004400) \nRXFIFO Full interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when RXFF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_ENABLED ) </loc>
//      <o.31..31> RXFFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when RXFF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Register RTree: USART2_CR1_FIFO_ENABLED  ----------------------------
// SVD Line: 21297

//  <rtree> SFDITEM_REG__USART2_CR1_FIFO_ENABLED
//    <name> CR1_FIFO_ENABLED </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004400) Control register 1 </i>
//    <loc> ( (unsigned int)((USART2_CR1_FIFO_ENABLED >> 0) & 0xFFFFFFFF), ((USART2_CR1_FIFO_ENABLED = (USART2_CR1_FIFO_ENABLED & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_UE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_UESM </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_IDLEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RXFNEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TCIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TXFNFIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PS </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_PCE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_WAKE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_M0 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_MME </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_CMIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_OVER8 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_DEDT </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_DEAT </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RTOIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_EOBIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_M1 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_FIFOEN </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_TXFEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_ENABLED_RXFFIE </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART2_CR1_FIFO_DISABLED  ------------------------
// SVD Line: 21768

unsigned int USART2_CR1_FIFO_DISABLED __AT (0x40004400);



// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_UE  ----------------------------
// SVD Line: 21778

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_UE
//    <name> UE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40004400) \nUSART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.\n0 : B_0x0 = USART prescaler and outputs disabled, low-power mode\n1 : B_0x1 = USART enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.0..0> UE
//        <0=> 0: B_0x0 = USART prescaler and outputs disabled, low-power mode
//        <1=> 1: B_0x1 = USART enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_UESM  ---------------------------
// SVD Line: 21801

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_UESM
//    <name> UESM </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40004400) \nUSART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode. This bit is set and cleared by software. Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = USART not able to wake up the MCU from low-power mode.\n1 : B_0x1 = USART able to wake up the MCU from low-power mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.1..1> UESM
//        <0=> 0: B_0x0 = USART not able to wake up the MCU from low-power mode.
//        <1=> 1: B_0x1 = USART able to wake up the MCU from low-power mode.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_RE  ----------------------------
// SVD Line: 21825

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RE
//    <name> RE </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40004400) \nReceiver enable This bit enables the receiver. It is set and cleared by software.\n0 : B_0x0 = Receiver is disabled\n1 : B_0x1 = Receiver is enabled and begins searching for a start bit </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.2..2> RE
//        <0=> 0: B_0x0 = Receiver is disabled
//        <1=> 1: B_0x1 = Receiver is enabled and begins searching for a start bit
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_TE  ----------------------------
// SVD Line: 21845

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TE
//    <name> TE </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40004400) \nTransmitter enable This bit enables the transmitter. It is set and cleared by software. Note: During transmission, a low pulse on the TE bit ('0 followed by '1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.\n0 : B_0x0 = Transmitter is disabled\n1 : B_0x1 = Transmitter is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.3..3> TE
//        <0=> 0: B_0x0 = Transmitter is disabled
//        <1=> 1: B_0x1 = Transmitter is enabled
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_IDLEIE  --------------------------
// SVD Line: 21867

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_IDLEIE
//    <name> IDLEIE </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40004400) \nIDLE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.4..4> IDLEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever IDLE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_RXNEIE  --------------------------
// SVD Line: 21887

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RXNEIE
//    <name> RXNEIE </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40004400) \nReceive data register not empty This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.5..5> RXNEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_TCIE  ---------------------------
// SVD Line: 21907

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TCIE
//    <name> TCIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40004400) \nTransmission complete interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.6..6> TCIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TC = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_TXEIE  ---------------------------
// SVD Line: 21927

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TXEIE
//    <name> TXEIE </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40004400) \nTransmit data register empty This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TXE =1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.7..7> TXEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TXE =1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_PEIE  ---------------------------
// SVD Line: 21947

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PEIE
//    <name> PEIE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40004400) \nPE interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.8..8> PEIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever PE = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_PS  ----------------------------
// SVD Line: 21967

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PS
//    <name> PS </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40004400) \nParity selection This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Even parity\n1 : B_0x1 = Odd parity </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.9..9> PS
//        <0=> 0: B_0x0 = Even parity
//        <1=> 1: B_0x1 = Odd parity
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_PCE  ----------------------------
// SVD Line: 21988

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PCE
//    <name> PCE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40004400) \nParity control enable This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission). This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Parity control disabled\n1 : B_0x1 = Parity control enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.10..10> PCE
//        <0=> 0: B_0x0 = Parity control disabled
//        <1=> 1: B_0x1 = Parity control enabled
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_WAKE  ---------------------------
// SVD Line: 22009

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_WAKE
//    <name> WAKE </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40004400) \nReceiver wakeup method This bit determines the USART wakeup method from Mute mode. It is set or cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Idle line\n1 : B_0x1 = Address mark </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.11..11> WAKE
//        <0=> 0: B_0x0 = Idle line
//        <1=> 1: B_0x1 = Address mark
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_M0  ----------------------------
// SVD Line: 22030

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_M0
//    <name> M0 </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40004400) Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE=0). </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.12..12> M0
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_MME  ----------------------------
// SVD Line: 22039

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_MME
//    <name> MME </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40004400) \nMute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0 : B_0x0 = Receiver in active mode permanently\n1 : B_0x1 = Receiver can switch between Mute mode and active mode. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.13..13> MME
//        <0=> 0: B_0x0 = Receiver in active mode permanently
//        <1=> 1: B_0x1 = Receiver can switch between Mute mode and active mode.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_CMIE  ---------------------------
// SVD Line: 22059

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_CMIE
//    <name> CMIE </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40004400) \nCharacter match interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.14..14> CMIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the CMF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_OVER8  ---------------------------
// SVD Line: 22079

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_OVER8
//    <name> OVER8 </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40004400) \nOversampling mode This bit can only be written when the USART is disabled (UE=0). Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.\n0 : B_0x0 = Oversampling by 16\n1 : B_0x1 = Oversampling by 8 </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.15..15> OVER8
//        <0=> 0: B_0x0 = Oversampling by 16
//        <1=> 1: B_0x1 = Oversampling by 8
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_DEDT  ---------------------------
// SVD Line: 22100

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_DEDT
//    <name> DEDT </name>
//    <rw> 
//    <i> [Bits 20..16] RW (@ 0x40004400) Driver Enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_CR1_FIFO_DISABLED >> 16) & 0x1F), ((USART2_CR1_FIFO_DISABLED = (USART2_CR1_FIFO_DISABLED & ~(0x1FUL << 16 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 16 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------  Field Item: USART2_CR1_FIFO_DISABLED_DEAT  ---------------------------
// SVD Line: 22111

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_DEAT
//    <name> DEAT </name>
//    <rw> 
//    <i> [Bits 25..21] RW (@ 0x40004400) Driver Enable assertion time This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_CR1_FIFO_DISABLED >> 21) & 0x1F), ((USART2_CR1_FIFO_DISABLED = (USART2_CR1_FIFO_DISABLED & ~(0x1FUL << 21 )) | ((unsigned long)(Gui_u8:GuiVal & 0x1F) << 21 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_RTOIE  ---------------------------
// SVD Line: 22121

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RTOIE
//    <name> RTOIE </name>
//    <rw> 
//    <i> [Bit 26] RW (@ 0x40004400) \nReceiver timeout interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.26..26> RTOIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the RTOF bit is set in the USART_ISR register.
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_EOBIE  ---------------------------
// SVD Line: 22142

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_EOBIE
//    <name> EOBIE </name>
//    <rw> 
//    <i> [Bit 27] RW (@ 0x40004400) \nEnd of Block interrupt enable This bit is set and cleared by software. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.27..27> EOBIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when the EOBF flag is set in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_CR1_FIFO_DISABLED_M1  ----------------------------
// SVD Line: 22163

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_M1
//    <name> M1 </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40004400) Word length This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software. M[1:0] = '00: 1 start bit, 8 Data bits, n Stop bit M[1:0] = '01: 1 start bit, 9 Data bits, n Stop bit M[1:0] = '10: 1 start bit, 7 Data bits, n Stop bit This bit can only be written when the USART is disabled (UE=0). Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.28..28> M1
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART2_CR1_FIFO_DISABLED_FIFOEN  --------------------------
// SVD Line: 22176

//  <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_FIFOEN
//    <name> FIFOEN </name>
//    <rw> 
//    <i> [Bit 29] RW (@ 0x40004400) \nFIFO mode enable This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0). Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.\n0 : B_0x0 = FIFO mode is disabled.\n1 : B_0x1 = FIFO mode is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR1_FIFO_DISABLED ) </loc>
//      <o.29..29> FIFOEN
//        <0=> 0: B_0x0 = FIFO mode is disabled.
//        <1=> 1: B_0x1 = FIFO mode is enabled.
//    </combo>
//  </item>
//  


// ------------------------  Register RTree: USART2_CR1_FIFO_DISABLED  ----------------------------
// SVD Line: 21768

//  <rtree> SFDITEM_REG__USART2_CR1_FIFO_DISABLED
//    <name> CR1_FIFO_DISABLED </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004400) Control register 1 </i>
//    <loc> ( (unsigned int)((USART2_CR1_FIFO_DISABLED >> 0) & 0xFFFFFFFF), ((USART2_CR1_FIFO_DISABLED = (USART2_CR1_FIFO_DISABLED & ~(0x3FFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3FFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_UE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_UESM </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_IDLEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RXNEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TCIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_TXEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PEIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PS </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_PCE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_WAKE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_M0 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_MME </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_CMIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_OVER8 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_DEDT </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_DEAT </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_RTOIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_EOBIE </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_M1 </item>
//    <item> SFDITEM_FIELD__USART2_CR1_FIFO_DISABLED_FIFOEN </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_CR2  -------------------------------
// SVD Line: 22200

unsigned int USART2_CR2 __AT (0x40004404);



// ------------------------------  Field Item: USART2_CR2_SLVEN  ----------------------------------
// SVD Line: 22209

//  <item> SFDITEM_FIELD__USART2_CR2_SLVEN
//    <name> SLVEN </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40004404) \nSynchronous Slave mode enable When the SLVEN bit is set, the synchronous slave mode is enabled. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Slave mode disabled.\n1 : B_0x1 = Slave mode enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.0..0> SLVEN
//        <0=> 0: B_0x0 = Slave mode disabled.
//        <1=> 1: B_0x1 = Slave mode enabled.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR2_DIS_NSS  ---------------------------------
// SVD Line: 22230

//  <item> SFDITEM_FIELD__USART2_CR2_DIS_NSS
//    <name> DIS_NSS </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40004404) \nWhen the DIS_NSS bit is set, the NSS pin input is ignored. Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = SPI slave selection depends on NSS input pin.\n1 : B_0x1 = SPI slave is always selected and NSS input pin is ignored. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.3..3> DIS_NSS
//        <0=> 0: B_0x0 = SPI slave selection depends on NSS input pin.
//        <1=> 1: B_0x1 = SPI slave is always selected and NSS input pin is ignored.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_ADDM7  ----------------------------------
// SVD Line: 22250

//  <item> SFDITEM_FIELD__USART2_CR2_ADDM7
//    <name> ADDM7 </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40004404) \n7-bit Address Detection/4-bit Address Detection This bit is for selection between 4-bit address detection or 7-bit address detection. This bit can only be written when the USART is disabled (UE=0) Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.\n0 : B_0x0 = 4-bit address detection\n1 : B_0x1 = 7-bit address detection (in 8-bit data mode) </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.4..4> ADDM7
//        <0=> 0: B_0x0 = 4-bit address detection
//        <1=> 1: B_0x1 = 7-bit address detection (in 8-bit data mode)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_LBDL  ----------------------------------
// SVD Line: 22272

//  <item> SFDITEM_FIELD__USART2_CR2_LBDL
//    <name> LBDL </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40004404) \nLIN break detection length This bit is for selection between 11 bit or 10 bit break detection. This bit can only be written when the USART is disabled (UE=0). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = 10-bit break detection\n1 : B_0x1 = 11-bit break detection </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.5..5> LBDL
//        <0=> 0: B_0x0 = 10-bit break detection
//        <1=> 1: B_0x1 = 11-bit break detection
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_LBDIE  ----------------------------------
// SVD Line: 22294

//  <item> SFDITEM_FIELD__USART2_CR2_LBDIE
//    <name> LBDIE </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40004404) \nLIN break detection interrupt enable Break interrupt mask (break detection using break delimiter). Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt is inhibited\n1 : B_0x1 = An interrupt is generated whenever LBDF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.6..6> LBDIE
//        <0=> 0: B_0x0 = Interrupt is inhibited
//        <1=> 1: B_0x1 = An interrupt is generated whenever LBDF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_LBCL  ----------------------------------
// SVD Line: 22315

//  <item> SFDITEM_FIELD__USART2_CR2_LBCL
//    <name> LBCL </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40004404) \nLast bit clock pulse This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in synchronous mode. The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register. This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = The clock pulse of the last data bit is not output to the SCLK pin\n1 : B_0x1 = The clock pulse of the last data bit is output to the SCLK pin </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.8..8> LBCL
//        <0=> 0: B_0x0 = The clock pulse of the last data bit is not output to the SCLK pin
//        <1=> 1: B_0x1 = The clock pulse of the last data bit is output to the SCLK pin
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_CPHA  ----------------------------------
// SVD Line: 22338

//  <item> SFDITEM_FIELD__USART2_CR2_CPHA
//    <name> CPHA </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40004404) \nClock phase This bit is used to select the phase of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see and ) This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = The first clock transition is the first data capture edge\n1 : B_0x1 = The second clock transition is the first data capture edge </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.9..9> CPHA
//        <0=> 0: B_0x0 = The first clock transition is the first data capture edge
//        <1=> 1: B_0x1 = The second clock transition is the first data capture edge
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_CPOL  ----------------------------------
// SVD Line: 22360

//  <item> SFDITEM_FIELD__USART2_CR2_CPOL
//    <name> CPOL </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40004404) \nClock polarity This bit enables the user to select the polarity of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship This bit can only be written when the USART is disabled (UE=0). Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Steady low value on SCLK pin outside transmission window\n1 : B_0x1 = Steady high value on SCLK pin outside transmission window </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.10..10> CPOL
//        <0=> 0: B_0x0 = Steady low value on SCLK pin outside transmission window
//        <1=> 1: B_0x1 = Steady high value on SCLK pin outside transmission window
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_CLKEN  ----------------------------------
// SVD Line: 22382

//  <item> SFDITEM_FIELD__USART2_CR2_CLKEN
//    <name> CLKEN </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40004404) \nClock enable This bit enables the user to enable the SCLK pin. This bit can only be written when the USART is disabled (UE=0). Note: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to . In Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected: UE = 0 SCEN = 1 GTPR configuration CLKEN= 1 UE = 1\n0 : B_0x0 = SCLK pin disabled\n1 : B_0x1 = SCLK pin enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.11..11> CLKEN
//        <0=> 0: B_0x0 = SCLK pin disabled
//        <1=> 1: B_0x1 = SCLK pin enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_STOP  ----------------------------------
// SVD Line: 22410

//  <item> SFDITEM_FIELD__USART2_CR2_STOP
//    <name> STOP </name>
//    <rw> 
//    <i> [Bits 13..12] RW (@ 0x40004404) \nstop bits These bits are used for programming the stop bits. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = 1 stop bit\n1 : B_0x1 = 0.5 stop bit.\n2 : B_0x2 = 2 stop bits\n3 : B_0x3 = 1.5 stop bits </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.13..12> STOP
//        <0=> 0: B_0x0 = 1 stop bit
//        <1=> 1: B_0x1 = 0.5 stop bit.
//        <2=> 2: B_0x2 = 2 stop bits
//        <3=> 3: B_0x3 = 1.5 stop bits
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_LINEN  ----------------------------------
// SVD Line: 22441

//  <item> SFDITEM_FIELD__USART2_CR2_LINEN
//    <name> LINEN </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40004404) \nLIN mode enable This bit is set and cleared by software. The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = LIN mode disabled\n1 : B_0x1 = LIN mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.14..14> LINEN
//        <0=> 0: B_0x0 = LIN mode disabled
//        <1=> 1: B_0x1 = LIN mode enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_SWAP  ----------------------------------
// SVD Line: 22464

//  <item> SFDITEM_FIELD__USART2_CR2_SWAP
//    <name> SWAP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40004404) \nSwap TX/RX pins This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = TX/RX pins are used as defined in standard pinout\n1 : B_0x1 = The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.15..15> SWAP
//        <0=> 0: B_0x0 = TX/RX pins are used as defined in standard pinout
//        <1=> 1: B_0x1 = The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_RXINV  ----------------------------------
// SVD Line: 22485

//  <item> SFDITEM_FIELD__USART2_CR2_RXINV
//    <name> RXINV </name>
//    <rw> 
//    <i> [Bit 16] RW (@ 0x40004404) \nRX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the RX line. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = RX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)\n1 : B_0x1 = RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.16..16> RXINV
//        <0=> 0: B_0x0 = RX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)
//        <1=> 1: B_0x1 = RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle).
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_TXINV  ----------------------------------
// SVD Line: 22507

//  <item> SFDITEM_FIELD__USART2_CR2_TXINV
//    <name> TXINV </name>
//    <rw> 
//    <i> [Bit 17] RW (@ 0x40004404) \nTX pin active level inversion This bit is set and cleared by software. This enables the use of an external inverter on the TX line. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)\n1 : B_0x1 = TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.17..17> TXINV
//        <0=> 0: B_0x0 = TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)
//        <1=> 1: B_0x1 = TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle).
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR2_DATAINV  ---------------------------------
// SVD Line: 22529

//  <item> SFDITEM_FIELD__USART2_CR2_DATAINV
//    <name> DATAINV </name>
//    <rw> 
//    <i> [Bit 18] RW (@ 0x40004404) \nBinary data inversion This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)\n1 : B_0x1 = Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.18..18> DATAINV
//        <0=> 0: B_0x0 = Logical data from the data register are send/received in positive/direct logic. (1 = H, 0 = L)
//        <1=> 1: B_0x1 = Logical data from the data register are send/received in negative/inverse logic. (1 = L, 0 = H). The parity bit is also inverted.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR2_MSBFIRST  --------------------------------
// SVD Line: 22550

//  <item> SFDITEM_FIELD__USART2_CR2_MSBFIRST
//    <name> MSBFIRST </name>
//    <rw> 
//    <i> [Bit 19] RW (@ 0x40004404) \nMost significant bit first This bit is set and cleared by software. This bitfield can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = data is transmitted/received with data bit 0 first, following the start bit.\n1 : B_0x1 = data is transmitted/received with the MSB (bit 7/8) first, following the start bit. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.19..19> MSBFIRST
//        <0=> 0: B_0x0 = data is transmitted/received with data bit 0 first, following the start bit.
//        <1=> 1: B_0x1 = data is transmitted/received with the MSB (bit 7/8) first, following the start bit.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_ABREN  ----------------------------------
// SVD Line: 22571

//  <item> SFDITEM_FIELD__USART2_CR2_ABREN
//    <name> ABREN </name>
//    <rw> 
//    <i> [Bit 20] RW (@ 0x40004404) \nAuto baud rate enable This bit is set and cleared by software. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Auto baud rate detection is disabled.\n1 : B_0x1 = Auto baud rate detection is enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.20..20> ABREN
//        <0=> 0: B_0x0 = Auto baud rate detection is disabled.
//        <1=> 1: B_0x1 = Auto baud rate detection is enabled.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_ABRMOD  ---------------------------------
// SVD Line: 22592

//  <item> SFDITEM_FIELD__USART2_CR2_ABRMOD
//    <name> ABRMOD </name>
//    <rw> 
//    <i> [Bits 22..21] RW (@ 0x40004404) \nAuto baud rate mode These bits are set and cleared by software. This bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0). Note: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST) If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Measurement of the start bit is used to detect the baud rate.\n1 : B_0x1 = Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)\n2 : B_0x2 = 0x7F frame detection.\n3 : B_0x3 = 0x55 frame detection </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.22..21> ABRMOD
//        <0=> 0: B_0x0 = Measurement of the start bit is used to detect the baud rate.
//        <1=> 1: B_0x1 = Falling edge to falling edge measurement (the received frame must start with a single bit = 1 and Frame = Start10xxxxxx)
//        <2=> 2: B_0x2 = 0x7F frame detection.
//        <3=> 3: B_0x3 = 0x55 frame detection
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR2_RTOEN  ----------------------------------
// SVD Line: 22625

//  <item> SFDITEM_FIELD__USART2_CR2_RTOEN
//    <name> RTOEN </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40004404) \nReceiver timeout enable This bit is set and cleared by software. When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register). Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Receiver timeout feature disabled.\n1 : B_0x1 = Receiver timeout feature enabled. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR2 ) </loc>
//      <o.23..23> RTOEN
//        <0=> 0: B_0x0 = Receiver timeout feature disabled.
//        <1=> 1: B_0x1 = Receiver timeout feature enabled.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR2_ADD  -----------------------------------
// SVD Line: 22647

//  <item> SFDITEM_FIELD__USART2_CR2_ADD
//    <name> ADD </name>
//    <rw> 
//    <i> [Bits 31..24] RW (@ 0x40004404) Address of the USART node ADD[7:4]: These bits give the address of the USART node or a character code to be recognized. They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or low-power mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0). ADD[3:0]: These bits give the address of the USART node or a character code to be recognized. They are used for wakeup with address mark detection, in multiprocessor communication during Mute mode or low-power mode. These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0). </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_CR2 >> 24) & 0xFF), ((USART2_CR2 = (USART2_CR2 & ~(0xFFUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_CR2  -----------------------------------
// SVD Line: 22200

//  <rtree> SFDITEM_REG__USART2_CR2
//    <name> CR2 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004404) Control register 2 </i>
//    <loc> ( (unsigned int)((USART2_CR2 >> 0) & 0xFFFFFFFF), ((USART2_CR2 = (USART2_CR2 & ~(0xFFFFFF79UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFF79) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_CR2_SLVEN </item>
//    <item> SFDITEM_FIELD__USART2_CR2_DIS_NSS </item>
//    <item> SFDITEM_FIELD__USART2_CR2_ADDM7 </item>
//    <item> SFDITEM_FIELD__USART2_CR2_LBDL </item>
//    <item> SFDITEM_FIELD__USART2_CR2_LBDIE </item>
//    <item> SFDITEM_FIELD__USART2_CR2_LBCL </item>
//    <item> SFDITEM_FIELD__USART2_CR2_CPHA </item>
//    <item> SFDITEM_FIELD__USART2_CR2_CPOL </item>
//    <item> SFDITEM_FIELD__USART2_CR2_CLKEN </item>
//    <item> SFDITEM_FIELD__USART2_CR2_STOP </item>
//    <item> SFDITEM_FIELD__USART2_CR2_LINEN </item>
//    <item> SFDITEM_FIELD__USART2_CR2_SWAP </item>
//    <item> SFDITEM_FIELD__USART2_CR2_RXINV </item>
//    <item> SFDITEM_FIELD__USART2_CR2_TXINV </item>
//    <item> SFDITEM_FIELD__USART2_CR2_DATAINV </item>
//    <item> SFDITEM_FIELD__USART2_CR2_MSBFIRST </item>
//    <item> SFDITEM_FIELD__USART2_CR2_ABREN </item>
//    <item> SFDITEM_FIELD__USART2_CR2_ABRMOD </item>
//    <item> SFDITEM_FIELD__USART2_CR2_RTOEN </item>
//    <item> SFDITEM_FIELD__USART2_CR2_ADD </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_CR3  -------------------------------
// SVD Line: 22664

unsigned int USART2_CR3 __AT (0x40004408);



// -------------------------------  Field Item: USART2_CR3_EIE  -----------------------------------
// SVD Line: 22673

//  <item> SFDITEM_FIELD__USART2_CR3_EIE
//    <name> EIE </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40004408) \nError interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1 or UDR = 1 in the USART_ISR register).\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.0..0> EIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_IREN  ----------------------------------
// SVD Line: 22693

//  <item> SFDITEM_FIELD__USART2_CR3_IREN
//    <name> IREN </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40004408) \nIrDA mode enable This bit is set and cleared by software. This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = IrDA disabled\n1 : B_0x1 = IrDA enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.1..1> IREN
//        <0=> 0: B_0x0 = IrDA disabled
//        <1=> 1: B_0x1 = IrDA enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_IRLP  ----------------------------------
// SVD Line: 22715

//  <item> SFDITEM_FIELD__USART2_CR3_IRLP
//    <name> IRLP </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40004408) \nIrDA low-power This bit is used for selecting between normal and low-power IrDA modes This bit can only be written when the USART is disabled (UE=0). Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Normal mode\n1 : B_0x1 = Low-power mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.2..2> IRLP
//        <0=> 0: B_0x0 = Normal mode
//        <1=> 1: B_0x1 = Low-power mode
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_HDSEL  ----------------------------------
// SVD Line: 22737

//  <item> SFDITEM_FIELD__USART2_CR3_HDSEL
//    <name> HDSEL </name>
//    <rw> 
//    <i> [Bit 3] RW (@ 0x40004408) \nHalf-duplex selection Selection of Single-wire Half-duplex mode This bit can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Half duplex mode is not selected\n1 : B_0x1 = Half duplex mode is selected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.3..3> HDSEL
//        <0=> 0: B_0x0 = Half duplex mode is not selected
//        <1=> 1: B_0x1 = Half duplex mode is selected
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_NACK  ----------------------------------
// SVD Line: 22758

//  <item> SFDITEM_FIELD__USART2_CR3_NACK
//    <name> NACK </name>
//    <rw> 
//    <i> [Bit 4] RW (@ 0x40004408) \nSmartcard NACK enable This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = NACK transmission in case of parity error is disabled\n1 : B_0x1 = NACK transmission during parity error is enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.4..4> NACK
//        <0=> 0: B_0x0 = NACK transmission in case of parity error is disabled
//        <1=> 1: B_0x1 = NACK transmission during parity error is enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_SCEN  ----------------------------------
// SVD Line: 22779

//  <item> SFDITEM_FIELD__USART2_CR3_SCEN
//    <name> SCEN </name>
//    <rw> 
//    <i> [Bit 5] RW (@ 0x40004408) \nSmartcard mode enable This bit is used for enabling Smartcard mode. This bitfield can only be written when the USART is disabled (UE=0). Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Smartcard Mode disabled\n1 : B_0x1 = Smartcard Mode enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.5..5> SCEN
//        <0=> 0: B_0x0 = Smartcard Mode disabled
//        <1=> 1: B_0x1 = Smartcard Mode enabled
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_DMAR  ----------------------------------
// SVD Line: 22801

//  <item> SFDITEM_FIELD__USART2_CR3_DMAR
//    <name> DMAR </name>
//    <rw> 
//    <i> [Bit 6] RW (@ 0x40004408) \nDMA enable receiver This bit is set/reset by software\n0 : B_0x0 = DMA mode is disabled for reception\n1 : B_0x1 = DMA mode is enabled for reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.6..6> DMAR
//        <0=> 0: B_0x0 = DMA mode is disabled for reception
//        <1=> 1: B_0x1 = DMA mode is enabled for reception
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_DMAT  ----------------------------------
// SVD Line: 22821

//  <item> SFDITEM_FIELD__USART2_CR3_DMAT
//    <name> DMAT </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40004408) \nDMA enable transmitter This bit is set/reset by software\n0 : B_0x0 = DMA mode is disabled for transmission\n1 : B_0x1 = DMA mode is enabled for transmission </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.7..7> DMAT
//        <0=> 0: B_0x0 = DMA mode is disabled for transmission
//        <1=> 1: B_0x1 = DMA mode is enabled for transmission
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_RTSE  ----------------------------------
// SVD Line: 22841

//  <item> SFDITEM_FIELD__USART2_CR3_RTSE
//    <name> RTSE </name>
//    <rw> 
//    <i> [Bit 8] RW (@ 0x40004408) \nRTS enable This bit can only be written when the USART is disabled (UE=0). Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = RTS hardware flow control disabled\n1 : B_0x1 = RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.8..8> RTSE
//        <0=> 0: B_0x0 = RTS hardware flow control disabled
//        <1=> 1: B_0x1 = RTS output enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The nRTS output is asserted (pulled to 0) when data can be received.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_CTSE  ----------------------------------
// SVD Line: 22862

//  <item> SFDITEM_FIELD__USART2_CR3_CTSE
//    <name> CTSE </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40004408) \nCTS enable This bit can only be written when the USART is disabled (UE=0) Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = CTS hardware flow control disabled\n1 : B_0x1 = CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.9..9> CTSE
//        <0=> 0: B_0x0 = CTS hardware flow control disabled
//        <1=> 1: B_0x1 = CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0). If the nCTS input is deasserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while nCTS is asserted, the transmission is postponed until nCTS is asserted.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_CTSIE  ----------------------------------
// SVD Line: 22883

//  <item> SFDITEM_FIELD__USART2_CR3_CTSIE
//    <name> CTSIE </name>
//    <rw> 
//    <i> [Bit 10] RW (@ 0x40004408) \nCTS interrupt enable Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt is inhibited\n1 : B_0x1 = An interrupt is generated whenever CTSIF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.10..10> CTSIE
//        <0=> 0: B_0x0 = Interrupt is inhibited
//        <1=> 1: B_0x1 = An interrupt is generated whenever CTSIF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_ONEBIT  ---------------------------------
// SVD Line: 22903

//  <item> SFDITEM_FIELD__USART2_CR3_ONEBIT
//    <name> ONEBIT </name>
//    <rw> 
//    <i> [Bit 11] RW (@ 0x40004408) \nOne sample bit method enable This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled. This bit can only be written when the USART is disabled (UE=0).\n0 : B_0x0 = Three sample bit method\n1 : B_0x1 = One sample bit method </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.11..11> ONEBIT
//        <0=> 0: B_0x0 = Three sample bit method
//        <1=> 1: B_0x1 = One sample bit method
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_OVRDIS  ---------------------------------
// SVD Line: 22924

//  <item> SFDITEM_FIELD__USART2_CR3_OVRDIS
//    <name> OVRDIS </name>
//    <rw> 
//    <i> [Bit 12] RW (@ 0x40004408) \nOverrun Disable This bit is used to disable the receive overrun detection. the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used. This bit can only be written when the USART is disabled (UE=0). Note: This control bit enables checking the communication flow w/o reading the data\n0 : B_0x0 = Overrun Error Flag, ORE, is set when received data is not read before receiving new data.\n1 : B_0x1 = Overrun functionality is disabled. If new data is received while the RXNE flag is still set </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.12..12> OVRDIS
//        <0=> 0: B_0x0 = Overrun Error Flag, ORE, is set when received data is not read before receiving new data.
//        <1=> 1: B_0x1 = Overrun functionality is disabled. If new data is received while the RXNE flag is still set
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_DDRE  ----------------------------------
// SVD Line: 22947

//  <item> SFDITEM_FIELD__USART2_CR3_DDRE
//    <name> DDRE </name>
//    <rw> 
//    <i> [Bit 13] RW (@ 0x40004408) \nDMA Disable on Reception Error This bit can only be written when the USART is disabled (UE=0). Note: The reception errors are: parity error, framing error or noise error.\n0 : B_0x0 = DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode).\n1 : B_0x1 = DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.13..13> DDRE
//        <0=> 0: B_0x0 = DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not transferred (no DMA request), but next correct received data is transferred (used for Smartcard mode).
//        <1=> 1: B_0x1 = DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_DEM  -----------------------------------
// SVD Line: 22968

//  <item> SFDITEM_FIELD__USART2_CR3_DEM
//    <name> DEM </name>
//    <rw> 
//    <i> [Bit 14] RW (@ 0x40004408) \nDriver enable mode This bit enables the user to activate the external transceiver control, through the DE signal. This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .\n0 : B_0x0 = DE function is disabled.\n1 : B_0x1 = DE function is enabled. The DE signal is output on the RTS pin. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.14..14> DEM
//        <0=> 0: B_0x0 = DE function is disabled.
//        <1=> 1: B_0x1 = DE function is enabled. The DE signal is output on the RTS pin.
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_DEP  -----------------------------------
// SVD Line: 22990

//  <item> SFDITEM_FIELD__USART2_CR3_DEP
//    <name> DEP </name>
//    <rw> 
//    <i> [Bit 15] RW (@ 0x40004408) \nDriver enable polarity selection This bit can only be written when the USART is disabled (UE=0). Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = DE signal is active high.\n1 : B_0x1 = DE signal is active low. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.15..15> DEP
//        <0=> 0: B_0x0 = DE signal is active high.
//        <1=> 1: B_0x1 = DE signal is active low.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR3_SCARCNT  ---------------------------------
// SVD Line: 23011

//  <item> SFDITEM_FIELD__USART2_CR3_SCARCNT
//    <name> SCARCNT </name>
//    <rw> 
//    <i> [Bits 19..17] RW (@ 0x40004408) \nSmartcard auto-retry count This bitfield specifies the number of retries for transmission and reception in Smartcard mode. In transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set). In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set). This bitfield must be programmed only when the USART is disabled (UE=0). When the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission. Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = retransmission disabled - No automatic retransmission in transmit mode.\n1 : B_0x1 = number of automatic retransmission attempts (before signaling error)\n2 : B_0x2 = number of automatic retransmission attempts (before signaling error)\n3 : B_0x3 = number of automatic retransmission attempts (before signaling error)\n4 : B_0x4 = number of automatic retransmission attempts (before signaling error)\n5 : B_0x5 = number of automatic retransmission attempts (before signaling error)\n6 : B_0x6 = number of automatic retransmission attempts (before signaling error)\n7 : B_0x7 = number of automatic retransmission attempts (before signaling error) </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.19..17> SCARCNT
//        <0=> 0: B_0x0 = retransmission disabled - No automatic retransmission in transmit mode.
//        <1=> 1: B_0x1 = number of automatic retransmission attempts (before signaling error)
//        <2=> 2: B_0x2 = number of automatic retransmission attempts (before signaling error)
//        <3=> 3: B_0x3 = number of automatic retransmission attempts (before signaling error)
//        <4=> 4: B_0x4 = number of automatic retransmission attempts (before signaling error)
//        <5=> 5: B_0x5 = number of automatic retransmission attempts (before signaling error)
//        <6=> 6: B_0x6 = number of automatic retransmission attempts (before signaling error)
//        <7=> 7: B_0x7 = number of automatic retransmission attempts (before signaling error)
//    </combo>
//  </item>
//  


// -------------------------------  Field Item: USART2_CR3_WUS  -----------------------------------
// SVD Line: 23066

//  <item> SFDITEM_FIELD__USART2_CR3_WUS
//    <name> WUS </name>
//    <rw> 
//    <i> [Bits 21..20] RW (@ 0x40004408) \nWakeup from low-power mode interrupt flag selection This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag). This bitfield can only be written when the USART is disabled (UE=0). If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835.\n0 : B_0x0 = WUF active on address match (as defined by ADD[7:0] and ADDM7)\n1 : Reserved - do not use\n2 : B_0x2 = WUF active on start bit detection\n3 : B_0x3 = WUF active on RXNE/RXFNE. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.21..20> WUS
//        <0=> 0: B_0x0 = WUF active on address match (as defined by ADD[7:0] and ADDM7)
//        <1=> 1: 
//        <2=> 2: B_0x2 = WUF active on start bit detection
//        <3=> 3: B_0x3 = WUF active on RXNE/RXFNE.
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_WUFIE  ----------------------------------
// SVD Line: 23093

//  <item> SFDITEM_FIELD__USART2_CR3_WUFIE
//    <name> WUFIE </name>
//    <rw> 
//    <i> [Bit 22] RW (@ 0x40004408) \nWakeup from low-power mode interrupt enable This bit is set and cleared by software. Note: WUFIE must be set before entering in low-power mode. If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever WUF = 1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.22..22> WUFIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever WUF = 1 in the USART_ISR register
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_TXFTIE  ---------------------------------
// SVD Line: 23115

//  <item> SFDITEM_FIELD__USART2_CR3_TXFTIE
//    <name> TXFTIE </name>
//    <rw> 
//    <i> [Bit 23] RW (@ 0x40004408) \nTXFIFO threshold interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.23..23> TXFTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR3_TCBGTIE  ---------------------------------
// SVD Line: 23135

//  <item> SFDITEM_FIELD__USART2_CR3_TCBGTIE
//    <name> TCBGTIE </name>
//    <rw> 
//    <i> [Bit 24] RW (@ 0x40004408) \nTransmission Complete before guard time, interrupt enable This bit is set and cleared by software. Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated whenever TCBGT=1 in the USART_ISR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.24..24> TCBGTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated whenever TCBGT=1 in the USART_ISR register
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR3_RXFTCFG  ---------------------------------
// SVD Line: 23156

//  <item> SFDITEM_FIELD__USART2_CR3_RXFTCFG
//    <name> RXFTCFG </name>
//    <rw> 
//    <i> [Bits 27..25] RW (@ 0x40004408) \nReceive FIFO threshold configuration Remaining combinations: Reserved\n0 : B_0x0 = Receive FIFO reaches 1/8 of its depth\n1 : B_0x1 = Receive FIFO reaches 1/4 of its depth\n2 : B_0x2 = Receive FIFO reaches 1/2 of its depth\n3 : B_0x3 = Receive FIFO reaches 3/4 of its depth\n4 : B_0x4 = Receive FIFO reaches 7/8 of its depth\n5 : B_0x5 = Receive FIFO becomes full\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.27..25> RXFTCFG
//        <0=> 0: B_0x0 = Receive FIFO reaches 1/8 of its depth
//        <1=> 1: B_0x1 = Receive FIFO reaches 1/4 of its depth
//        <2=> 2: B_0x2 = Receive FIFO reaches 1/2 of its depth
//        <3=> 3: B_0x3 = Receive FIFO reaches 3/4 of its depth
//        <4=> 4: B_0x4 = Receive FIFO reaches 7/8 of its depth
//        <5=> 5: B_0x5 = Receive FIFO becomes full
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// ------------------------------  Field Item: USART2_CR3_RXFTIE  ---------------------------------
// SVD Line: 23196

//  <item> SFDITEM_FIELD__USART2_CR3_RXFTIE
//    <name> RXFTIE </name>
//    <rw> 
//    <i> [Bit 28] RW (@ 0x40004408) \nRXFIFO threshold interrupt enable This bit is set and cleared by software.\n0 : B_0x0 = Interrupt inhibited\n1 : B_0x1 = USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.28..28> RXFTIE
//        <0=> 0: B_0x0 = Interrupt inhibited
//        <1=> 1: B_0x1 = USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG.
//    </combo>
//  </item>
//  


// -----------------------------  Field Item: USART2_CR3_TXFTCFG  ---------------------------------
// SVD Line: 23216

//  <item> SFDITEM_FIELD__USART2_CR3_TXFTCFG
//    <name> TXFTCFG </name>
//    <rw> 
//    <i> [Bits 31..29] RW (@ 0x40004408) \nTXFIFO threshold configuration Remaining combinations: Reserved\n0 : B_0x0 = TXFIFO reaches 1/8 of its depth\n1 : B_0x1 = TXFIFO reaches 1/4 of its depth\n2 : B_0x2 = TXFIFO reaches 1/2 of its depth\n3 : B_0x3 = TXFIFO reaches 3/4 of its depth\n4 : B_0x4 = TXFIFO reaches 7/8 of its depth\n5 : B_0x5 = TXFIFO becomes empty\n6 : Reserved - do not use\n7 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_CR3 ) </loc>
//      <o.31..29> TXFTCFG
//        <0=> 0: B_0x0 = TXFIFO reaches 1/8 of its depth
//        <1=> 1: B_0x1 = TXFIFO reaches 1/4 of its depth
//        <2=> 2: B_0x2 = TXFIFO reaches 1/2 of its depth
//        <3=> 3: B_0x3 = TXFIFO reaches 3/4 of its depth
//        <4=> 4: B_0x4 = TXFIFO reaches 7/8 of its depth
//        <5=> 5: B_0x5 = TXFIFO becomes empty
//        <6=> 6: 
//        <7=> 7: 
//    </combo>
//  </item>
//  


// -------------------------------  Register RTree: USART2_CR3  -----------------------------------
// SVD Line: 22664

//  <rtree> SFDITEM_REG__USART2_CR3
//    <name> CR3 </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004408) Control register 3 </i>
//    <loc> ( (unsigned int)((USART2_CR3 >> 0) & 0xFFFFFFFF), ((USART2_CR3 = (USART2_CR3 & ~(0xFFFEFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFEFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_CR3_EIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_IREN </item>
//    <item> SFDITEM_FIELD__USART2_CR3_IRLP </item>
//    <item> SFDITEM_FIELD__USART2_CR3_HDSEL </item>
//    <item> SFDITEM_FIELD__USART2_CR3_NACK </item>
//    <item> SFDITEM_FIELD__USART2_CR3_SCEN </item>
//    <item> SFDITEM_FIELD__USART2_CR3_DMAR </item>
//    <item> SFDITEM_FIELD__USART2_CR3_DMAT </item>
//    <item> SFDITEM_FIELD__USART2_CR3_RTSE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_CTSE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_CTSIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_ONEBIT </item>
//    <item> SFDITEM_FIELD__USART2_CR3_OVRDIS </item>
//    <item> SFDITEM_FIELD__USART2_CR3_DDRE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_DEM </item>
//    <item> SFDITEM_FIELD__USART2_CR3_DEP </item>
//    <item> SFDITEM_FIELD__USART2_CR3_SCARCNT </item>
//    <item> SFDITEM_FIELD__USART2_CR3_WUS </item>
//    <item> SFDITEM_FIELD__USART2_CR3_WUFIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_TXFTIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_TCBGTIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_RXFTCFG </item>
//    <item> SFDITEM_FIELD__USART2_CR3_RXFTIE </item>
//    <item> SFDITEM_FIELD__USART2_CR3_TXFTCFG </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_BRR  -------------------------------
// SVD Line: 23258

unsigned int USART2_BRR __AT (0x4000440C);



// -------------------------------  Field Item: USART2_BRR_BRR  -----------------------------------
// SVD Line: 23267

//  <item> SFDITEM_FIELD__USART2_BRR_BRR
//    <name> BRR </name>
//    <rw> 
//    <i> [Bits 15..0] RW (@ 0x4000440C) USART baud rate </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART2_BRR >> 0) & 0xFFFF), ((USART2_BRR = (USART2_BRR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_BRR  -----------------------------------
// SVD Line: 23258

//  <rtree> SFDITEM_REG__USART2_BRR
//    <name> BRR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000440C) Baud rate register </i>
//    <loc> ( (unsigned int)((USART2_BRR >> 0) & 0xFFFFFFFF), ((USART2_BRR = (USART2_BRR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_BRR_BRR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART2_GTPR  -------------------------------
// SVD Line: 23276

unsigned int USART2_GTPR __AT (0x40004410);



// -------------------------------  Field Item: USART2_GTPR_PSC  ----------------------------------
// SVD Line: 23286

//  <item> SFDITEM_FIELD__USART2_GTPR_PSC
//    <name> PSC </name>
//    <rw> 
//    <i> [Bits 7..0] RW (@ 0x40004410) Prescaler value In IrDA low-power and normal IrDA mode: PSC[7:0] = IrDA Normal and Low-Power baud rate PSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits): In Smartcard mode: PSC[4:0]=Prescaler value PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency: ... 00100000: Divides the source clock by 32 (IrDA mode) ... 11111111: Divides the source clock by 255 (IrDA mode) This bitfield can only be written when the USART is disabled (UE=0). Note: Bits [7:5] must be kept cleared if Smartcard mode is used. This bitfield is reserved and forced by hardware to '0 when the Smartcard and IrDA modes are not supported. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_GTPR >> 0) & 0xFF), ((USART2_GTPR = (USART2_GTPR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Field Item: USART2_GTPR_GT  -----------------------------------
// SVD Line: 23333

//  <item> SFDITEM_FIELD__USART2_GTPR_GT
//    <name> GT </name>
//    <rw> 
//    <i> [Bits 15..8] RW (@ 0x40004410) Guard time value This bitfield is used to program the Guard time value in terms of number of baud clock periods. This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value. This bitfield can only be written when the USART is disabled (UE=0). Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_GTPR >> 8) & 0xFF), ((USART2_GTPR = (USART2_GTPR & ~(0xFFUL << 8 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 8 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_GTPR  ----------------------------------
// SVD Line: 23276

//  <rtree> SFDITEM_REG__USART2_GTPR
//    <name> GTPR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004410) Guard time and prescaler  register </i>
//    <loc> ( (unsigned int)((USART2_GTPR >> 0) & 0xFFFFFFFF), ((USART2_GTPR = (USART2_GTPR & ~(0xFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_GTPR_PSC </item>
//    <item> SFDITEM_FIELD__USART2_GTPR_GT </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART2_RTOR  -------------------------------
// SVD Line: 23346

unsigned int USART2_RTOR __AT (0x40004414);



// -------------------------------  Field Item: USART2_RTOR_RTO  ----------------------------------
// SVD Line: 23355

//  <item> SFDITEM_FIELD__USART2_RTOR_RTO
//    <name> RTO </name>
//    <rw> 
//    <i> [Bits 23..0] RW (@ 0x40004414) Receiver timeout value </i>
//    <edit> 
//      <loc> ( (unsigned int)((USART2_RTOR >> 0) & 0xFFFFFF), ((USART2_RTOR = (USART2_RTOR & ~(0xFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: USART2_RTOR_BLEN  ----------------------------------
// SVD Line: 23361

//  <item> SFDITEM_FIELD__USART2_RTOR_BLEN
//    <name> BLEN </name>
//    <rw> 
//    <i> [Bits 31..24] RW (@ 0x40004414) Block Length </i>
//    <edit> 
//      <loc> ( (unsigned char)((USART2_RTOR >> 24) & 0xFF), ((USART2_RTOR = (USART2_RTOR & ~(0xFFUL << 24 )) | ((unsigned long)(Gui_u8:GuiVal & 0xFF) << 24 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_RTOR  ----------------------------------
// SVD Line: 23346

//  <rtree> SFDITEM_REG__USART2_RTOR
//    <name> RTOR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004414) Receiver timeout register </i>
//    <loc> ( (unsigned int)((USART2_RTOR >> 0) & 0xFFFFFFFF), ((USART2_RTOR = (USART2_RTOR & ~(0xFFFFFFFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFFFFFFFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_RTOR_RTO </item>
//    <item> SFDITEM_FIELD__USART2_RTOR_BLEN </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_RQR  -------------------------------
// SVD Line: 23369

unsigned int USART2_RQR __AT (0x40004418);



// ------------------------------  Field Item: USART2_RQR_ABRRQ  ----------------------------------
// SVD Line: 23378

//  <item> SFDITEM_FIELD__USART2_RQR_ABRRQ
//    <name> ABRRQ </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40004418) Auto baud rate request Writing 1 to this bit resets the ABRF flag in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_RQR ) </loc>
//      <o.0..0> ABRRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_RQR_SBKRQ  ----------------------------------
// SVD Line: 23387

//  <item> SFDITEM_FIELD__USART2_RQR_SBKRQ
//    <name> SBKRQ </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40004418) Send break request Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_RQR ) </loc>
//      <o.1..1> SBKRQ
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_RQR_MMRQ  ----------------------------------
// SVD Line: 23396

//  <item> SFDITEM_FIELD__USART2_RQR_MMRQ
//    <name> MMRQ </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40004418) Mute mode request Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_RQR ) </loc>
//      <o.2..2> MMRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_RQR_RXFRQ  ----------------------------------
// SVD Line: 23404

//  <item> SFDITEM_FIELD__USART2_RQR_RXFRQ
//    <name> RXFRQ </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40004418) Receive data flush request Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE. This enables to discard the received data without reading them, and avoid an overrun condition. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_RQR ) </loc>
//      <o.3..3> RXFRQ
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_RQR_TXFRQ  ----------------------------------
// SVD Line: 23413

//  <item> SFDITEM_FIELD__USART2_RQR_TXFRQ
//    <name> TXFRQ </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40004418) Transmit data flush request When FIFO mode is disabled, writing '1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_RQR ) </loc>
//      <o.4..4> TXFRQ
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: USART2_RQR  -----------------------------------
// SVD Line: 23369

//  <rtree> SFDITEM_REG__USART2_RQR
//    <name> RQR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40004418) Request register </i>
//    <loc> ( (unsigned int)((USART2_RQR >> 0) & 0xFFFFFFFF), ((USART2_RQR = (USART2_RQR & ~(0x1FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_RQR_ABRRQ </item>
//    <item> SFDITEM_FIELD__USART2_RQR_SBKRQ </item>
//    <item> SFDITEM_FIELD__USART2_RQR_MMRQ </item>
//    <item> SFDITEM_FIELD__USART2_RQR_RXFRQ </item>
//    <item> SFDITEM_FIELD__USART2_RQR_TXFRQ </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART2_ISR_FIFO_ENABLED  -------------------------
// SVD Line: 23425

unsigned int USART2_ISR_FIFO_ENABLED __AT (0x4000441C);



// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_PE  -----------------------------
// SVD Line: 23435

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_PE
//    <name> PE </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x4000441C) \nParity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No parity error\n1 : B_0x1 = Parity error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = No parity error
//        <1=> 1: B_0x1 = Parity error
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_FE  -----------------------------
// SVD Line: 23457

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_FE
//    <name> FE </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x4000441C) \nFraming error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE=1 in the USART_CR1 register. Note: This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No Framing error is detected\n1 : B_0x1 = Framing error or break character is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.1..1> FE
//        <0=> 0: B_0x0 = No Framing error is detected
//        <1=> 1: B_0x1 = Framing error or break character is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_NE  -----------------------------
// SVD Line: 23480

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_NE
//    <name> NE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x4000441C) \nNoise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page861). This error is associated with the character in the USART_RDR.\n0 : B_0x0 = No noise is detected\n1 : B_0x1 = Noise is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.2..2> NE
//        <0=> 0: B_0x0 = No noise is detected
//        <1=> 1: B_0x1 = Noise is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_ORE  ----------------------------
// SVD Line: 23503

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ORE
//    <name> ORE </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x4000441C) \nOverrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.\n0 : B_0x0 = No overrun error\n1 : B_0x1 = Overrun error is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.3..3> ORE
//        <0=> 0: B_0x0 = No overrun error
//        <1=> 1: B_0x1 = Overrun error is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_IDLE  ----------------------------
// SVD Line: 23527

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_IDLE
//    <name> IDLE </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x4000441C) \nIdle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n0 : B_0x0 = No Idle line is detected\n1 : B_0x1 = Idle line is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.4..4> IDLE
//        <0=> 0: B_0x0 = No Idle line is detected
//        <1=> 1: B_0x1 = Idle line is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_RXFNE  ---------------------------
// SVD Line: 23549

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFNE
//    <name> RXFNE </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x4000441C) \nRXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXFNEIE=1 in the USART_CR1 register.\n0 : B_0x0 = Data is not received\n1 : B_0x1 = Received data is ready to be read. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.5..5> RXFNE
//        <0=> 0: B_0x0 = Data is not received
//        <1=> 1: B_0x1 = Received data is ready to be read.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TC  -----------------------------
// SVD Line: 23571

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x4000441C) \nTransmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.\n0 : B_0x0 = Transmission is not complete\n1 : B_0x1 = Transmission is complete </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.6..6> TC
//        <0=> 0: B_0x0 = Transmission is not complete
//        <1=> 1: B_0x1 = Transmission is complete
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TXFNF  ---------------------------
// SVD Line: 23595

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFNF
//    <name> TXFNF </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x4000441C) \nTXFIFO not full TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register. Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time). This bit is used during single buffer transmission.\n0 : B_0x0 = Transmit FIFO is full\n1 : B_0x1 = Transmit FIFO is not full </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.7..7> TXFNF
//        <0=> 0: B_0x0 = Transmit FIFO is full
//        <1=> 1: B_0x1 = Transmit FIFO is not full
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_LBDF  ----------------------------
// SVD Line: 23618

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_LBDF
//    <name> LBDF </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x4000441C) \nLIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = LIN Break not detected\n1 : B_0x1 = LIN break detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.8..8> LBDF
//        <0=> 0: B_0x0 = LIN Break not detected
//        <1=> 1: B_0x1 = LIN break detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_CTSIF  ---------------------------
// SVD Line: 23640

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CTSIF
//    <name> CTSIF </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x4000441C) \nCTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE=1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = No change occurred on the nCTS status line\n1 : B_0x1 = A change occurred on the nCTS status line </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.9..9> CTSIF
//        <0=> 0: B_0x0 = No change occurred on the nCTS status line
//        <1=> 1: B_0x1 = A change occurred on the nCTS status line
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_CTS  ----------------------------
// SVD Line: 23662

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CTS
//    <name> CTS </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x4000441C) \nCTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = nCTS line set\n1 : B_0x1 = nCTS line reset </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.10..10> CTS
//        <0=> 0: B_0x0 = nCTS line set
//        <1=> 1: B_0x1 = nCTS line reset
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_RTOF  ----------------------------
// SVD Line: 23683

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RTOF
//    <name> RTOF </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x4000441C) \nReceiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE=1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.\n0 : B_0x0 = Timeout value not reached\n1 : B_0x1 = Timeout value reached without any data reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.11..11> RTOF
//        <0=> 0: B_0x0 = Timeout value not reached
//        <1=> 1: B_0x1 = Timeout value reached without any data reception
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_EOBF  ----------------------------
// SVD Line: 23708

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_EOBF
//    <name> EOBF </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x4000441C) \nEnd of block flag This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE=1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = End of Block not reached\n1 : B_0x1 = End of Block (number of characters) reached </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.12..12> EOBF
//        <0=> 0: B_0x0 = End of Block not reached
//        <1=> 1: B_0x1 = End of Block (number of characters) reached
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_UDR  ----------------------------
// SVD Line: 23731

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_UDR
//    <name> UDR </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x4000441C) \nSPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = No underrun error\n1 : B_0x1 = underrun error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.13..13> UDR
//        <0=> 0: B_0x0 = No underrun error
//        <1=> 1: B_0x1 = underrun error
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_ABRE  ----------------------------
// SVD Line: 23752

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ABRE
//    <name> ABRE </name>
//    <r> 
//    <i> [Bit 14] RO (@ 0x4000441C) Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.14..14> ABRE
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_ABRF  ----------------------------
// SVD Line: 23762

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ABRF
//    <name> ABRF </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x4000441C) Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.15..15> ABRF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_BUSY  ----------------------------
// SVD Line: 23772

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x4000441C) \nBusy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).\n0 : B_0x0 = USART is idle (no reception)\n1 : B_0x1 = Reception on going </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.16..16> BUSY
//        <0=> 0: B_0x0 = USART is idle (no reception)
//        <1=> 1: B_0x1 = Reception on going
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_CMF  ----------------------------
// SVD Line: 23792

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CMF
//    <name> CMF </name>
//    <r> 
//    <i> [Bit 17] RO (@ 0x4000441C) \nCharacter match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIE=1in the USART_CR1 register.\n0 : B_0x0 = No Character match detected\n1 : B_0x1 = Character Match detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.17..17> CMF
//        <0=> 0: B_0x0 = No Character match detected
//        <1=> 1: B_0x1 = Character Match detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_SBKF  ----------------------------
// SVD Line: 23813

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_SBKF
//    <name> SBKF </name>
//    <r> 
//    <i> [Bit 18] RO (@ 0x4000441C) \nSend break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.\n0 : B_0x0 = Break character transmitted\n1 : B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.18..18> SBKF
//        <0=> 0: B_0x0 = Break character transmitted
//        <1=> 1: B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_RWU  ----------------------------
// SVD Line: 23833

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RWU
//    <name> RWU </name>
//    <r> 
//    <i> [Bit 19] RO (@ 0x4000441C) \nReceiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = Receiver in active mode\n1 : B_0x1 = Receiver in Mute mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.19..19> RWU
//        <0=> 0: B_0x0 = Receiver in active mode
//        <1=> 1: B_0x1 = Receiver in Mute mode
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_ENABLED_WUF  ----------------------------
// SVD Line: 23855

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_WUF
//    <name> WUF </name>
//    <r> 
//    <i> [Bit 20] RO (@ 0x4000441C) Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE=1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.20..20> WUF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TEACK  ---------------------------
// SVD Line: 23866

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TEACK
//    <name> TEACK </name>
//    <r> 
//    <i> [Bit 21] RO (@ 0x4000441C) Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.21..21> TEACK
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_REACK  ---------------------------
// SVD Line: 23875

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_REACK
//    <name> REACK </name>
//    <r> 
//    <i> [Bit 22] RO (@ 0x4000441C) Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.22..22> REACK
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TXFE  ----------------------------
// SVD Line: 23885

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFE
//    <name> TXFE </name>
//    <r> 
//    <i> [Bit 23] RO (@ 0x4000441C) \nTXFIFO empty This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. An interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.\n0 : B_0x0 = TXFIFO not empty.\n1 : B_0x1 = TXFIFO empty. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.23..23> TXFE
//        <0=> 0: B_0x0 = TXFIFO not empty.
//        <1=> 1: B_0x1 = TXFIFO empty.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_RXFF  ----------------------------
// SVD Line: 23906

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFF
//    <name> RXFF </name>
//    <r> 
//    <i> [Bit 24] RO (@ 0x4000441C) \nRXFIFO full This bit is set by hardware when the number of received data corresponds to RXFIFOsize+1 (RXFIFO full + 1 data in the USART_RDR register. An interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.\n0 : B_0x0 = RXFIFO not full.\n1 : B_0x1 = RXFIFO Full. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.24..24> RXFF
//        <0=> 0: B_0x0 = RXFIFO not full.
//        <1=> 1: B_0x1 = RXFIFO Full.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TCBGT  ---------------------------
// SVD Line: 23927

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TCBGT
//    <name> TCBGT </name>
//    <r> 
//    <i> [Bit 25] RO (@ 0x4000441C) \nTransmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1. Refer to on page835.\n0 : B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)\n1 : B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.25..25> TCBGT
//        <0=> 0: B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)
//        <1=> 1: B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_RXFT  ----------------------------
// SVD Line: 23950

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFT
//    <name> RXFT </name>
//    <r> 
//    <i> [Bit 26] RO (@ 0x4000441C) \nRXFIFO threshold flag This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register. Note: When the RXFTCFG threshold is configured to '101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.\n0 : B_0x0 = Receive FIFO does not reach the programmed threshold.\n1 : B_0x1 = Receive FIFO reached the programmed threshold. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.26..26> RXFT
//        <0=> 0: B_0x0 = Receive FIFO does not reach the programmed threshold.
//        <1=> 1: B_0x1 = Receive FIFO reached the programmed threshold.
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_ENABLED_TXFT  ----------------------------
// SVD Line: 23971

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFT
//    <name> TXFT </name>
//    <r> 
//    <i> [Bit 27] RO (@ 0x4000441C) \nTXFIFO threshold flag This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.\n0 : B_0x0 = TXFIFO does not reach the programmed threshold.\n1 : B_0x1 = TXFIFO reached the programmed threshold. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_ENABLED ) </loc>
//      <o.27..27> TXFT
//        <0=> 0: B_0x0 = TXFIFO does not reach the programmed threshold.
//        <1=> 1: B_0x1 = TXFIFO reached the programmed threshold.
//    </combo>
//  </item>
//  


// -------------------------  Register RTree: USART2_ISR_FIFO_ENABLED  ----------------------------
// SVD Line: 23425

//  <rtree> SFDITEM_REG__USART2_ISR_FIFO_ENABLED
//    <name> ISR_FIFO_ENABLED </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000441C) Interrupt & status  register </i>
//    <loc> ( (unsigned int)((USART2_ISR_FIFO_ENABLED >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_PE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_FE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_NE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ORE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_IDLE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFNE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TC </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFNF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_LBDF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CTSIF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CTS </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RTOF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_EOBF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_UDR </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ABRE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_ABRF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_BUSY </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_CMF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_SBKF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RWU </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_WUF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TEACK </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_REACK </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TCBGT </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_RXFT </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_ENABLED_TXFT </item>
//  </rtree>
//  


// ---------------------  Register Item Address: USART2_ISR_FIFO_DISABLED  ------------------------
// SVD Line: 23993

unsigned int USART2_ISR_FIFO_DISABLED __AT (0x4000441C);



// -------------------------  Field Item: USART2_ISR_FIFO_DISABLED_PE  ----------------------------
// SVD Line: 24004

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_PE
//    <name> PE </name>
//    <r> 
//    <i> [Bit 0] RO (@ 0x4000441C) \nParity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0 : B_0x0 = No parity error\n1 : B_0x1 = Parity error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.0..0> PE
//        <0=> 0: B_0x0 = No parity error
//        <1=> 1: B_0x1 = Parity error
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_DISABLED_FE  ----------------------------
// SVD Line: 24025

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_FE
//    <name> FE </name>
//    <r> 
//    <i> [Bit 1] RO (@ 0x4000441C) \nFraming error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame). An interrupt is generated if EIE=1 in the USART_CR1 register.\n0 : B_0x0 = No Framing error is detected\n1 : B_0x1 = Framing error or break character is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.1..1> FE
//        <0=> 0: B_0x0 = No Framing error is detected
//        <1=> 1: B_0x1 = Framing error or break character is detected
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_DISABLED_NE  ----------------------------
// SVD Line: 24047

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_NE
//    <name> NE </name>
//    <r> 
//    <i> [Bit 2] RO (@ 0x4000441C) \nNoise detection flag This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page861).\n0 : B_0x0 = No noise is detected\n1 : B_0x1 = Noise is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.2..2> NE
//        <0=> 0: B_0x0 = No noise is detected
//        <1=> 1: B_0x1 = Noise is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_ORE  ----------------------------
// SVD Line: 24069

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ORE
//    <name> ORE </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x4000441C) \nOverrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXNEIE=1 or EIE = 1 in the USART_CR1 register. Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.\n0 : B_0x0 = No overrun error\n1 : B_0x1 = Overrun error is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.3..3> ORE
//        <0=> 0: B_0x0 = No overrun error
//        <1=> 1: B_0x1 = Overrun error is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_IDLE  ---------------------------
// SVD Line: 24093

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_IDLE
//    <name> IDLE </name>
//    <r> 
//    <i> [Bit 4] RO (@ 0x4000441C) \nIdle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register. Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n0 : B_0x0 = No Idle line is detected\n1 : B_0x1 = Idle line is detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.4..4> IDLE
//        <0=> 0: B_0x0 = No Idle line is detected
//        <1=> 1: B_0x1 = Idle line is detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_RXNE  ---------------------------
// SVD Line: 24115

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RXNE
//    <name> RXNE </name>
//    <r> 
//    <i> [Bit 5] RO (@ 0x4000441C) \nRead data register not empty RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXNEIE=1 in the USART_CR1 register.\n0 : B_0x0 = Data is not received\n1 : B_0x1 = Received data is ready to be read. </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.5..5> RXNE
//        <0=> 0: B_0x0 = Data is not received
//        <1=> 1: B_0x1 = Received data is ready to be read.
//    </combo>
//  </item>
//  


// -------------------------  Field Item: USART2_ISR_FIFO_DISABLED_TC  ----------------------------
// SVD Line: 24136

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TC
//    <name> TC </name>
//    <r> 
//    <i> [Bit 6] RO (@ 0x4000441C) \nTransmission complete This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.\n0 : B_0x0 = Transmission is not complete\n1 : B_0x1 = Transmission is complete </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.6..6> TC
//        <0=> 0: B_0x0 = Transmission is not complete
//        <1=> 1: B_0x1 = Transmission is complete
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_TXE  ----------------------------
// SVD Line: 24160

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TXE
//    <name> TXE </name>
//    <r> 
//    <i> [Bit 7] RO (@ 0x4000441C) \nTransmit data register empty TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T=0 mode, in case of transmission failure). An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.\n0 : B_0x0 = Data register full\n1 : B_0x1 = Data register not full </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.7..7> TXE
//        <0=> 0: B_0x0 = Data register full
//        <1=> 1: B_0x1 = Data register not full
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_LBDF  ---------------------------
// SVD Line: 24181

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_LBDF
//    <name> LBDF </name>
//    <r> 
//    <i> [Bit 8] RO (@ 0x4000441C) \nLIN break detection flag This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = LIN Break not detected\n1 : B_0x1 = LIN break detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.8..8> LBDF
//        <0=> 0: B_0x0 = LIN Break not detected
//        <1=> 1: B_0x1 = LIN break detected
//    </combo>
//  </item>
//  


// -----------------------  Field Item: USART2_ISR_FIFO_DISABLED_CTSIF  ---------------------------
// SVD Line: 24203

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CTSIF
//    <name> CTSIF </name>
//    <r> 
//    <i> [Bit 9] RO (@ 0x4000441C) \nCTS interrupt flag This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE=1 in the USART_CR3 register. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = No change occurred on the nCTS status line\n1 : B_0x1 = A change occurred on the nCTS status line </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.9..9> CTSIF
//        <0=> 0: B_0x0 = No change occurred on the nCTS status line
//        <1=> 1: B_0x1 = A change occurred on the nCTS status line
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_CTS  ----------------------------
// SVD Line: 24225

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CTS
//    <name> CTS </name>
//    <r> 
//    <i> [Bit 10] RO (@ 0x4000441C) \nCTS flag This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin. Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.\n0 : B_0x0 = nCTS line set\n1 : B_0x1 = nCTS line reset </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.10..10> CTS
//        <0=> 0: B_0x0 = nCTS line set
//        <1=> 1: B_0x1 = nCTS line reset
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_RTOF  ---------------------------
// SVD Line: 24246

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RTOF
//    <name> RTOF </name>
//    <r> 
//    <i> [Bit 11] RO (@ 0x4000441C) \nReceiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE=1 in the USART_CR2 register. In Smartcard mode, the timeout corresponds to the CWT or BWT timings. Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.\n0 : B_0x0 = Timeout value not reached\n1 : B_0x1 = Timeout value reached without any data reception </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.11..11> RTOF
//        <0=> 0: B_0x0 = Timeout value not reached
//        <1=> 1: B_0x1 = Timeout value reached without any data reception
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_EOBF  ---------------------------
// SVD Line: 24271

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_EOBF
//    <name> EOBF </name>
//    <r> 
//    <i> [Bit 12] RO (@ 0x4000441C) \nEnd of block flag This bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE=1 in the USART_CR2 register. It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = End of Block not reached\n1 : B_0x1 = End of Block (number of characters) reached </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.12..12> EOBF
//        <0=> 0: B_0x0 = End of Block not reached
//        <1=> 1: B_0x1 = End of Block (number of characters) reached
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_UDR  ----------------------------
// SVD Line: 24294

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_UDR
//    <name> UDR </name>
//    <r> 
//    <i> [Bit 13] RO (@ 0x4000441C) \nSPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = No underrun error\n1 : B_0x1 = underrun error </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.13..13> UDR
//        <0=> 0: B_0x0 = No underrun error
//        <1=> 1: B_0x1 = underrun error
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_ABRE  ---------------------------
// SVD Line: 24315

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ABRE
//    <name> ABRE </name>
//    <r> 
//    <i> [Bit 14] RO (@ 0x4000441C) Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.14..14> ABRE
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_ABRF  ---------------------------
// SVD Line: 24325

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ABRF
//    <name> ABRF </name>
//    <r> 
//    <i> [Bit 15] RO (@ 0x4000441C) Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.15..15> ABRF
//    </check>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_BUSY  ---------------------------
// SVD Line: 24335

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_BUSY
//    <name> BUSY </name>
//    <r> 
//    <i> [Bit 16] RO (@ 0x4000441C) \nBusy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).\n0 : B_0x0 = USART is idle (no reception)\n1 : B_0x1 = Reception on going </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.16..16> BUSY
//        <0=> 0: B_0x0 = USART is idle (no reception)
//        <1=> 1: B_0x1 = Reception on going
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_CMF  ----------------------------
// SVD Line: 24355

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CMF
//    <name> CMF </name>
//    <r> 
//    <i> [Bit 17] RO (@ 0x4000441C) \nCharacter match flag This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register. An interrupt is generated if CMIE=1in the USART_CR1 register.\n0 : B_0x0 = No Character match detected\n1 : B_0x1 = Character Match detected </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.17..17> CMF
//        <0=> 0: B_0x0 = No Character match detected
//        <1=> 1: B_0x1 = Character Match detected
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_SBKF  ---------------------------
// SVD Line: 24376

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_SBKF
//    <name> SBKF </name>
//    <r> 
//    <i> [Bit 18] RO (@ 0x4000441C) \nSend break flag This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.\n0 : B_0x0 = Break character transmitted\n1 : B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.18..18> SBKF
//        <0=> 0: B_0x0 = Break character transmitted
//        <1=> 1: B_0x1 = Break character requested by setting SBKRQ bit in USART_RQR register
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_RWU  ----------------------------
// SVD Line: 24396

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RWU
//    <name> RWU </name>
//    <r> 
//    <i> [Bit 19] RO (@ 0x4000441C) \nReceiver wakeup from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .\n0 : B_0x0 = Receiver in active mode\n1 : B_0x1 = Receiver in Mute mode </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.19..19> RWU
//        <0=> 0: B_0x0 = Receiver in active mode
//        <1=> 1: B_0x1 = Receiver in Mute mode
//    </combo>
//  </item>
//  


// ------------------------  Field Item: USART2_ISR_FIFO_DISABLED_WUF  ----------------------------
// SVD Line: 24418

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_WUF
//    <name> WUF </name>
//    <r> 
//    <i> [Bit 20] RO (@ 0x4000441C) Wakeup from low-power mode flag This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE=1 in the USART_CR3 register. Note: When UESM is cleared, WUF flag is also cleared. If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.20..20> WUF
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART2_ISR_FIFO_DISABLED_TEACK  ---------------------------
// SVD Line: 24429

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TEACK
//    <name> TEACK </name>
//    <r> 
//    <i> [Bit 21] RO (@ 0x4000441C) Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.21..21> TEACK
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART2_ISR_FIFO_DISABLED_REACK  ---------------------------
// SVD Line: 24438

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_REACK
//    <name> REACK </name>
//    <r> 
//    <i> [Bit 22] RO (@ 0x4000441C) Receive enable acknowledge flag This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.22..22> REACK
//    </check>
//  </item>
//  


// -----------------------  Field Item: USART2_ISR_FIFO_DISABLED_TCBGT  ---------------------------
// SVD Line: 24448

//  <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TCBGT
//    <name> TCBGT </name>
//    <r> 
//    <i> [Bit 25] RO (@ 0x4000441C) \nTransmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1. Refer to on page835.\n0 : B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)\n1 : B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card). </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_ISR_FIFO_DISABLED ) </loc>
//      <o.25..25> TCBGT
//        <0=> 0: B_0x0 = Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)
//        <1=> 1: B_0x1 = Transmission is complete successfully (before Guard time completion and there is no NACK from the smart card).
//    </combo>
//  </item>
//  


// ------------------------  Register RTree: USART2_ISR_FIFO_DISABLED  ----------------------------
// SVD Line: 23993

//  <rtree> SFDITEM_REG__USART2_ISR_FIFO_DISABLED
//    <name> ISR_FIFO_DISABLED </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x4000441C) Interrupt & status  register </i>
//    <loc> ( (unsigned int)((USART2_ISR_FIFO_DISABLED >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_PE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_FE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_NE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ORE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_IDLE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RXNE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TC </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TXE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_LBDF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CTSIF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CTS </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RTOF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_EOBF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_UDR </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ABRE </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_ABRF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_BUSY </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_CMF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_SBKF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_RWU </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_WUF </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TEACK </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_REACK </item>
//    <item> SFDITEM_FIELD__USART2_ISR_FIFO_DISABLED_TCBGT </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_ICR  -------------------------------
// SVD Line: 24473

unsigned int USART2_ICR __AT (0x40004420);



// -------------------------------  Field Item: USART2_ICR_PECF  ----------------------------------
// SVD Line: 24482

//  <item> SFDITEM_FIELD__USART2_ICR_PECF
//    <name> PECF </name>
//    <w> 
//    <i> [Bit 0] WO (@ 0x40004420) Parity error clear flag Writing 1 to this bit clears the PE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.0..0> PECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_ICR_FECF  ----------------------------------
// SVD Line: 24490

//  <item> SFDITEM_FIELD__USART2_ICR_FECF
//    <name> FECF </name>
//    <w> 
//    <i> [Bit 1] WO (@ 0x40004420) Framing error clear flag Writing 1 to this bit clears the FE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.1..1> FECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_ICR_NECF  ----------------------------------
// SVD Line: 24498

//  <item> SFDITEM_FIELD__USART2_ICR_NECF
//    <name> NECF </name>
//    <w> 
//    <i> [Bit 2] WO (@ 0x40004420) Noise detected clear flag Writing 1 to this bit clears the NE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.2..2> NECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_ORECF  ----------------------------------
// SVD Line: 24506

//  <item> SFDITEM_FIELD__USART2_ICR_ORECF
//    <name> ORECF </name>
//    <w> 
//    <i> [Bit 3] WO (@ 0x40004420) Overrun error clear flag Writing 1 to this bit clears the ORE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.3..3> ORECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_IDLECF  ---------------------------------
// SVD Line: 24514

//  <item> SFDITEM_FIELD__USART2_ICR_IDLECF
//    <name> IDLECF </name>
//    <w> 
//    <i> [Bit 4] WO (@ 0x40004420) Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.4..4> IDLECF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_TXFECF  ---------------------------------
// SVD Line: 24522

//  <item> SFDITEM_FIELD__USART2_ICR_TXFECF
//    <name> TXFECF </name>
//    <w> 
//    <i> [Bit 5] WO (@ 0x40004420) TXFIFO empty clear flag Writing 1 to this bit clears the TXFE flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.5..5> TXFECF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_ICR_TCCF  ----------------------------------
// SVD Line: 24530

//  <item> SFDITEM_FIELD__USART2_ICR_TCCF
//    <name> TCCF </name>
//    <w> 
//    <i> [Bit 6] WO (@ 0x40004420) Transmission complete clear flag Writing 1 to this bit clears the TC flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.6..6> TCCF
//    </check>
//  </item>
//  


// -----------------------------  Field Item: USART2_ICR_TCBGTCF  ---------------------------------
// SVD Line: 24538

//  <item> SFDITEM_FIELD__USART2_ICR_TCBGTCF
//    <name> TCBGTCF </name>
//    <w> 
//    <i> [Bit 7] WO (@ 0x40004420) Transmission complete before Guard time clear flag Writing 1 to this bit clears the TCBGT flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.7..7> TCBGTCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_LBDCF  ----------------------------------
// SVD Line: 24546

//  <item> SFDITEM_FIELD__USART2_ICR_LBDCF
//    <name> LBDCF </name>
//    <w> 
//    <i> [Bit 8] WO (@ 0x40004420) LIN break detection clear flag Writing 1 to this bit clears the LBDF flag in the USART_ISR register. Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.8..8> LBDCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_CTSCF  ----------------------------------
// SVD Line: 24555

//  <item> SFDITEM_FIELD__USART2_ICR_CTSCF
//    <name> CTSCF </name>
//    <w> 
//    <i> [Bit 9] WO (@ 0x40004420) CTS clear flag Writing 1 to this bit clears the CTSIF flag in the USART_ISR register. Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.9..9> CTSCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_RTOCF  ----------------------------------
// SVD Line: 24564

//  <item> SFDITEM_FIELD__USART2_ICR_RTOCF
//    <name> RTOCF </name>
//    <w> 
//    <i> [Bit 11] WO (@ 0x40004420) Receiver timeout clear flag Writing 1 to this bit clears the RTOF flag in the USART_ISR register. Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page835. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.11..11> RTOCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_EOBCF  ----------------------------------
// SVD Line: 24573

//  <item> SFDITEM_FIELD__USART2_ICR_EOBCF
//    <name> EOBCF </name>
//    <w> 
//    <i> [Bit 12] WO (@ 0x40004420) End of block clear flag Writing 1 to this bit clears the EOBF flag in the USART_ISR register. Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to . </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.12..12> EOBCF
//    </check>
//  </item>
//  


// ------------------------------  Field Item: USART2_ICR_UDRCF  ----------------------------------
// SVD Line: 24582

//  <item> SFDITEM_FIELD__USART2_ICR_UDRCF
//    <name> UDRCF </name>
//    <w> 
//    <i> [Bit 13] WO (@ 0x40004420) SPI slave underrun clear flag Writing 1 to this bit clears the UDRF flag in the USART_ISR register. Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.13..13> UDRCF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_ICR_CMCF  ----------------------------------
// SVD Line: 24591

//  <item> SFDITEM_FIELD__USART2_ICR_CMCF
//    <name> CMCF </name>
//    <w> 
//    <i> [Bit 17] WO (@ 0x40004420) Character match clear flag Writing 1 to this bit clears the CMF flag in the USART_ISR register. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.17..17> CMCF
//    </check>
//  </item>
//  


// -------------------------------  Field Item: USART2_ICR_WUCF  ----------------------------------
// SVD Line: 24599

//  <item> SFDITEM_FIELD__USART2_ICR_WUCF
//    <name> WUCF </name>
//    <w> 
//    <i> [Bit 20] WO (@ 0x40004420) Wakeup from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835. </i>
//    <check> 
//      <loc> ( (unsigned int) USART2_ICR ) </loc>
//      <o.20..20> WUCF
//    </check>
//  </item>
//  


// -------------------------------  Register RTree: USART2_ICR  -----------------------------------
// SVD Line: 24473

//  <rtree> SFDITEM_REG__USART2_ICR
//    <name> ICR </name>
//    <w> 
//    <i> [Bits 31..0] WO (@ 0x40004420) Interrupt flag clear register </i>
//    <loc> ( (unsigned int)((USART2_ICR >> 0) & 0xFFFFFFFF), ((USART2_ICR = (USART2_ICR & ~(0x123BFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x123BFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_ICR_PECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_FECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_NECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_ORECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_IDLECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_TXFECF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_TCCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_TCBGTCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_LBDCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_CTSCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_RTOCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_EOBCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_UDRCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_CMCF </item>
//    <item> SFDITEM_FIELD__USART2_ICR_WUCF </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_RDR  -------------------------------
// SVD Line: 24610

unsigned int USART2_RDR __AT (0x40004424);



// -------------------------------  Field Item: USART2_RDR_RDR  -----------------------------------
// SVD Line: 24619

//  <item> SFDITEM_FIELD__USART2_RDR_RDR
//    <name> RDR </name>
//    <r> 
//    <i> [Bits 8..0] RO (@ 0x40004424) Receive data value </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART2_RDR >> 0) & 0x1FF) ) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_RDR  -----------------------------------
// SVD Line: 24610

//  <rtree> SFDITEM_REG__USART2_RDR
//    <name> RDR </name>
//    <r> 
//    <i> [Bits 31..0] RO (@ 0x40004424) Receive data register </i>
//    <loc> ( (unsigned int)((USART2_RDR >> 0) & 0xFFFFFFFF) ) </loc>
//    <item> SFDITEM_FIELD__USART2_RDR_RDR </item>
//  </rtree>
//  


// ----------------------------  Register Item Address: USART2_TDR  -------------------------------
// SVD Line: 24627

unsigned int USART2_TDR __AT (0x40004428);



// -------------------------------  Field Item: USART2_TDR_TDR  -----------------------------------
// SVD Line: 24636

//  <item> SFDITEM_FIELD__USART2_TDR_TDR
//    <name> TDR </name>
//    <rw> 
//    <i> [Bits 8..0] RW (@ 0x40004428) Transmit data value </i>
//    <edit> 
//      <loc> ( (unsigned short)((USART2_TDR >> 0) & 0x1FF), ((USART2_TDR = (USART2_TDR & ~(0x1FFUL << 0 )) | ((unsigned long)(Gui_u16:GuiVal & 0x1FF) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// -------------------------------  Register RTree: USART2_TDR  -----------------------------------
// SVD Line: 24627

//  <rtree> SFDITEM_REG__USART2_TDR
//    <name> TDR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40004428) Transmit data register </i>
//    <loc> ( (unsigned int)((USART2_TDR >> 0) & 0xFFFFFFFF), ((USART2_TDR = (USART2_TDR & ~(0x1FFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1FF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_TDR_TDR </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: USART2_PRESC  ------------------------------
// SVD Line: 24644

unsigned int USART2_PRESC __AT (0x4000442C);



// ---------------------------  Field Item: USART2_PRESC_PRESCALER  -------------------------------
// SVD Line: 24653

//  <item> SFDITEM_FIELD__USART2_PRESC_PRESCALER
//    <name> PRESCALER </name>
//    <rw> 
//    <i> [Bits 3..0] RW (@ 0x4000442C) \nClock prescaler The USART input clock can be divided by a prescaler factor: Remaining combinations: Reserved Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.\n0 : B_0x0 = input clock not divided\n1 : B_0x1 = input clock divided by 2\n2 : B_0x2 = input clock divided by 4\n3 : B_0x3 = input clock divided by 6\n4 : B_0x4 = input clock divided by 8\n5 : B_0x5 = input clock divided by 10\n6 : B_0x6 = input clock divided by 12\n7 : B_0x7 = input clock divided by 16\n8 : B_0x8 = input clock divided by 32\n9 : B_0x9 = input clock divided by 64\n10 : B_0xA = input clock divided by 128\n11 : B_0xB = input clock divided by 256\n12 : Reserved - do not use\n13 : Reserved - do not use\n14 : Reserved - do not use\n15 : Reserved - do not use </i>
//    <combo> 
//      <loc> ( (unsigned int) USART2_PRESC ) </loc>
//      <o.3..0> PRESCALER
//        <0=> 0: B_0x0 = input clock not divided
//        <1=> 1: B_0x1 = input clock divided by 2
//        <2=> 2: B_0x2 = input clock divided by 4
//        <3=> 3: B_0x3 = input clock divided by 6
//        <4=> 4: B_0x4 = input clock divided by 8
//        <5=> 5: B_0x5 = input clock divided by 10
//        <6=> 6: B_0x6 = input clock divided by 12
//        <7=> 7: B_0x7 = input clock divided by 16
//        <8=> 8: B_0x8 = input clock divided by 32
//        <9=> 9: B_0x9 = input clock divided by 64
//        <10=> 10: B_0xA = input clock divided by 128
//        <11=> 11: B_0xB = input clock divided by 256
//        <12=> 12: 
//        <13=> 13: 
//        <14=> 14: 
//        <15=> 15: 
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: USART2_PRESC  ----------------------------------
// SVD Line: 24644

//  <rtree> SFDITEM_REG__USART2_PRESC
//    <name> PRESC </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x4000442C) Prescaler register </i>
//    <loc> ( (unsigned int)((USART2_PRESC >> 0) & 0xFFFFFFFF), ((USART2_PRESC = (USART2_PRESC & ~(0xFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__USART2_PRESC_PRESCALER </item>
//  </rtree>
//  


// ---------------------------------  Peripheral View: USART2  ------------------------------------
// SVD Line: 24729

//  <view> USART2
//    <name> USART2 </name>
//    <item> SFDITEM_REG__USART2_CR1_FIFO_ENABLED </item>
//    <item> SFDITEM_REG__USART2_CR1_FIFO_DISABLED </item>
//    <item> SFDITEM_REG__USART2_CR2 </item>
//    <item> SFDITEM_REG__USART2_CR3 </item>
//    <item> SFDITEM_REG__USART2_BRR </item>
//    <item> SFDITEM_REG__USART2_GTPR </item>
//    <item> SFDITEM_REG__USART2_RTOR </item>
//    <item> SFDITEM_REG__USART2_RQR </item>
//    <item> SFDITEM_REG__USART2_ISR_FIFO_ENABLED </item>
//    <item> SFDITEM_REG__USART2_ISR_FIFO_DISABLED </item>
//    <item> SFDITEM_REG__USART2_ICR </item>
//    <item> SFDITEM_REG__USART2_RDR </item>
//    <item> SFDITEM_REG__USART2_TDR </item>
//    <item> SFDITEM_REG__USART2_PRESC </item>
//  </view>
//  


// -----------------------  Register Item Address: VREFBUF_VREFBUF_CSR  ---------------------------
// SVD Line: 24749

unsigned int VREFBUF_VREFBUF_CSR __AT (0x40010030);



// --------------------------  Field Item: VREFBUF_VREFBUF_CSR_ENVR  ------------------------------
// SVD Line: 24758

//  <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_ENVR
//    <name> ENVR </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40010030) \nVoltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.\n0 : B_0x0 = Internal voltage reference mode disable (external voltage reference mode).\n1 : B_0x1 = Internal voltage reference mode (reference buffer enable or hold mode) enable. </i>
//    <combo> 
//      <loc> ( (unsigned int) VREFBUF_VREFBUF_CSR ) </loc>
//      <o.0..0> ENVR
//        <0=> 0: B_0x0 = Internal voltage reference mode disable (external voltage reference mode).
//        <1=> 1: B_0x1 = Internal voltage reference mode (reference buffer enable or hold mode) enable.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: VREFBUF_VREFBUF_CSR_HIZ  ------------------------------
// SVD Line: 24778

//  <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_HIZ
//    <name> HIZ </name>
//    <rw> 
//    <i> [Bit 1] RW (@ 0x40010030) \nHigh impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to for the mode descriptions depending on ENVR bit configuration.\n0 : B_0x0 = VREF+ pin is internally connected to the voltage reference buffer output.\n1 : B_0x1 = VREF+ pin is high impedance. </i>
//    <combo> 
//      <loc> ( (unsigned int) VREFBUF_VREFBUF_CSR ) </loc>
//      <o.1..1> HIZ
//        <0=> 0: B_0x0 = VREF+ pin is internally connected to the voltage reference buffer output.
//        <1=> 1: B_0x1 = VREF+ pin is high impedance.
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: VREFBUF_VREFBUF_CSR_VRS  ------------------------------
// SVD Line: 24799

//  <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_VRS
//    <name> VRS </name>
//    <rw> 
//    <i> [Bit 2] RW (@ 0x40010030) \nVoltage reference scale This bit selects the value generated by the voltage reference buffer.\n0 : B_0x0 = Voltage reference set to VREF_OUT1 (around 2.048 V).\n1 : B_0x1 = Voltage reference set to VREF_OUT2 (around 2.5 V). </i>
//    <combo> 
//      <loc> ( (unsigned int) VREFBUF_VREFBUF_CSR ) </loc>
//      <o.2..2> VRS
//        <0=> 0: B_0x0 = Voltage reference set to VREF_OUT1 (around 2.048 V).
//        <1=> 1: B_0x1 = Voltage reference set to VREF_OUT2 (around 2.5 V).
//    </combo>
//  </item>
//  


// ---------------------------  Field Item: VREFBUF_VREFBUF_CSR_VRR  ------------------------------
// SVD Line: 24819

//  <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_VRR
//    <name> VRR </name>
//    <r> 
//    <i> [Bit 3] RO (@ 0x40010030) \nVoltage reference buffer ready\n0 : B_0x0 = the voltage reference buffer output is not ready.\n1 : B_0x1 = the voltage reference buffer output reached the requested level. </i>
//    <combo> 
//      <loc> ( (unsigned int) VREFBUF_VREFBUF_CSR ) </loc>
//      <o.3..3> VRR
//        <0=> 0: B_0x0 = the voltage reference buffer output is not ready.
//        <1=> 1: B_0x1 = the voltage reference buffer output reached the requested level.
//    </combo>
//  </item>
//  


// ---------------------------  Register RTree: VREFBUF_VREFBUF_CSR  ------------------------------
// SVD Line: 24749

//  <rtree> SFDITEM_REG__VREFBUF_VREFBUF_CSR
//    <name> VREFBUF_CSR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40010030) VREFBUF control and status  register </i>
//    <loc> ( (unsigned int)((VREFBUF_VREFBUF_CSR >> 0) & 0xFFFFFFFF), ((VREFBUF_VREFBUF_CSR = (VREFBUF_VREFBUF_CSR & ~(0x7UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x7) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_ENVR </item>
//    <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_HIZ </item>
//    <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_VRS </item>
//    <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CSR_VRR </item>
//  </rtree>
//  


// -----------------------  Register Item Address: VREFBUF_VREFBUF_CCR  ---------------------------
// SVD Line: 24840

unsigned int VREFBUF_VREFBUF_CCR __AT (0x40010034);



// --------------------------  Field Item: VREFBUF_VREFBUF_CCR_TRIM  ------------------------------
// SVD Line: 24850

//  <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CCR_TRIM
//    <name> TRIM </name>
//    <rw> 
//    <i> [Bits 5..0] RW (@ 0x40010034) Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage. </i>
//    <edit> 
//      <loc> ( (unsigned char)((VREFBUF_VREFBUF_CCR >> 0) & 0x3F), ((VREFBUF_VREFBUF_CCR = (VREFBUF_VREFBUF_CCR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ---------------------------  Register RTree: VREFBUF_VREFBUF_CCR  ------------------------------
// SVD Line: 24840

//  <rtree> SFDITEM_REG__VREFBUF_VREFBUF_CCR
//    <name> VREFBUF_CCR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40010034) VREFBUF calibration control  register </i>
//    <loc> ( (unsigned int)((VREFBUF_VREFBUF_CCR >> 0) & 0xFFFFFFFF), ((VREFBUF_VREFBUF_CCR = (VREFBUF_VREFBUF_CCR & ~(0x3FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__VREFBUF_VREFBUF_CCR_TRIM </item>
//  </rtree>
//  


// --------------------------------  Peripheral View: VREFBUF  ------------------------------------
// SVD Line: 24738

//  <view> VREFBUF
//    <name> VREFBUF </name>
//    <item> SFDITEM_REG__VREFBUF_VREFBUF_CSR </item>
//    <item> SFDITEM_REG__VREFBUF_VREFBUF_CCR </item>
//  </view>
//  


// ---------------------------  Register Item Address: WWDG_WWDG_CR  ------------------------------
// SVD Line: 24878

unsigned int WWDG_WWDG_CR __AT (0x40002C00);



// -------------------------------  Field Item: WWDG_WWDG_CR_T  -----------------------------------
// SVD Line: 24887

//  <item> SFDITEM_FIELD__WWDG_WWDG_CR_T
//    <name> T </name>
//    <rw> 
//    <i> [Bits 6..0] RW (@ 0x40002C00) 7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter, decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared). </i>
//    <edit> 
//      <loc> ( (unsigned char)((WWDG_WWDG_CR >> 0) & 0x7F), ((WWDG_WWDG_CR = (WWDG_WWDG_CR & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: WWDG_WWDG_CR_WDGA  ---------------------------------
// SVD Line: 24896

//  <item> SFDITEM_FIELD__WWDG_WWDG_CR_WDGA
//    <name> WDGA </name>
//    <rw> 
//    <i> [Bit 7] RW (@ 0x40002C00) \nActivation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.\n0 : B_0x0 = Watchdog disabled\n1 : B_0x1 = Watchdog enabled </i>
//    <combo> 
//      <loc> ( (unsigned int) WWDG_WWDG_CR ) </loc>
//      <o.7..7> WDGA
//        <0=> 0: B_0x0 = Watchdog disabled
//        <1=> 1: B_0x1 = Watchdog enabled
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: WWDG_WWDG_CR  ----------------------------------
// SVD Line: 24878

//  <rtree> SFDITEM_REG__WWDG_WWDG_CR
//    <name> WWDG_CR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002C00) Control register </i>
//    <loc> ( (unsigned int)((WWDG_WWDG_CR >> 0) & 0xFFFFFFFF), ((WWDG_WWDG_CR = (WWDG_WWDG_CR & ~(0xFFUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0xFF) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__WWDG_WWDG_CR_T </item>
//    <item> SFDITEM_FIELD__WWDG_WWDG_CR_WDGA </item>
//  </rtree>
//  


// --------------------------  Register Item Address: WWDG_WWDG_CFR  ------------------------------
// SVD Line: 24918

unsigned int WWDG_WWDG_CFR __AT (0x40002C04);



// -------------------------------  Field Item: WWDG_WWDG_CFR_W  ----------------------------------
// SVD Line: 24927

//  <item> SFDITEM_FIELD__WWDG_WWDG_CFR_W
//    <name> W </name>
//    <rw> 
//    <i> [Bits 6..0] RW (@ 0x40002C04) 7-bit window value These bits contain the window value to be compared with the down-counter. </i>
//    <edit> 
//      <loc> ( (unsigned char)((WWDG_WWDG_CFR >> 0) & 0x7F), ((WWDG_WWDG_CFR = (WWDG_WWDG_CFR & ~(0x7FUL << 0 )) | ((unsigned long)(Gui_u8:GuiVal & 0x7F) << 0 ) ) )) </loc>
//    </edit>
//  </item>
//  


// ------------------------------  Field Item: WWDG_WWDG_CFR_EWI  ---------------------------------
// SVD Line: 24935

//  <item> SFDITEM_FIELD__WWDG_WWDG_CFR_EWI
//    <name> EWI </name>
//    <rw> 
//    <i> [Bit 9] RW (@ 0x40002C04) Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. </i>
//    <check> 
//      <loc> ( (unsigned int) WWDG_WWDG_CFR ) </loc>
//      <o.9..9> EWI
//    </check>
//  </item>
//  


// -----------------------------  Field Item: WWDG_WWDG_CFR_WDGTB  --------------------------------
// SVD Line: 24943

//  <item> SFDITEM_FIELD__WWDG_WWDG_CFR_WDGTB
//    <name> WDGTB </name>
//    <rw> 
//    <i> [Bits 13..11] RW (@ 0x40002C04) \nTimer base The timebase of the prescaler can be modified as follows:\n0 : B_0x0 = CK Counter Clock (PCLK div 4096) div 1\n1 : B_0x1 = CK Counter Clock (PCLK div 4096) div 2\n2 : B_0x2 = CK Counter Clock (PCLK div 4096) div 4\n3 : B_0x3 = CK Counter Clock (PCLK div 4096) div 8\n4 : B_0x4 = CK Counter Clock (PCLK div 4096) div 16\n5 : B_0x5 = CK Counter Clock (PCLK div 4096) div 32\n6 : B_0x6 = CK Counter Clock (PCLK div 4096) div 64\n7 : B_0x7 = CK Counter Clock (PCLK div 4096) div 128 </i>
//    <combo> 
//      <loc> ( (unsigned int) WWDG_WWDG_CFR ) </loc>
//      <o.13..11> WDGTB
//        <0=> 0: B_0x0 = CK Counter Clock (PCLK div 4096) div 1
//        <1=> 1: B_0x1 = CK Counter Clock (PCLK div 4096) div 2
//        <2=> 2: B_0x2 = CK Counter Clock (PCLK div 4096) div 4
//        <3=> 3: B_0x3 = CK Counter Clock (PCLK div 4096) div 8
//        <4=> 4: B_0x4 = CK Counter Clock (PCLK div 4096) div 16
//        <5=> 5: B_0x5 = CK Counter Clock (PCLK div 4096) div 32
//        <6=> 6: B_0x6 = CK Counter Clock (PCLK div 4096) div 64
//        <7=> 7: B_0x7 = CK Counter Clock (PCLK div 4096) div 128
//    </combo>
//  </item>
//  


// ------------------------------  Register RTree: WWDG_WWDG_CFR  ---------------------------------
// SVD Line: 24918

//  <rtree> SFDITEM_REG__WWDG_WWDG_CFR
//    <name> WWDG_CFR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002C04) Configuration register </i>
//    <loc> ( (unsigned int)((WWDG_WWDG_CFR >> 0) & 0xFFFFFFFF), ((WWDG_WWDG_CFR = (WWDG_WWDG_CFR & ~(0x3A7FUL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x3A7F) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__WWDG_WWDG_CFR_W </item>
//    <item> SFDITEM_FIELD__WWDG_WWDG_CFR_EWI </item>
//    <item> SFDITEM_FIELD__WWDG_WWDG_CFR_WDGTB </item>
//  </rtree>
//  


// ---------------------------  Register Item Address: WWDG_WWDG_SR  ------------------------------
// SVD Line: 24995

unsigned int WWDG_WWDG_SR __AT (0x40002C08);



// ------------------------------  Field Item: WWDG_WWDG_SR_EWIF  ---------------------------------
// SVD Line: 25004

//  <item> SFDITEM_FIELD__WWDG_WWDG_SR_EWIF
//    <name> EWIF </name>
//    <rw> 
//    <i> [Bit 0] RW (@ 0x40002C08) Early wakeup interrupt  flag </i>
//    <check> 
//      <loc> ( (unsigned int) WWDG_WWDG_SR ) </loc>
//      <o.0..0> EWIF
//    </check>
//  </item>
//  


// ------------------------------  Register RTree: WWDG_WWDG_SR  ----------------------------------
// SVD Line: 24995

//  <rtree> SFDITEM_REG__WWDG_WWDG_SR
//    <name> WWDG_SR </name>
//    <rw> 
//    <i> [Bits 31..0] RW (@ 0x40002C08) Status register </i>
//    <loc> ( (unsigned int)((WWDG_WWDG_SR >> 0) & 0xFFFFFFFF), ((WWDG_WWDG_SR = (WWDG_WWDG_SR & ~(0x1UL << 0 )) | ((unsigned long)(Gui_u32:GuiVal & 0x1) << 0 ) ) )) </loc>
//    <item> SFDITEM_FIELD__WWDG_WWDG_SR_EWIF </item>
//  </rtree>
//  


// ----------------------------------  Peripheral View: WWDG  -------------------------------------
// SVD Line: 24862

//  <view> WWDG
//    <name> WWDG </name>
//    <item> SFDITEM_REG__WWDG_WWDG_CR </item>
//    <item> SFDITEM_REG__WWDG_WWDG_CFR </item>
//    <item> SFDITEM_REG__WWDG_WWDG_SR </item>
//  </view>
//  


// -----------------------------   IRQ Num definition: STM32G061  ---------------------------------
// SVD Line: 19



// ------------------------------------------------------------------------------------------------
// -----                              Interrupt Number Definition                             -----
// ------------------------------------------------------------------------------------------------



// ------------------------  ARM Cortex-M0 Specific Interrupt Numbers  ----------------------------

//  <qitem> Reset_IRQ
//    <name> Reset </name>
//    <i> Reset Vector, invoked on Power up and warm reset </i>
//    <loc> 1 </loc>
//  </qitem>
//  
//  <qitem> NonMaskableInt_IRQ
//    <name> NonMaskableInt </name>
//    <i> Non maskable Interrupt, cannot be stopped or preempted </i>
//    <loc> 2 </loc>
//  </qitem>
//  
//  <qitem> HardFault_IRQ
//    <name> HardFault </name>
//    <i> Hard Fault, all classes of Fault </i>
//    <loc> 3 </loc>
//  </qitem>
//  
//  <qitem> SVCall_IRQ
//    <name> SVCall </name>
//    <i> System Service Call via SVC instruction </i>
//    <loc> 11 </loc>
//  </qitem>
//  
//  <qitem> PendSV_IRQ
//    <name> PendSV </name>
//    <i> Pendable request for system service </i>
//    <loc> 14 </loc>
//  </qitem>
//  
//  <qitem> SysTick_IRQ
//    <name> SysTick </name>
//    <i> System Tick Timer </i>
//    <loc> 15 </loc>
//  </qitem>
//  


// --------------------------  STM32G061 Specific Interrupt Numbers  ------------------------------

//  <qitem> WWDG_IRQ
//    <name> WWDG </name>
//    <i> Window watchdog interrupt </i>
//    <loc> 16 </loc>
//  </qitem>
//  
//  <qitem> DMA_Channel4_5_6_7_IRQ
//    <name> DMA_Channel4_5_6_7 </name>
//    <i> DMA channel 4, 5, 6 & 7 and  DMAMUX </i>
//    <loc> 27 </loc>
//  </qitem>
//  
//  <qitem> TIM1_BRK_UP_TRG_COM_IRQ
//    <name> TIM1_BRK_UP_TRG_COM </name>
//    <i> TIM1 break, update, trigger </i>
//    <loc> 29 </loc>
//  </qitem>
//  
//  <qitem> TIM1_CC_IRQ
//    <name> TIM1_CC </name>
//    <i> TIM1 Capture Compare interrupt </i>
//    <loc> 30 </loc>
//  </qitem>
//  
//  <qitem> TIM2_IRQ
//    <name> TIM2 </name>
//    <i> TIM2 global interrupt </i>
//    <loc> 31 </loc>
//  </qitem>
//  
//  <qitem> TIM3_IRQ
//    <name> TIM3 </name>
//    <i> TIM3 global interrupt </i>
//    <loc> 32 </loc>
//  </qitem>
//  
//  <qitem> TIM6_DAC_IRQ
//    <name> TIM6_DAC </name>
//    <i> TIM6 + LPTIM1 and DAC global  interrupt </i>
//    <loc> 33 </loc>
//  </qitem>
//  
//  <qitem> TIM7_IRQ
//    <name> TIM7 </name>
//    <i> TIM7 + LPTIM2 global interrupt </i>
//    <loc> 34 </loc>
//  </qitem>
//  
//  <qitem> TIM14_IRQ
//    <name> TIM14 </name>
//    <i> TIM14 global interrupt </i>
//    <loc> 35 </loc>
//  </qitem>
//  
//  <qitem> TIM15_IRQ
//    <name> TIM15 </name>
//    <i> Timer 15 global interrupt </i>
//    <loc> 36 </loc>
//  </qitem>
//  
//  <qitem> TIM16_IRQ
//    <name> TIM16 </name>
//    <i> TIM16 global interrupt </i>
//    <loc> 37 </loc>
//  </qitem>
//  
//  <qitem> TIM17_IRQ
//    <name> TIM17 </name>
//    <i> TIM17 global interrupt </i>
//    <loc> 38 </loc>
//  </qitem>
//  
//  <qitem> I2C1_IRQ
//    <name> I2C1 </name>
//    <i> I2C1 global interrupt </i>
//    <loc> 39 </loc>
//  </qitem>
//  
//  <qitem> I2C2_IRQ
//    <name> I2C2 </name>
//    <i> I2C2 global interrupt </i>
//    <loc> 40 </loc>
//  </qitem>
//  
//  <qitem> USART1_IRQ
//    <name> USART1 </name>
//    <i> USART1 global interrupt </i>
//    <loc> 43 </loc>
//  </qitem>
//  
//  <qitem> USART2_IRQ
//    <name> USART2 </name>
//    <i> USART2 global interrupt </i>
//    <loc> 44 </loc>
//  </qitem>
//  
//  <qitem> CEC_IRQ
//    <name> CEC </name>
//    <i> CEC global interrupt </i>
//    <loc> 46 </loc>
//  </qitem>
//  
//  <irqtable> STM32G061_IRQTable
//    <name> STM32G061 Interrupt Table </name>
//    <nvicPrioBits> 4 </nvicPrioBits>
//    <qitem> Reset_IRQ </qitem>
//    <qitem> NonMaskableInt_IRQ </qitem>
//    <qitem> HardFault_IRQ </qitem>
//    <qitem> SVCall_IRQ </qitem>
//    <qitem> PendSV_IRQ </qitem>
//    <qitem> SysTick_IRQ </qitem>
//    <qitem> WWDG_IRQ </qitem>
//    <qitem> DMA_Channel4_5_6_7_IRQ </qitem>
//    <qitem> TIM1_BRK_UP_TRG_COM_IRQ </qitem>
//    <qitem> TIM1_CC_IRQ </qitem>
//    <qitem> TIM2_IRQ </qitem>
//    <qitem> TIM3_IRQ </qitem>
//    <qitem> TIM6_DAC_IRQ </qitem>
//    <qitem> TIM7_IRQ </qitem>
//    <qitem> TIM14_IRQ </qitem>
//    <qitem> TIM15_IRQ </qitem>
//    <qitem> TIM16_IRQ </qitem>
//    <qitem> TIM17_IRQ </qitem>
//    <qitem> I2C1_IRQ </qitem>
//    <qitem> I2C2_IRQ </qitem>
//    <qitem> USART1_IRQ </qitem>
//    <qitem> USART2_IRQ </qitem>
//    <qitem> CEC_IRQ </qitem>
//  </irqtable>


// ------------------------------------   Menu: STM32G061  ----------------------------------------
// SVD Line: 19



// ------------------------------  Peripheral Menu: 'STM32G061'  ----------------------------------



// ------------------------------------------------------------------------------------------------
// -----                                       Main Menu                                      -----
// ------------------------------------------------------------------------------------------------

//  <b> ADC
//    <m> ADC </m>
//  </b>
//  
//  <b> CEC
//    <m> HDMI_CEC </m>
//  </b>
//  
//  <b> CRC
//    <m> CRC </m>
//  </b>
//  
//  <b> DAC
//    <m> DAC </m>
//  </b>
//  
//  <b> DMAMUX
//    <m> DMAMUX </m>
//  </b>
//  
//  <b> I2C
//    <m> I2C1 </m>
//    <m> I2C2 </m>
//  </b>
//  
//  <b> IWDG
//    <m> IWDG </m>
//  </b>
//  
//  <b> LPTIM
//    <m> LPTIM1 </m>
//    <m> LPTIM2 </m>
//  </b>
//  
//  <b> TIM
//    <m> TIM1 </m>
//    <m> TIM2 </m>
//    <m> TIM3 </m>
//    <m> TIM6 </m>
//    <m> TIM7 </m>
//    <m> TIM14 </m>
//    <m> TIM15 </m>
//    <m> TIM16 </m>
//    <m> TIM17 </m>
//  </b>
//  
//  <b> USART
//    <m> USART1 </m>
//    <m> USART2 </m>
//  </b>
//  
//  <b> VREFBUF
//    <m> VREFBUF </m>
//  </b>
//  
//  <b> WWDG
//    <m> WWDG </m>
//  </b>
//  
